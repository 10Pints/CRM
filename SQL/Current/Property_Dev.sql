/*
Parameters:

--------------------------------------------------------------------------------
 Type                         : Params
--------------------------------------------------------------------------------
 CreateMode                   : Create
 Database                     : Property_Dev
 DisplayLog                   : True
 DisplayScript                : True
 IndividualFiles              : False
 Instance                     : 
 IsExprtngData                : False
 LogFile                      : D:\Logs\CRM_backup_250914-1859.log
 LogLevel                     : Info
 Name                         : CRM_config
 RequiredAssemblies           : System.Collections.Generic.List`1[System.String]
 RequiredSchemas              : System.Collections.Generic.List`1[System.String]
 RequiredFunctions            : System.Collections.Generic.List`1[System.String]
 RequiredProcedures           : System.Collections.Generic.List`1[System.String]
 RequiredTables               : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedDataTypes : System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedTableTypes: System.Collections.Generic.List`1[System.String]
 RequiredUserDefinedTypes     : System.Collections.Generic.List`1[System.String]
 RequiredViews                : System.Collections.Generic.List`1[System.String]
 Want All:                 : Assembly False
 Want All:                 : Schema False
 Want All:                 : Function True
 Want All:                 : Procedure True
 Want All:                 : Table True
 Want All:                 : UserDefinedDataType False
 Want All:                 : UserDefinedTableType False
 Want All:                 : UserDefinedType True
 Want All:                 : View False
 Want All:                 : Assembly System.Collections.Generic.List`1[System.String]
 Want All:                 : Schema System.Collections.Generic.List`1[System.String]
 Want All:                 : Function System.Collections.Generic.List`1[System.String]
 Want All:                 : Procedure System.Collections.Generic.List`1[System.String]
 Want All:                 : Table System.Collections.Generic.List`1[System.String]
 Want All:                 : UserDefinedDataType System.Collections.Generic.List`1[System.String]
 Want All:                 : UserDefinedTableType System.Collections.Generic.List`1[System.String]
 Want All:                 : UserDefinedType System.Collections.Generic.List`1[System.String]
 Want All:                 : View System.Collections.Generic.List`1[System.String]
 Script Dir                   : D:\Dev\CRM\SQL\Backups\250914-1859
 Script File                  : D:\Dev\CRM\SQL\Backups\250914-1859\Property_Dev.sql
 ScriptUseDb                  : True
 Server                       : DevI9
 AddTimestamp                 : True
 Timestamp                    : 250914-1859

 RequiredSchemas : 1
	dbo

*/

USE [Property_Dev]
GO
CREATE ASSEMBLY [RegEx]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C010300B1C625930000000000000000E00022200B0130000022000000080000000000007E40000000200000006000000000001000200000000200000400000000000000060000000000000000A0000000020000000000000300608500001000001000000000100000100000000000001000000000000000000000002A4000004F000000006000001C04000000000000000000000000000000000000008000000C000000883F0000380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E7465787400000084200000002000000022000000020000000000000000000000000000200000602E727372630000001C040000006000000006000000240000000000000000000000000000400000402E72656C6F6300000C0000000080000000020000002A000000000000000000000000000040000042000000000000000000000000000000005E400000000000004800000002000500242900006416000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001330020065000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281400000A281500000A2A000000133004007F000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1300000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281900000A281500000A2A00133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A6F1C00000A281D00000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1A00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A6F1C00000A281D00000A2A133002006A000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A282000000A6F2100000A282200000A2A00001330040084000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001282300000A6F2100000A282200000A2A133003008F000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000A282400000A282200000A2A0013300500A9000000000000000F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A0F02FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001282500000A282200000A2A0000001B3004001B010000010000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160C066F2600000A13042B1C11046F2700000A7419000001130507082517580C11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0DDE161308720100007011086F2B00000A282C00000A0DDE0009282200000A2A7E1F00000A2A00011C000002009F0029C80015000000000000DE001AF800161B0000011B30040035010000020000110F00281000000A2D4E0F01281000000A2D450F02281000000A2D3C0F00FE16140000016F1100000A6F1200000A2C280F01FE16140000016F1100000A6F1200000A2C140F02FE16140000016F1100000A6F1200000A2D067E1F00000A2A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A05281700000A281800000AA51F000001281E00000A0A066F1C00000A163E8C000000066F1C00000A8D1E0000010B160D066F2600000A13042B1C11046F2700000A7419000001130507092517580D11056F2100000AA211046F2800000A2DDBDE151104751A000001130611062C0711066F2900000ADC000F02FE16140000016F1100000A0713071107282A00000A0CDE161308720100007011086F2B00000A282C00000A0CDE0008282200000A2A7E1F00000A2A000000011C00000200B90029E20015000000000000F8001A1201161B000001133002008A0000000000000002282D00000A2D03162B011703282D00000A2D03162B01186004282D00000A2D03162B011A6005282D00000A2D03162B011E600E04282D00000A2D03162B021F10600E05282D00000A2D03162B021F20600E06282D00000A2D03162B021F40600E07282D00000A2D03162B052000010000600E08282D00000A2D03162B05200002000060281D00000A2A0000133002005C000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000A281B00000A2A1330040076000000000000000F00281000000A2D310F01281000000A2D280F00FE16140000016F1100000A6F1200000A2C140F01FE16140000016F1100000A6F1200000A2D02142A0F00FE16140000016F1100000A0F01FE16140000016F1100000AD01F000001281600000A04281700000A281800000AA51F000001281E00000A2A0000133002003C000000030000110274190000010A03066F2E00000A281D00000A811600000104066F2F00000A281D00000A811600000105066F2100000A282200000A733000000A512A42534A4201000100000000000C00000076342E302E33303331390000000005006C00000034050000237E0000A0050000A805000023537472696E677300000000480B00001C00000023555300640B0000100000002347554944000000740B0000F00A000023426C6F620000000000000002000001471502000900000000FA0133001600000100000023000000020000000E0000002F000000300000001B0000000300000001000000030000000000EA020100000000000600DA01B70306004702B7030600F90085030F00D70300000600210116030600BD01160306008901160306002E0216030600FA01160306001302160306003801160306000D0198030600EB00980306006C01160306005301770206008304FF020A00A8014A030A0031004A030A000B03EE030A009102EE030E00A10503040A000100EE030E00280303040600650322040E00B802030406007E00FF0206003803FF020600720022040A005D04EE0306009D02FF020E00430403040600C300FF0206008A00FF0206000603FF020E00D0000304000000000A00000000000100010081011000A10500004100010001005020000000009600B002EF000100C4200000000096001505F80003005021000000009600D70403010600C8210000000096004C050C0108005822000000009600A40217010B00D022000000009600050520010D00602300000000960040002B011000FC23000000009600F30436011300B4240000000096006D042B011700F8250000000096003B0536011A005827000000009600350443011E00F027000000009600DA025A0127005828000000009600270563012900DC2800000000960083056E012C00000001006D05000002004203000001006D05000002004203000003005004000001006D05000002004203000001006D05000002004203000003004304000001006D05000002004203000001006D05000002004203000003004304000001006D0500000200420300000300BF04000001006D0500000200420300000300BF04000004004304000001006D05000002004203000003007A04000001006D0500000200420300000300730500000400430400000100D80000000200B90000000300C80000000400280000000500AE00000006004E00000007008A0400000800620500000900AE04000001006D05000002004203000001006D0500000200420300000300430400000100D602020002009B0502000300CF0202000400BE0209007F03010011007F03060019007F030A0029007F03100031007F03100039007F03100041007F03100049007F03100051007F03100059007F03100061007F03150069007F03100071007F03100079007F03100089007F030600A100F4021A0081009B021E00F100C40222009900FA022600A900B6022A0099009604300001019C003600B100A2043F00110181044500A900B6024D00B100FA025500A900E6035900B900E9042200B10096046000A900E6036600A100FA026F00A900B8027300190165021E00A10096047A00A900B8028000A90046008900A90046009000B9007103AC00C100CB04B100C1007A051A00D100E3000600F1007304B500D90066001E00F1006604BC0099006F02D5001901910522001901C4022200E9007F03E00020007B00C4022E000B007C012E00130085012E001B00A4012E002300AD012E002B00BB012E003300F3012E003B00F9012E004300AD012E004B0014022E005300F3012E005B00F3012E0063003F022E006B0069022E007300760240007B007D0360007B003A0480007B00F704A0007B00B805C0007B006F06E0007B002A0700017B00E30720017B00A00840017B00580960017B00140A80017B00CD0AA0017B00CD0A9900C200DB000480000001000000000000000000000000008B050000040000000000000000000000E6001F0000000000040000000000000000000000E600130000000000040000000000000000000000E600FF0200000000000000000053716C496E743332003C4D6F64756C653E0053797374656D2E44617461006D73636F726C696200436F6D70696C656400446174614163636573734B696E640052656765785F5265706C6163650049676E6F72655061747465726E57686974657370616365006765745F4D6573736167650049456E756D657261626C650049446973706F7361626C650052756E74696D655479706548616E646C65004765745479706546726F6D48616E646C650053696E676C654C696E65004D756C74694C696E650054797065004578706C69636974436170747572650049676E6F72654361736500446973706F736500477569644174747269627574650044656275676761626C6541747472696275746500436F6D56697369626C6541747472696275746500417373656D626C795469746C6541747472696275746500417373656D626C7954726164656D61726B417474726962757465005461726765744672616D65776F726B41747472696275746500417373656D626C7946696C6556657273696F6E41747472696275746500417373656D626C79436F6E66696775726174696F6E4174747269627574650053716C46756E6374696F6E41747472696275746500417373656D626C794465736372697074696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E7341747472696275746500417373656D626C7950726F6475637441747472696275746500417373656D626C79436F7079726967687441747472696275746500417373656D626C79436F6D70616E794174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465006765745F56616C7565006F705F547275650053797374656D2E52756E74696D652E56657273696F6E696E670053716C537472696E6700546F537472696E670052656765785F4D617463680052656765785F49734D61746368006D61746368006765745F4C656E677468006C656E677468006F626A0052656765785F4D617463685F416C6C0052656745782E646C6C006765745F49734E756C6C0053797374656D00456E756D0053716C426F6F6C65616E0053797374656D2E5265666C656374696F6E004D61746368436F6C6C656374696F6E00457863657074696F6E007061747465726E004D6963726F736F66742E53716C5365727665722E5365727665720049456E756D657261746F7200476574456E756D657261746F72002E63746F720053797374656D2E446961676E6F73746963730053797374656D2E52756E74696D652E496E7465726F7053657276696365730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F646573004D6174636865730053797374656D2E446174612E53716C54797065730053797374656D2E546578742E526567756C617245787072657373696F6E730053797374656D2E436F6C6C656374696F6E730052656765785F4F7074696F6E730052656765784F7074696F6E730072656765784F7074696F6E730053716C436861727300436F6E6361740052656765785F466F726D617400666F726D617400546F4F626A656374005269676874546F4C656674006F705F496D706C69636974006F705F4578706C696369740043756C74757265496E76617269616E74007265706C6163656D656E74006765745F43757272656E740052656765785F4D617463685F436F756E74006765745F436F756E740052656765785F5265706C6163655F4F70740052656765785F4D617463685F4F70740052656765785F49734D617463685F4F70740052656765785F4D617463685F416C6C5F4F70740052656765785F466F726D61745F4F70740052656765785F4D617463685F436F756E745F4F70740045434D4153637269707400696E707574006F7574707574004D6F76654E6578740046696C6C526F77005265674578006765745F496E64657800696E6465780052656765780000001745007800630065007000740069006F006E003A00200000000000CA0849E65B60614FBB66A50C49F81C3400042001010803200001052001011111042001010E0420010102032000020320000E032000080306114D050002020E0E050001114D020800011280811180850500010811590700021C12808108070003020E0E117D03061159060002125D0E0E050001115908080003125D0E0E117D0306115106000212650E0E05000111510E08000312650E0E117D0600030E0E0E0E0800040E0E0E0E117D120709125D1D0E080E1261126512691D1C126D04200012610320001C0600020E0E1D1C0500020E0E0E120709125D1D0E0E081261126512691D1C126D05000102114D040701126505200101115108B77A5C561934E089080002114D115111510A0003114D1151115111590800021159115111510A000311591151115111590800021151115111510A000311511151115111590A000311511151115111510C0004115111511151115111591600091159114D114D114D114D114D114D114D114D114D0800021271115111510A000312711151115111590D0004011C1011591011591012750801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F7773010801000200000000000D01000853514C5265676578000037010032526567756C61722045787072657373696F6E732073616D706C6520617373656D626C7920666F722053514C2053657276657200000501000000001A0100154D6963726F736F667420436F72706F726174696F6E00002A010025436F7079726967687420C2A92032303232204D6963726F736F667420436F72706F7261746500002901002439316233393038372D636434382D343633622D613838632D63346566323038303464623400000C010007312E302E302E3000004D01001C2E4E45544672616D65776F726B2C56657273696F6E3D76342E372E320100540E144672616D65776F726B446973706C61794E616D65142E4E4554204672616D65776F726B20342E372E3280B701000300540E044E616D650D52656765785F49734D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F49734D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F4D617463685F436F756E745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BF01000300540E044E616D651552656765785F4D617463685F436F756E745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B501000300540E044E616D650B52656765785F4D617463685455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B901000300540E044E616D650F52656765785F4D617463685F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F5265706C6163655455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BB01000300540E044E616D651152656765785F5265706C6163655F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B601000300540E044E616D650C52656765785F466F726D61745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080BA01000300540E044E616D651052656765785F466F726D61745F4F70745455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630080B701000300540E044E616D650D52656765785F4F7074696F6E735455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D342E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E6973746963002001000100540E1146696C6C526F774D6574686F644E616D650746696C6C526F770000000000004A84A98800000000020000006A000000C03F0000C02100000000000000000000000000001000000000000000000000000000000052534453AC0D2DF91B817E4284EDEAC96F1DA1BE01000000443A5C4465765C53514C5F434C525C53514C5F434C525F362E305F646F6E745F776F726B5F696E5F73716C5F7365727665725C53716C52656745785C6F626A5C52656C656173655C52656745782E706462005240000000000000000000006C4000000020000000000000000000000000000000000000000000005E400000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C00000000000000FF2500200010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058600000C00300000000000000000000C00334000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000001000000000000000100000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B00420030000010053007400720069006E006700460069006C00650049006E0066006F000000FC02000001003000300030003000300034006200300000007E003300010043006F006D006D0065006E0074007300000052006500670075006C00610072002000450078007000720065007300730069006F006E0073002000730061006D0070006C006500200061007300730065006D0062006C007900200066006F0072002000530051004C002000530065007200760065007200000000004C001600010043006F006D00700061006E0079004E0061006D006500000000004D006900630072006F0073006F0066007400200043006F00720070006F0072006100740069006F006E0000003A0009000100460069006C0065004400650073006300720069007000740069006F006E0000000000530051004C005200650067006500780000000000300008000100460069006C006500560065007200730069006F006E000000000031002E0030002E0030002E003000000034000A00010049006E007400650072006E0061006C004E0061006D0065000000520065006700450078002E0064006C006C0000006E00250001004C006500670061006C0043006F007000790072006900670068007400000043006F0070007900720069006700680074002000A9002000320030003200320020004D006900630072006F0073006F0066007400200043006F00720070006F007200610074006500000000002A00010001004C006500670061006C00540072006100640065006D00610072006B00730000000000000000003C000A0001004F0072006900670069006E0061006C00460069006C0065006E0061006D0065000000520065006700450078002E0064006C006C000000320009000100500072006F0064007500630074004E0061006D00650000000000530051004C005200650067006500780000000000340008000100500072006F006400750063007400560065007200730069006F006E00000031002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000031002E0030002E0030002E00300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000C000000803000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = SAFE
GO

GO
CREATE ASSEMBLY [tSQLtCLR]
FROM 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C01030095AB0D620000000000000000E00022200B013000004A000000080000000000006A69000000200000008000000000001000200000000200000400000000000000040000000000000000C0000000020000FEC60000030040850000100000100000000010000010000000000000100000000000000000000000186900004F000000008000001C0400000000000000000000000000000000000000A000000C000000E06700001C0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E746578740000007049000000200000004A000000020000000000000000000000000000200000602E727372630000001C0400000080000000060000004C0000000000000000000000000000400000402E72656C6F6300000C00000000A00000000200000052000000000000000000000000000040000042000000000000000000000000000000004C6900000000000048000000020005005C3400000433000009000000000000000000000000000000606700008000000000000000000000000000000000000000000000000000000000000000000000001E02281200000A2A133004005400000001000011731300000A0A160B022803000006731400000A0C7201000070731500000A13042B261104096F1600000A2C1C0717580B0607096F1700000A186F1800000A281900000A6F1A00000A086F1B00000A250D2DD0062A5E0F00281C00000A2D080F00281D00000A2A72210000702A13300200270000000200001102A50200001B0A031200281E00000A281F00000A8118000001041200282000000A81140000012A001B3003006500000003000011140A18732100000A0B2806000006732200000A0A066F2300000A732400000A25066F2500000A250F01FE16140000016F2600000A6F2700000A6F2800000A26DE0A072C06076F2900000ADCDE170C722300007008730A0000067A062C06066F2A00000ADC2A00000001280000020009003841000A00000000000002004B4D000D1C00000102000200585A000A000000001330040046000000040000117344000006256F490000060A6F4A0000060B732B00000A2572D8000070066F2C00000A2572F0000070178C4A0000016F2C00000A257218010070076F2C00000A6F2D00000A2A1E02282E00000A2A220203282F00000A2A26020304283000000A2A26020304283100000A2A3A02281200000A02037D010000042A7A0203280F000006027B01000004027B010000046F460000066F4F0000062A220203280F0000062A4A027B01000004036F4B0000066F3200000A2A6A283300000A6F3400000A6F3500000A6F2600000A281900000A2A56283300000A6F3400000A6F3600000A283700000A2A00001330040032000000050000117238010070283800000A0A1200FE16270000016F2600000A725C01007072210000706F3900000A283A00000A281900000A2A00001B3005001A020000060000110F00281C00000A2C0B7260010070732F00000A7A0F01281C00000A2C0C7221000070281900000A10010F02281C00000A2C0C7221000070281900000A100273440000060F000F0128190000060A06281900000A6F4B00000604281A0000060B160C07166F3B00000A8E698D4F0000010D076F3C00000A13072B371207283D00000A13081613092B1D09110909110994110811099A6F3E00000A283F00000A9E110917581309110911088E6932DB0817580C1207284000000A2DC0DE0E1207FE160400001B6F2900000ADC16130A2B1809110A09110A94209B000000284100000A9E110A1758130A110A098E6932E116130409130B16130C2B16110B110C94130D110417110D58581304110C1758130C110C110B8E6932E211041758130411040817585A13041713051104734200000A1306076F3C00000A130738AE0000001207283D00000A130E11052D0811066F4300000A2616130F2B2B110672960100706F4400000A110E110F9A281800000609110F9428170000066F4400000A26110F1758130F110F110E8E6932CD110672960100706F4400000A2611052C5016130511066F4300000A261613102B2B1106729A0100706F4400000A26110611066F4500000A725C010070091110946F4600000A261110175813101110110E8E6932CD1106729A0100706F4400000A261207284000000A3A46FFFFFFDE0E1207FE160400001B6F2900000ADC11066F2600000A281900000A734700000A2A0000011C00000200780044BC000E0000000002003901C1FA010E000000001330050035000000070000110228160000060A729E010070731500000A0F00FE16140000016F2600000A720202007017066F4800000A281900000A734700000A2A327E04000004026F4900000A2A000013300200FA000000080000110F00FE16140000016F2600000A6F4A00000A0A150B160C160D16130438C900000008450600000005000000330000003F00000053000000760000008C00000038A00000000611049328150000063A92000000061104931F2D3307170C3883000000061104931F2F3304190C2B7711040B2B72061104931F2D336A180C2B66061104931F0D2E08061104931F0A3356160C2B52061104931F2A33081A0C0917580D2B42091631041A0C2B3A7220020070732F00000A7A061104931F2A33021B0C061104931F2F331D190C2B19061104931F2F330F0917590D092D04160C2B061A0C2B021A0C1104175813041104068E692F0707163F29FFFFFF072A9202734B00000A16723A02007003026F3E00000A59284600000A6F2600000A283A00000A2AD2026F3E00000A209B000000312502161F4B6F4C00000A723E02007002026F3E00000A1F4B591F4B6F4C00000A284D00000A2A022A133003004500000009000011724A02007002FE16140000016F2600000A283A00000A0A03FE16140000016F2600000A6F3E00000A16311806726802007003FE16140000016F2600000A284D00000A0A062A00000013300400860200000A000011026F4E00000A0A734F00000A0B066F5000000A6F5100000A0C0F01FE16140000016F2600000A72210000706F5200000A2C47088D420000010D1613042B2A066F5000000A11046F5300000A13050911041105727E0200706F5400000A6F2600000AA211041758130411040832D107096F5500000A38000200000F01281B000006735600000A130613071613082B2E110711089A130911096F3E00000A2C18110611097294020070729A0200706F3900000A6F5700000A110817581308110811078E6932CA0711066F5800000A6F5500000A38A3010000088D42000001130A16130B387E01000002110B6F5900000A2C0F110A110B729E020070A2385F010000066F5000000A110B6F5300000A72AC0200706F5400000AA52F000001130C110C1F0F3024110C1A59450400000074000000B8000000D6000000FC000000110C1F0F2E523805010000110C1F133BE8000000110C1F153BDF000000110C1F1F59450400000005000000D9000000590000006D00000038D4000000110A110B02110B6F5A00000A285B00000A281D000006A238CA000000110A110B02110B6F5A00000A285B00000A281F000006A238AE000000110A110B02110B6F5A00000A285B00000A281E000006A23892000000110A110B02110B6F5A00000A2820000006A22B7E110A110B02110B6F5C00000A2821000006A22B6A110A110B02110B6F5D00000A130D120DFE16300000016F2600000AA22B4C110A110B02110B6F5E00000A130E120E285F00000A130F120F72C6020070286000000AA22B26110A110B02110B6F6100000A2822000006A22B12110A110B02110B6F6200000A6F2600000AA2110B1758130B110B026F6300000A3F75FEFFFF07110A6F5500000A026F6400000A3A52FEFFFF072A9A72F002007002FE16140000016F2600000A72F6020070284D00000A72FC020070286500000A2A8202720803007072210000706F3900000A729A02007072210000706F3900000A2A5E720C0300700F00286600000A8C33000001286700000A2A5E722A0300700F00286600000A8C33000001286700000A2A5E72620300700F00286600000A8C33000001286700000A2A72728C0300700F00286800000A736900000A8C33000001286700000A2A4672CC030070028C34000001286700000A2A00000013300300440000000B000011734B00000A7214040070284400000A0A0F00286A00000A0B160C2B1B0708910D061203721A040070286B00000A6F4400000A260817580C08078E6932DF066F2600000A2A2E7220040070732F00000A7A1A736C00000A7A00133004004100000000000000736D00000A251F20176F6E00000A251F0A176F6E00000A251F0D176F6E00000A251F09176F6E00000A251F0C176F6E00000A251F0B176F6E00000A80040000042A3A02281200000A02037D050000042A1B300300340000000C000011020328300000060A020428300000060B027B0500000406076F4D000006DE140C027B05000004086F6F00000A6F4E000006DE002A01100000000000001F1F0014070000021B300200370000000D000011140A027B05000004036F4B0000060A066F6400000A26030628320000060B030728330000060728340000060CDE07062831000006DC082A0001100000020002002C2E0007000000002A022C06026F3200000A2A001B3003002F0000000E000011036F4E00000A0ADE240B72940400700F00FE16140000016F2600000A72B0040070284D00000A07732C0000067A062A000110000000000000090900241D0000019A032D2272940400700F00FE16140000016F2600000A72F8040070284D00000A732B0000067A2A001B3005000D0100000F00001172210000700A026F5000000A6F7000000A0B38D3000000076F7100000A742E0000010C0872340500706F5400000A6F2600000A7246050070287200000A39A8000000067208030070283A00000A0A026F7300000A6F7000000A0D2B64096F7100000A74390000011304110428350000062C4E1C8D42000001251606A225177250050070A2251811046F7400000AA225197254050070A2251A0811046F7400000A6F5400000A252D0426142B056F2600000AA2251B7258050070A2287500000A0A096F7600000A2D94DE1409753A000001130511052C0711056F2900000ADC06729A020070283A00000A0A076F7600000A3A22FFFFFFDE1407753A000001130511052C0711056F2900000ADC062A000000011C000002005A0070CA00140000000002001200E5F7001400000000AA026F7400000A725C0500701B6F7700000A2D15026F7400000A72620500701B6F7700000A16FE012A162A3A02281200000A02037D060000042A000013300400A30000001000001102032838000006027B06000004046F4B0000060A160B066F6300000A1631270717580B07281F00000A03287800000A287900000A2C080628390000062B08066F7A00000A2DD9066F3200000A07281F00000A03287B00000A287900000A2C431B8D420000012516726C050070A225171201287C00000AA22518729E050070A225190F01FE16180000016F2600000AA2251A72D0050070A2287500000A732B0000067A2A001330030054000000110000110316281F00000A287B00000A0A06287900000A2D14060F01287D00000A287E00000A287F00000A2B0106287900000A2C2272F40500700F01FE16180000016F2600000A7252060070284D00000A732B0000067A2A13300200290000001200001102283C0000060A288000000A06738100000A6F8200000A0206283A000006288000000A6F8300000A2A722B11288000000A0203283B0000066F8400000A026F6400000A2DE72A000013300300230000001300001103738100000A026F6300000A8D0F0000010A02066F8500000A2625066F8600000A262A001B3003005100000014000011026F4E00000A283D000006256F8700000A8D3C0000010A160B6F8800000A0C2B151202288900000A0D060709283E000006A20717580B1202288A00000A2DE2DE0E1202FE160800001B6F2900000ADC062A0000000110000002001F002241000E000000001B3002006600000015000011738B00000A0A026F5000000A6F7000000A0B2B35076F7100000A742E0000010C0872340500706F5400000A6F2600000A6F8C00000A726E060070287200000A2C0806086F8D00000A26076F7600000A2DC3DE1107753A0000010D092C06096F2900000ADC062A000001100000020012004153001100000000133005006D010000160000110272AC0200706F5400000AA52F0000010A02727E0200706F5400000A74420000010B0272780600706F5400000A74400000010C064523000000050000000D000000050000000D000000050000004B000000050000000500000005000000050000000D0000000500000026000000050000000500000005000000050000000500000005000000050000000500000026000000260000000500000086000000050000008600000086000000860000007D0000008600000005000000050000004B0000004B00000038810000000706738E00000A2A070602728A0600706F5400000AA54F0000016A738F00000A2A02728A0600706F5400000AA54F0000010D0920FF7F00003102150D0706096A738F00000A2A07060272A00600706F5400000A289000000A289100000A0272C20600706F5400000A289000000A289100000A739200000A2A070608739300000A2A72DC0600701200FE162F0000016F2600000A72F2060070284D00000A739400000A7A4A7344000006732E00000602036F2F0000062A4A7344000006733600000602036F370000062A327307000006026F050000062A467344000006730C000006026F0D0000062A467344000006730C000006026F0E0000062A3602281200000A0228470000062A72027B090000042D0D02284800000602177D0900000402289500000A2A1E027B080000042A9E02739600000A7D07000004027B07000004723A0700706F9700000A027B070000046F2300000A2A32027B070000046F9800000A2A13300300260000000900001102726C070070281900000A284B000006256F6400000A2625166F9900000A0A6F3200000A062A32027B070000046F9A00000A2A00133003004D00000000000000027E9B00000A7D08000004027B0700000402FE064C000006739C00000A6F9D00000A732400000A25027B070000046F2500000A250F01FE16140000016F2600000A6F2700000A1A6F9E00000A2A000000133004004400000000000000027C08000004281C00000A2C10027221000070281900000A7D0800000402027B08000004046F9F00000A72B6070070283A00000A281900000A28A000000A7D080000042A133004004E00000000000000732400000A25027B070000046F2500000A2572BC0700706F2700000A256FA100000A72EE070070036FA200000A26256FA100000A7200080070046FA200000A26251A6FA300000A6F2800000A262AF2732400000A25027B070000046F2500000A25720E0800706F2700000A256FA100000A7224080070036FA200000A26251A6FA300000A6F2800000A262A00133004004100000000000000732400000A25027B070000046F2500000A2572360800706F2700000A256FA100000A7266080070038C140000016FA200000A26251A6FA300000A6F2800000A262A00000042534A4201000100000000000C00000076322E302E35303732370000000005006C000000800F0000237E0000EC0F0000A811000023537472696E677300000000942100007008000023555300042A0000100000002347554944000000142A0000F008000023426C6F620000000000000002000001579FA2090902000000FA01330016000001000000650000000C000000100000004F0000005100000003000000A3000000080000001300000001000000160000000200000005000000050000000800000001000000040000000100000000003B0801000000000006005805630D0600ED05630D060078041C0D0F00830D00000600A3053A090600A0043A0906003B053A09060007053A090600D4053A09060078053A090600EC043A0906008C04440D0600BE0577080600B7043A090600C90E77080A002605A50C0A00D301A50C0600CA02870E0A009105A50C0A00C906920D0600370011010600CF0B6D000E00D710480E0A001F00920D0600280011010A00A6092D0F12009C03730E0600970A7A1106009F0A77080600290B1D0906007D101D090A00C20EA50C0A00D004A50C0600C70377080A00C002920D0A005306A50C0A003C11920D0A006504A50C0600410177080A009A0E920D0600180011010600320C5310A700E70C00000A009C0B2D0F0A009E028F000A00B8108F000A00AD038F000A001A08920D0A00E502920D0A005F03920D06006E0377080600DE0E77080600E70B6D0006006F0C6D000600830877080600D80C870E0A00BA088F000600D60277080A008808920D0A00BC00A50C0A00E201A50C0E0012001101FB00E70C00000600CC0377080A00E60D2D0F0600A20777080600DC0B6D001200EA09730E0A009909A90A0A009B012D0F0A005501A90A0A00250C2D0F0A000B0CA90A06008B0877080A008F0BA90A060030113A09060052033A090600F50877080600220077080600E50777080A0078098F000A00E6038F000600E802770806001506770806000D0A77080A004C098F000600E70A77080A00A510A50C0A009403A50C0E000100110106001D0B08090600AA0F77080600FB0B77080600670A770806004D0077080E00630F25080A00470C2D0F0A00C80C8F000A0061092D0F0A00620C2D0F0A00BB038F00000000004400000000000100010001001000670E77003D0001000100000010000C0D77003D000100050001201000340A770075000100080000001000FF0C77003D0001000C00090110004A047700890002001000012010004D0A7700750005002A00000010008C0C77003D0005002E00000010007C0C77003D000600360081011000A70D77003D0007003F0000001000030277003D000700440003010000B80D0000DD000A00500001001602900451805000940451805C0097043100F8019A040100160290040100160290040100C209A204010072027D0301003501A60406068000970456801A0FA9045680CB07A9045680BB07A9045680DA07A90456805E0BA90456806D0BA9045020000000008618F20C060001005820000000009600E60FAD040100B8200000000091008607B4040200D020000000009100D90FBA04030004210000000086000B0648010600A0210000000091000E04C50407005020000000008618F20C06000700F221000000008618F20C06000700FA21000000008618F20C100007000322000000008618F20CA00008000D22000000008418F20CA7000A001722000000008618F20CC9040C002622000000008300A80248010D0045220000000083003B1048010E004E220000000083006F0148010F006122000000009600360BCF0410007C220000000096000D11D404100094220000000096003303CF041000D4220000000096001207DA04100018250000000096007506E604130059250000000091004D0BEE0414006825000000009100D909F30415006E26000000009100C508F90416009326000000009100F507FF041800C826000000009100530F040519001C27000000009100DD100E051B00AE29000000009100BA0F1D051D00D5290000000091005D04FF041E00F6290000000091004A0725051F000E2A000000009100360725052000262A0000000091002007250521003E2A000000009100FD062C0522005B2A0000000091005A0733052300702A00000000910074073A052400C02A000000009608510841052500C02A00000000E6095A0855002500C02A000000009600440446052500C02A00000000C6007D073E002600CC2A00000000E6012C014D052600CC2A00000000E601570454052700D42A000000009118F80C5B052800F221000000008618F20C06002800FA21000000008618F20C100028000322000000008618F20CA00029000D22000000008418F20CA7002B00212B000000008618F20CC9042D00302B0000000086009B005F052E00802B000000008100A60167053000D42B000000009100B50B6D053100E02B0000000091008602740532002C2C0000000091008A117F053400542C0000000091009B06880536008C2D000000009100BC0A8F053700B72D000000008618F20CC9043800C82D0000000086008E1096053900782E000000008100770B9E053B00D82E0000000091002F0D6D053C000D2F000000009100C800A4053D002C2F000000009100DD00AF053F005C2F000000009100ED0EBC054100CC2F000000009100340EC60542005030000000009100CF08D4054300C9310000000096009B00DD054400DC310000000096007C0CE5054600EF31000000009600B409ED054800FC310000000096002D10ED0549000E320000000096003B10ED054A002032000000008618F20C06004B002E3200000000E6013C0406004B004B320000000086085402F3054B005332000000008100D30E06004B007B32000000008100D00E06004B00883200000000860824033E004B00BA32000000008608F9023E004B00C8320000000086007E01F8054B002433000000008400640200064C0074330000000086000D0E08064E00CE33000000008600790A100050000C340000000086001B1048015100000001006F10000001006F1000000100CF1002000200F80A02000300FD0800000100C401000001007E02000001007E0200000200250A000001003B0B00000200B01000000100160200000100C40100000100C40100000100C40100000100EF0200000200010A00000300CE0F00000100430F000001002A0100000100430F00000100151000000200050800000100FB0000000100EF0200000200010A00000100F40B00000200F80F00000100CE0F000001001903000001003A06000001003A06000001003A06000001003A06000001003106000001004611000001001510000001001A0D00000100D110000001007E02000001007E0200000200250A000001003B0B00000200B010000001001602000001005F01000002008D0100000100C40100000100F40B00000100C40100000200F40B00000100C40100000200880000000100880000000100EA0800000100160200000100110B00000200C40100000100110B00000100AA0B00000100AA0B00000200030100000100AA0B00000200030100000100AA0B000001008800000001001A0E000001005F01000002008D0100000100050B00000200C40100000100C40100000100C40100000100C40100000100BC0100000100400C00000200FE0D00000100AD0600000200BC0600000100350200000100B31006008D00060091000B00E9000900F20C01001100F20C06001900F20C0A002900F20C10003100F20C10003900F20C10004100F20C10004900F20C10005100F20C10005900F20C10006100F20C15006900F20C15007100F20C10008100F20C06009900F20C06000901F20C1A003101F20C06007900F20C06000C00F20C0600B100F20C1000B900F20C1000B900B307390011027E083E001102A9074200A100080F47000C0031014D00190277033E00A1005A085500A1001A063E00140005116B00C100080F700014001A067600D900F20C8400D100F20C10002902B10806003102F20C060031028A098B0079007D073E0039025F101000390250119100D1013C0406002902360406004102F20C060049026E089A004902D3063E00E900F20C0600E900F20C1000E900F20CA000E900F20CA70059023604060061022411AF0061024A03B5006902F108BB0069029F08C1002901080FC60039013E01D4001102F001DA001102BB0EE0001C00650814011C00E40C1A0124006D0F6B001102EA0791008102D3102C0124004A1055008102B6082C015101F20C01005101800332015101CC0138015101EA0791005101A30F3F014101F20C4801B900F00152012C00181161011102F91071015101F20C06001102A90776011102BB0E7C0159028F02B2011C00F20C06006901B20EB8019102790F91001102130E390089026508BE0171016508C5011C003101CA013400F20C060034003101CA013400F110D70159024808DD0159026B03E2019101080FE9016101DB0EF20161011708F9016101E202000289011A06070299027D070B026101391110025902420617025902830F910059022C015500B900140F1C0291011A0623021102C20E29029901030E2F029901F20C330229011A06C100A1027D070B02A902F20C06002C00F20C06002C0031014D00E90029023E009102E40C6E02C1016D0F740211026C1178026901280E7E02C9010A033E001102BB0E8402C1014A10550011020C088A02C10060119902D9014B06A3025902220F5500C1009308990279027D073E00C1005A085500D901080FB002D901400BB702C1028B03CA02E901F20CD002C902920FD802C90246010600C902C010D8026101CF0DE402E901DC0DE4023C00790F91003C00E40C060344006D0F6B0044004A1055003C00F20C06001102C00C3E003C00B20F2D03E101F20C4403E101F20C4C03D902D1035503E10213065B03E101F20C6303E101F20C6D03F102F20C1000F90264067803D100F20C06002902E806100001033C04060059029F074200290201043E00A10060087D030903F20C8103D100440287033102C10B8E03090229023E00A100CD0997033102A30EA00319032406A6033902B703AE030E000800600408000C006D0408002C007204080030007704080034007C0408003800810408003C008604080040008B0424007B00DB082E000B0020062E00130029062E001B0048062E00230051062E002B007B062E00330089062E003B00B8062E004300BE062E004B00CE062E005300B8062E005B00B8062E006300D9062E006B00DF0640007300FD06C3008300AF0840028B001E0860028B001E0880028B001E080000010000000600210059007B009500CE00E6004E0167018301870138024202490253025B029202AA02C302DF02EA0219033903060001000B000300000060080E0600005E081306000066021706000028031C060000FD021C0602002300030002002400050002004600070002004900090002004A000B00310063000C0124015A01D001FD0210030480000001000000931FC90D01000000BE0377000000020000000000000000000000B503080100000000020000000000000000000000B5038F0000000000020000000000000000000000B503770800000000020000000000000000000000B503730E000000000C0006000000004C696E6B65644C6973744E6F64656031004C696E6B65644C69737460310053716C496E743332004B657956616C75655061697260320044696374696F6E6172796032003C4D6F64756C653E004743004E554C4C5F535452494E47004D41585F434F4C554D4E5F57494454480053797374656D2E494F007453514C74434C520076616C75655F5F00736368656D610053797374656D2E4461746100417373657274526573756C74536574734861766553616D654D657461446174610053716C4D657461446174610073656E64456163685265636F72644F6644617461006372656174655265636F7264506F70756C61746564576974684461746100726F7744617461006D657461006D73636F726C69620053797374656D2E436F6C6C656374696F6E732E47656E6572696300526561640041646400646973706F736564004E6577477569640053656E64526573756C7473456E64004462436F6D6D616E64006578706563746564436F6D6D616E640045786563757465436F6D6D616E640065786563757465436F6D6D616E640061637475616C436F6D6D616E640053716C436F6D6D616E6400637265617465536368656D61537472696E6746726F6D436F6D6D616E6400636F6D6D616E6400417070656E6400446174614163636573734B696E640053716C446174615265636F7264005265706C61636500576869746573706163650054657374446174616261736546616361646500746573744461746162617365466163616465006765745F4D657373616765006661696C7572654D657373616765006164645F496E666F4D657373616765006765745F496E666F4D657373616765004F6E496E666F4D65737361676500696E666F4D657373616765006D65737361676500617474656D7074546F476574536368656D615461626C6500446174615461626C6500436170747572654F7574707574546F4C6F675461626C6500494E756C6C61626C650049456E756D657261626C650049446973706F7361626C650047657453716C446F75626C65005461626C654E616D65006765745F44617461626173654E616D65006765745F436F6C756D6E4E616D6500636F6C756D6E4E616D65006765745F5365727665724E616D6500437265617465556E697175654F626A6563744E616D65004765744E616D6500417373656D626C794E616D650053716C4461746554696D65004765744461746554696D6500526561644C696E6500417070656E644C696E65006765745F506970650053716C50697065005472616E73616374696F6E53636F70650053716C446254797065007365745F436F6D6D616E64547970650056616C756554797065006765745F496E76617269616E7443756C7475726500496E7465726E616C44617461436F6C6C656374696F6E42617365006765745F446174616261736500437265617465436F6E6E656374696F6E537472696E67546F436F6E74657874446174616261736500436C6F736500446973706F7365005061727365007453514C745072697661746500577269746500756E71756F74650053716C4D6574686F644174747269627574650044656275676761626C6541747472696275746500436F6D56697369626C6541747472696275746500417373656D626C795469746C6541747472696275746500417373656D626C794B65794E616D654174747269627574650053716C55736572446566696E65645479706541747472696275746500417373656D626C7954726164656D61726B41747472696275746500417373656D626C79436F6E66696775726174696F6E4174747269627574650053716C46756E6374696F6E41747472696275746500417373656D626C794465736372697074696F6E41747472696275746500436F6D70696C6174696F6E52656C61786174696F6E7341747472696275746500417373656D626C7950726F647563744174747269627574650053716C466163657441747472696275746500417373656D626C79436F7079726967687441747472696275746500434C53436F6D706C69616E7441747472696275746500417373656D626C79436F6D70616E794174747269627574650052756E74696D65436F6D7061746962696C697479417474726962757465004578656375746500546F42797465006765745F56616C7565004164645769746856616C75650064746F56616C756500647456616C75650047657456616C7565006F705F54727565004942696E61727953657269616C697A6500537570707265737346696E616C697A6500476574416C74657253746174656D656E74576974686F7574536368656D6142696E64696E67006275696C64536368656D61537472696E67006578706563746564537472696E670061637475616C537472696E670053716C537472696E67006765745F436F6E6E656374696F6E537472696E67007365745F436F6E6E656374696F6E537472696E670053716C4461746554696D6532546F537472696E67005461626C65546F537472696E6700536D616C6C4461746554696D65546F537472696E670053716C4461746554696D65546F537472696E670053716C44617465546F537472696E670053716C4461746554696D654F6666736574546F537472696E670053716C42696E617279546F537472696E670047657450726F636564757265546578744173537472696E6700476574537472696E6700537562737472696E670049734D617463680041667465725365636F6E6444617368004166746572466972737444617368004166746572536C617368004D617468006765745F4C656E677468005472696D546F4D61784C656E677468006C656E67746800537461727473576974680047657453716C446563696D616C0053797374656D2E436F6D706F6E656E744D6F64656C007453514C74434C522E646C6C00497344424E756C6C006765745F4E756C6C006765745F49734E756C6C006765745F4974656D007365745F4974656D0053797374656D005472696D00456E756D0053716C426F6F6C65616E006F705F4C6573735468616E004765745075626C69634B6579546F6B656E004F70656E004D696E0044617461436F6C756D6E00506164436F6C756D6E0063726561746553716C4D65746144617461466F72436F6C756D6E00636F6C756D6E006765745F56657273696F6E00416E6E6F746174696F6E0053797374656D2E476C6F62616C697A6174696F6E0053797374656D2E52756E74696D652E53657269616C697A6174696F6E0053797374656D2E5265666C656374696F6E0044617461436F6C756D6E436F6C6C656374696F6E0053716C506172616D65746572436F6C6C656374696F6E0044617461526F77436F6C6C656374696F6E007365745F436F6E6E656374696F6E004462436F6E6E656374696F6E0053716C436F6E6E656374696F6E004E6577436F6E6E656374696F6E00636F6E6E656374696F6E006F705F4164646974696F6E004765745374617274506F736974696F6E005472616E73616374696F6E53636F70654F7074696F6E004F726465724F7074696F6E004E6F74496D706C656D656E746564457863657074696F6E00696E6E6572457863657074696F6E00436F6D6D616E644578656375746F72457863657074696F6E00496E76616C6964526573756C74536574457863657074696F6E00417267756D656E74457863657074696F6E006661696C5465737443617365416E645468726F77457863657074696F6E005365637572697479457863657074696F6E0053797374656D2E446174612E436F6D6D6F6E00636F6C756D6E50726F7065727479497356616C6964466F724D65746144617461436F6D70617269736F6E00537472696E67436F6D70617269736F6E00416E6E6F746174696F6E4E6F00726573756C745365744E6F00726573756C747365744E6F0043756C74757265496E666F0053657269616C697A6174696F6E496E666F00696E666F006F705F426974776973654F720049735768697465737061636543686172004166746572536C61736853746172004166746572537461720076616C6964617465526573756C745365744E756D626572004462446174615265616465720053716C44617461526561646572006461746152656164657200636C6F7365526561646572004578656375746552656164657200537472696E6752656164657200546578745265616465720042696E617279526561646572007265616465720049466F726D617450726F7669646572004462436F6E6E656374696F6E537472696E674275696C6465720053716C436F6E6E656374696F6E537472696E674275696C6465720073656E6465720053716C496E666F4D6573736167654576656E7448616E646C65720053716C506172616D657465720042696E61727957726974657200526573756C7453657446696C746572004D65746144617461457175616C6974794173736572746572004D6963726F736F66742E53716C5365727665722E53657276657200546F4C6F77657200436F6D6D616E644265686176696F720049456E756D657261746F7200476574456E756D657261746F72002E63746F72002E6363746F72004F7574707574436170746F7200436F6D6D616E644578656375746F720053797374656D2E446961676E6F73746963730073656E64526573756C747365745265636F7264730053797374656D2E52756E74696D652E496E7465726F7053657276696365730053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300446562756767696E674D6F6465730053797374656D2E446174612E53716C54797065730053746F72656450726F63656475726573004765745374617274506F736974696F6E5374617465730047657453716C56616C7565730053657456616C7565730053716C496E666F4D6573736167654576656E74417267730061726773006765745F5469636B7300617373657274457175616C7300636F6C756D6E44657461696C73006765745F436F6C756D6E7300676574446973706C61796564436F6C756D6E730053797374656D2E546578742E526567756C617245787072657373696F6E7300416E6E6F746174696F6E730053797374656D2E5472616E73616374696F6E730053797374656D2E436F6C6C656374696F6E730053716C4368617273006765745F506172616D6574657273006765745F526F777300436F6E63617400466F726D6174004F626A65637400646973636F6E6E656374004765744461746554696D654F6666736574006372656174654D65746144617461466F72526573756C74736574006F705F496D706C696369740053706C69740044656661756C74004E657874526573756C740053797374656D2E446174612E53716C436C69656E740063726561746553746174656D656E740067657453716C53746174656D656E7400436F6D706F6E656E74006765745F43757272656E74006765745F436F756E74006765745F4669656C64436F756E740053656E64526573756C7473537461727400496E7365727400436F6E76657274004164644C6173740053706C6974436F6C756D6E4E616D654C69737400436F6C756D6E4C6973740050726F63657373526F77466F72476574416E6E6F746174696F6E4C697374005072696E744F6E6C79436F6C756D6E4E616D65416C6961734C69737400696E707574006C6F6743617074757265644F757470757400436170747572654F75747075740053757070726573734F7574707574004D6F76654E6578740053797374656D2E54657874007365745F436F6D6D616E64546578740070726F636564757265546578740053747265616D696E67436F6E746578740073656E6453656C6563746564526573756C74536574546F53716C436F6E7465787400636F6E746578740044617461526F770053656E64526573756C7473526F7700726F77004D6178005265676578006765745461626C65537472696E67417272617900546F417272617900546F436861724172726179006765745F4B6579005369676E696E674B657900436F6E7461696E734B657900476574457865637574696E67417373656D626C790047657453716C42696E6172790073716C42696E61727900457865637574654E6F6E5175657279006F705F457175616C697479006F705F496E657175616C6974790053797374656D2E5365637572697479007468726F77457863657074696F6E4966536368656D614973456D70747900001F5E005C0073002A002D002D005C005B0040007400530051004C0074003A0001010080B34500720072006F007200200063006F006E006E0065006300740069006E006700200074006F002000640061007400610062006100730065002E00200059006F00750020006D006100790020006E00650065006400200074006F00200063007200650061007400650020007400530051004C007400200061007300730065006D0062006C007900200077006900740068002000450058005400450052004E0041004C005F004100430043004500530053002E0000174400610074006100200053006F007500720063006500002749006E0074006500670072006100740065006400200053006500630075007200690074007900001F49006E0069007400690061006C00200043006100740061006C006F00670000237400530051004C0074005F00740065006D0070006F0062006A006500630074005F0000032D0001354F0062006A0065006300740020006E0061006D0065002000630061006E006E006F00740020006200650020004E0055004C004C0000037C0000032B0000634300520045004100540045005C0073002B00560049004500570028005C0073002A002E002A003F005C0073002A00290057004900540048005C0073002B0053004300480045004D004100420049004E00440049004E0047005C0073002B0041005300001D41004C00540045005200200056004900450057002400310041005300001975006E006500780070006500630074006500640020002F0000032000000B3C002E002E002E003E00001D530045004C0045004300540020002A002000460052004F004D002000001520004F0052004400450052002000420059002000001543006F006C0075006D006E004E0061006D00650000055D005D0000035D00000D21004E0055004C004C0021000019500072006F00760069006400650072005400790070006500002930002E0030003000300030003000300030003000300030003000300030003000300045002B00300000055D002C0000052C005B00000B5C005D002C005C005B0000035B00001D7B0030003A0079007900790079002D004D004D002D00640064007D0001377B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D003A00730073002E006600660066007D0001297B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D007D00013F7B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D003A00730073002E0066006600660066006600660066007D0001477B0030003A0079007900790079002D004D004D002D00640064002000480048003A006D006D003A00730073002E00660066006600660066006600660020007A007A007A007D0001053000780000055800320000737400530051004C007400500072006900760061007400650020006900730020006E006F007400200069006E00740065006E00640065006400200074006F002000620065002000750073006500640020006F0075007400730069006400650020006F00660020007400530051004C0074002100001B540068006500200063006F006D006D0061006E00640020005B0000475D00200064006900640020006E006F0074002000720065007400750072006E00200061002000760061006C0069006400200072006500730075006C0074002000730065007400003B5D00200064006900640020006E006F0074002000720065007400750072006E0020006100200072006500730075006C0074002000730065007400001149007300480069006400640065006E000009540072007500650000037B0000033A0000037D0000054900730000094200610073006500003145007800650063007500740069006F006E002000720065007400750072006E006500640020006F006E006C00790020000031200052006500730075006C00740053006500740073002E00200052006500730075006C00740053006500740020005B0000235D00200064006F006500730020006E006F0074002000650078006900730074002E00005D52006500730075006C007400530065007400200069006E00640065007800200062006500670069006E007300200061007400200031002E00200052006500730075006C007400530065007400200069006E0064006500780020005B00001B5D00200069007300200069006E00760061006C00690064002E0000097400720075006500001144006100740061005400790070006500001543006F006C0075006D006E00530069007A00650000214E0075006D00650072006900630050007200650063006900730069006F006E0000194E0075006D0065007200690063005300630061006C006500001541007200670075006D0065006E00740020005B0000475D0020006900730020006E006F0074002000760061006C0069006400200066006F007200200052006500730075006C007400530065007400460069006C007400650072002E00003143006F006E007400650078007400200043006F006E006E0065006300740069006F006E003D0074007200750065003B000049530045004C004500430054002000530045005200560045005200500052004F0050004500520054005900280027005300650072007600650072004E0061006D006500270029003B0001050D000A0000317400530051004C0074002E0041007300730065007200740045007100750061006C00730053007400720069006E006700001145007800700065006300740065006400000D410063007400750061006C0000157400530051004C0074002E004600610069006C0000114D006500730073006100670065003000002F7400530051004C0074002E004C006F006700430061007000740075007200650064004F0075007400700075007400000974006500780074000054E676F0AE1C744AB26E0953546BB50500042001010803200001052001011111042001010E0420010102062001011180810F0705151255020811510812590E125D0715125502081151042001020E0320000E0420010E0805000111510E072002011300130103200002090701151165020811510715116502081151042000130005000111610804200013010807031269126D127106200101118111052001011269032000080407020E0E052002010E1C062002010E1275072002011279117D0500001281310520001281350520001281390420001D050700011180951D0505070111809D05000011809D0520020E0E0E0500020E0E0E2507110E151280A5011D0E081D0808021280A9151180AD011D0E1D0E08081D0808081D0E080807151280A5011D0E052001130008092000151180AD01130007151180AD011D0E0500020808080520001280A90620011280A90E0820031280A9080E08052001011151030701080720040E0E0E0808061512550203020520010213000907051D0308113008080420001D030520020E08080600030E0E0E0E0307010E2A07101280B5151280A5011D0E081D0E081280B9151280A5010E1D0E080E1D0E081180BD1180C11180C50D0520001280B50520001281450620011280B9080420011C0E05200101130006151280A5010E0520001D130004200102080620011180CD080800011180C91180CD0620011180D1080620011180C1080620011180C5080320000D0420010E0E062001118095080420011C080600021D0E0E0E0520001180CD0500020E0E1C0320000A042001010A0907041280A91D0508050607030E0E121C0907031280B11280B50E0707021280B512751207060E1280E11280B91280E11280E51280E90520001280E10320001C050002020E0E0520001281590500010E1D0E072002020E11815D0607021280B1080900021180ED11611161060001021180ED0507011180ED0600011180ED020B00021180ED1180ED1180ED0607011D1280F1050000128165072001011D1280F1062001011280F50407011D1C052001081D1C1207041D1280F108151180FD011280B91280B908151280F9011280B9092000151180FD01130008151180FD011280B9130704151280F9011280B91280E11280B91280E90B20011512816901130013000A07041180BD0E12810108072002010E1180BD082003010E1180BD0A05000012816D070002051C128175092004010E1180BD05050A2003010E1180BD128101040001011C03061151052002011C18062001011281850820011280B111818908000211511151115105200012818D0720021281910E1C0620010111819508B77A5C561934E08980A00024000004800000940000000602000000240000525341310004000001000100B9AF416AD8DFEDEC08A5652FA257F1242BF4ED60EF5A7B84A429604D62C919C5663A9C7710A7C5DF9953B69EC89FCE85D71E051140B273F4C9BF890A2BC19C48F22D7B1F1D739F90EEBC5729555F7F8B63ED088BBB083B336F7E38B92D44CFE1C842F09632B85114772FF2122BC638C78D497C4E88C2D656C166050D6E1EF3940C21004E0055004C004C002100049B0000000400000000040100000004020000000403000000040400000004050000000306122C02060E02060807061512550203020306126902060203061130060001124911510500010E11510A0003011C1011611011510300000E05200101122C04000011510500001180950B00031280A11151115111510700011280A1115104000102030500010811510500020E0E080400010E0E0900020E1011511011510E0002151280A5011D0E1280B111510700011D0E1011510600010E1180C90600010E1180CD0600010E1180D10600010E118095040000111806000111181151062001011280D5062001011280D90300000107200201115111510520010E1151060001011280B10A00021280B511511280B10800020111511280B50600010E1280B5060001021280E507200201116111510520010111610A0002011280B11D1280F10C00021280F51280B11D1280F10900011D1280F11280B10D0001151280F9011280B91280B50800011280F11280B90700020111511151070002011161115105000101115104200011510720011280B11151072002011C128105052002010E0E04080011180328000204280011510328000E0801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F77730108010002000000000029010024436F7079726967687420C2A9202073716C6974792E6E65742032303130202D203230313500000D0100087453514C74434C5200002E010029434C527320666F7220746865207453514C7420756E69742074657374696E67206672616D65776F726B00000501000000000F01000A73716C6974792E6E657400000A0100057453514C7400000501000100001D0100187453514C745F4F6666696369616C5369676E696E674B65790000811F010005005455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D322E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A446174614163636573730000000054020F497344657465726D696E69737469630154020949735072656369736501540E0F5461626C65446566696E6974696F6E2A416E6E6F746174696F6E4E6F20494E542C20416E6E6F746174696F6E204E56415243484152284D415829540E1146696C6C526F774D6574686F644E616D651E50726F63657373526F77466F72476574416E6E6F746174696F6E4C697374808F010001005455794D6963726F736F66742E53716C5365727665722E5365727665722E446174614163636573734B696E642C2053797374656D2E446174612C2056657273696F6E3D322E302E302E302C2043756C747572653D6E65757472616C2C205075626C69634B6579546F6B656E3D623737613563353631393334653038390A44617461416363657373010000002B010002000000020054080B4D61784279746553697A650100000054020D497346697865644C656E6774680112010001005408074D617853697A65FFFFFFFF0000EB06C2A28199175C1922F5244EB4E5C34276704E2B0009A88E85A27E4741464DB89E7361541154C9F705E6DD8FAA066C344E1BFA5475F9A78F2A40EFE883C693BC06F9E884930BA96DC66A978A6B46E807369489DB3AC6281D56A59DA5B714A02FAFC53F42C54D07638EB7A28B148F5BFA306AFC47356B5C63AD86B42E68C0510000000095AB0D6200000000020000001C010000FC670000FC490000525344537D89B6DEAF5FB54A96906274BAF65C4F01000000443A5C615C315C7453514C745C7453514C74434C525C7453514C74434C525C6F626A5C437275697365436F6E74726F6C5C7453514C74434C522E706462000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004069000000000000000000005A6900000020000000000000000000000000000000000000000000004C690000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000FF250020001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058800000C00300000000000000000000C00334000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE0000010000000100C90D931F00000100C90D931F3F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B00420030000010053007400720069006E006700460069006C00650049006E0066006F000000FC02000001003000300030003000300034006200300000006C002A00010043006F006D006D0065006E0074007300000043004C0052007300200066006F007200200074006800650020007400530051004C007400200075006E00690074002000740065007300740069006E00670020006600720061006D00650077006F0072006B00000036000B00010043006F006D00700061006E0079004E0061006D00650000000000730071006C006900740079002E006E0065007400000000003A0009000100460069006C0065004400650073006300720069007000740069006F006E00000000007400530051004C00740043004C005200000000003C000E000100460069006C006500560065007200730069006F006E000000000031002E0030002E0038003000380033002E00330035003200390000003A000D00010049006E007400650072006E0061006C004E0061006D00650000007400530051004C00740043004C0052002E0064006C006C00000000006C00240001004C006500670061006C0043006F007000790072006900670068007400000043006F0070007900720069006700680074002000A90020002000730071006C006900740079002E006E00650074002000320030003100300020002D002000320030003100350000002A00010001004C006500670061006C00540072006100640065006D00610072006B007300000000000000000042000D0001004F0072006900670069006E0061006C00460069006C0065006E0061006D00650000007400530051004C00740043004C0052002E0064006C006C00000000002C0006000100500072006F0064007500630074004E0061006D006500000000007400530051004C007400000040000E000100500072006F006400750063007400560065007200730069006F006E00000031002E0030002E0038003000380033002E003300350032003900000044000E00010041007300730065006D0062006C0079002000560065007200730069006F006E00000031002E0030002E0038003000380033002E00330035003200390000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000C0000006C3900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
WITH PERMISSION_SET = EXTERNAL_ACCESS
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 18-DEC-2019
-- Description: case sensitive compare helper function
-- Returns:     1 if match false 0
-- =============================================
CREATE FUNCTION [dbo].[fnCaseSensistiveCompare]
(
    @exp        VARCHAR(MAX)
   ,@act        VARCHAR(MAX)
)
RETURNS BIT
AS
BEGIN
   IF @exp IS NULL AND @act IS NULL
      RETURN 1;
   IF (@exp IS NULL     AND @act IS NOT NULL) OR
      (@exp IS NOT NULL AND @act IS NULL)
      RETURN 0;
   RETURN IIF( @exp COLLATE Latin1_General_CS_AS  = @act COLLATE Latin1_General_CS_AS
   , 1, 0);
END
/*
   
   IF (@expected IS NULL)
      SET @exp_is_null = 1;
   IF (@actual IS NULL)
      SET @act_is_null = 1;
   IF (@exp_is_null = 1) AND (@act_is_null = 1)
      RETURN 1;
   IF (@exp_is_null = 1) AND (@act_is_null = 1)
      RETURN 1;
   IF ( dbo.fnLEN(@expected) = 0) AND ( dbo.fnLEN(@actual) = 0)
      RETURN 1;
   SET @exp = CONVERT(VARBINARY(8000), @expected);
   SET @act = CONVERT(VARBINARY(8000), @actual);
   IF (@exp = 0x) AND (@act = 0x)
   BEGIN
      SET @res = 1;
   END
   ELSE
   BEGIN
      IF @exp = @act
         SET @res = 1;
      ELSE
         SET @res = 0;
   END
   -- ASSERTION @res is never NULL
   RETURN @res;
END
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================
-- Author:      Terry Watts
-- Create date: 04-JAN-2021
-- Description: determines if a sql_variant is an
-- approximate type: {float, real or numeric}
-- test: [test].[t 025 fnIsFloat]
-- ================================================
CREATE FUNCTION [dbo].[fnIsFloatType](@ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('float','real','numeric'), 1, 0);
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is of type GUID
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsGuidType](@v SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   RETURN iif(CONVERT(VARCHAR(500), SQL_VARIANT_PROPERTY(@v, 'BaseType')) = 'uniqueidentifier', 1, 0);
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is an
-- integral type: {int, smallint, tinyint, bigint, money, smallmoney}
-- test: [test].[t 025 fnIsFloat]
--
-- Changes:
-- 241128: added optional check for non negative ints
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsIntType]( @ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('BIT','INT','SMALLINT','TINYINT','BIGINT','MONEY','SMALLMONEY'), 1, 0);
END
/*
SELECT dbo.fnIsInt('0',0) as [fnIsInt('0', 0)], dbo.fnIsInt('05',0) as [fnIsInt(05,0)]
SELECT dbo.fnIsInt('0',1) as [fnIsInt('0',1)], dbo.fnIsInt('05',1) as [dbo.fnIsInt('05',1)]
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =====================================================================
-- Author:      Terry Watts
-- Create date: 31-OCT-2024
-- Description: determines if @ty is a text datatype
-- e.g. 'VARCHAR' is a text type
-- 
-- PRECONDITIONS: @ty is just the datatype without ()
-- e.g. 'VARCHAR' is OK but 'VARCHAR(20)' the output is undefined
-- =====================================================================
CREATE FUNCTION [dbo].[fnIsTextType](@ty   VARCHAR(500))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('char','nchar','varchar','nvarchar'), 1, 0);
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_097_fnIsTextType';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: Returns true if a time type
--              Handles single and array types like INT and VARCHAR(MAX)
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsTimeType](@ty VARCHAR(20))
RETURNS BIT
AS
BEGIN
   RETURN iif(@ty IN ('date','datetime','datetime2','datetimeoffset','smalldatetime','TIME'), 1, 0);
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: Gets the type category for a Sql Uerver datatype
-- e.g. Exact types : INT, MONEY 
-- Floating point types: float real
--
-- TESTS:
-- ===================================================================
CREATE FUNCTION [dbo].[fnGetTypeCat](@ty VARCHAR(25))
RETURNS VARCHAR(25)
AS
BEGIN
   DECLARE @type SQL_VARIANT
   ;
   RETURN
      CASE
         WHEN dbo.fnIsIntType (@ty)     = 1 THEN 'Int'
         WHEN dbo.fnIsTextType(@ty)     = 1 THEN 'Text'
         WHEN dbo.fnIsTimeType(@ty) = 1 THEN 'Time'
         WHEN dbo.fnIsFloatType(@ty)    = 1 THEN 'Float'
         WHEN dbo.fnIsGuidType(@ty)     = 1 THEN 'GUID'
         END;
END
/*
EXEC test.sp__crt_tst_rtns '[dbo].[fnGetTypeCat]';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================
-- Author:      Terry Watts
-- Create date: 01-FEB-2021
-- Description: determines if a sql_variant is of type BIT
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsBoolType](@v SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   RETURN iif( @v = 'bit', 1,0);
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =========================================================
-- Author:      Terry Watts
-- Create date: 05-JAN-2021
-- Description: function to compare values - includes an
--              approx equal check for floating point types
-- Returns 1 if equal, 0 otherwise
-- =========================================================
CREATE FUNCTION [dbo].[fnChkEquals]( @a SQL_VARIANT, @b SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   DECLARE
    @fn     VARCHAR(35)   = N'sp_fnChkEquals'
   ,@res    BIT
   ,@a_str  VARCHAR(4000) = CONVERT(VARCHAR(400), @a)
   ,@b_str  VARCHAR(4000) = CONVERT(VARCHAR(400), @b)
   ,@a_ty   VARCHAR(25)   = CONVERT(VARCHAR(25), SQL_VARIANT_PROPERTY(@a, 'BaseType'))
   ,@b_ty   VARCHAR(25)   = CONVERT(VARCHAR(25), SQL_VARIANT_PROPERTY(@b, 'BaseType'))
   ;
   -- NULL check
   IF @a IS NULL AND @b IS NULL
   BEGIN
      RETURN 1;
   END
   IF @a IS NULL AND @b IS NOT NULL
   BEGIN
      RETURN 0;
   END
   IF @a IS NOT NULL AND @b IS NULL
   BEGIN
      RETURN 0;
   END
   -- if both are floating point types, fnCompareFloats evaluates  fb comparison to accuracy +- epsilon
   -- any differnce less that epsilon is consider insignifacant so considers and b to =
   -- fnCompareFloats returns 1 if a>b, 0 if a==b, -1 if a<b
   IF (dbo.[fnIsFloatType](@a_ty) = 1) AND (dbo.[fnIsFloatType](@b_ty) = 1)
   BEGIN
      RETURN iif(dbo.[fnCompareFloats](CONVERT(FLOAT(24), @a), CONVERT(FLOAT(24), @b)) = 0, 1, 0);
   END
   -- if both are int types
   IF (dbo.fnIsIntType(@a_ty) = 1) AND (dbo.fnIsIntType(@b_ty) = 1)
      RETURN iif(CONVERT(BIGINT, @a) = CONVERT(BIGINT, @b), 1, 0);
   -- if both are string types
   IF (dbo.fnIsTextType(@a_ty) = 1) AND (dbo.fnIsTextType(@b_ty) = 1)
      RETURN iif(@a_str = @b_str, 1, 0);
   -- if both are boolean types
   IF (dbo.fnIsBoolType(@a_ty) = 1) AND (dbo.fnIsBoolType(@b_ty) = 1)
      RETURN iif(CONVERT(BIT, @a) = CONVERT(BIT, @b), 1, 0);
   -- if both are datetime types
   IF (dbo.fnIsTimeType(@a_ty) = 1) AND (dbo.fnIsTimeType(@b_ty) = 1)
      RETURN iif( CONVERT(DATETIME, @a) = CONVERT(DATETIME, @b), 1, 0);
   -- if both are guid types
   IF (dbo.fnIsGuidType(@a_ty) = 1) AND (dbo.fnIsGuidType(@b_ty) = 1)
      RETURN iif(CONVERT(UNIQUEIDENTIFIER, @a) = CONVERT(UNIQUEIDENTIFIER, @b), 1, 0);
   ----------------------------------------------------
   -- Compare by type cat
   ----------------------------------------------------
   DECLARE
    @a_cat  VARCHAR(25)
   ,@b_cat  VARCHAR(25)
   SET @a_cat = [dbo].[fnGetTypeCat](@a_ty);
   SET @b_cat = [dbo].[fnGetTypeCat](@b_ty);
   if(@a_cat = @b_cat)
   BEGIN
      IF @a_cat = 'Int'
      BEGIN
         SET @res = iif(CONVERT(BIGINT, @a) = CONVERT(BIGINT, @b), 1, 0);
      END
      ELSE IF @a_cat = 'Float'
      BEGIN
         SET @res = iif(CONVERT(FLOAT(24), @a) = CONVERT(FLOAT(24), @b), 1, 0);
      END
      ELSE IF @a_cat = 'Text'
      BEGIN
         SET @res = iif(CONVERT(VARCHAR(8000), @a) = CONVERT(VARCHAR(8000), @b), 1, 0);
      END
      ELSE IF @a_cat = 'Time'
      BEGIN
         SET @res = iif(CONVERT(DATETIME2, @a) = CONVERT(DATETIME2, @b), 1, 0);
      END
      ELSE IF @a_cat = 'GUID'
      BEGIN
         SET @res = iif(CONVERT(UNIQUEIDENTIFIER, @a) = CONVERT(UNIQUEIDENTIFIER, @b), 1, 0);
      END
      RETURN @res;
   END
   ----------------------------------------------------------------------
   -- Can compare Floats with integral types -> convert both to big float
   ----------------------------------------------------------------------
   IF (@a_cat='Int' AND @b_cat='Float') OR (@a_cat='Float' AND @b_cat='Int')
   BEGIN
      RETURN iif(CONVERT(FLOAT(24), @a) = CONVERT(FLOAT(24), @b), 1, 0);
   END
   ----------------------------------------------------
   -- Final option: compare by converting to text
   ----------------------------------------------------
   SET @res = iif(@a_str = @b_str, 1, 0)
   RETURN @res;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================================================
-- Author:      Terry Watts
-- Create date: 13-JAN-2020
-- Description: determines if a character is whitespace
--
-- whitespace is: 
-- (NCHAR(9), NCHAR(10), NCHAR(11), NCHAR(12), NCHAR(13), NCHAR(14), NCHAR(32), NCHAR(160))
--
-- RETURNS: 1 if is whitspace, 0 otherwise
-- ===============================================================================================
CREATE FUNCTION [dbo].[fnIsWhitespace]( @t NCHAR) 
RETURNS BIT
AS
BEGIN
   RETURN CASE WHEN  @t IN (NCHAR(9) , NCHAR(10), NCHAR(11), NCHAR(12)
                           ,NCHAR(13), NCHAR(14), NCHAR(32), NCHAR(160)) THEN 1 
              ELSE 0 END
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry Watts
-- Create date: 08-JAN-2020
-- Description: fnLen deals with the trailing spaces bug in Len
-- ===============================================================
CREATE  FUNCTION [dbo].[fnLen]( @v VARCHAR(8000))
RETURNS INT
AS
BEGIN
   RETURN CASE
            WHEN @v IS NULL THEN 0
            ELSE Len(@v+'x')-1
            END;
END
/*
EXEC test.sp__crt_tst_rtns 'dbo].[fnLen]', 43;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==========================================================================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2021
-- Description: determines if the string contains whitespace
--
-- whitespace is: 
-- (NCHAR(9), NCHAR(10), NCHAR(11), NCHAR(12), NCHAR(13), NCHAR(14), NCHAR(32), NCHAR(160))
--
-- RETURNS: 1 if string contains whitspace, 0 otherwise
-- ==========================================================================================
CREATE FUNCTION [dbo].[fnContainsWhitespace]( @s VARCHAR(4000))
RETURNS BIT
AS
BEGIN
   DECLARE
       @res       BIT = 0
      ,@i         INT = 1
      ,@len       INT = dbo.fnLen(@s)
   WHILE @i <= @len
   BEGIN
      IF dbo.fnIswhitespace(SUBSTRING(@s, @i, 1))=1
      BEGIN
         SET @res = 1;
         break;
      END
      SET @i = @i + 1;
   END
   RETURN @res;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry Watts
-- Create date: 17-JUN-2025
-- Description: generates the sql to check if every value 
--    in field @fld_nm of the table @q_table_nm
--    can be cast to the type @ty
-- Tests      : test_075_fnCrtFldNotNullSql
--
-- Postconditions: returns the check SQL for the given parameters
-- ===============================================================
CREATE FUNCTION [dbo].[fnCrtFldNotNullSql]
(
    @q_table_nm VARCHAR(60)
   ,@fld_nm     VARCHAR(40)
   ,@ty         VARCHAR(25)
)
RETURNS NVARCHAR(4000)
AS
BEGIN
     DECLARE @sql NVARCHAR(4000)
     ;
     SET @sql =
     CONCAT
     (
'IF NOT EXISTS
(
   SELECT 1 FROM ',@q_table_nm,'
   WHERE TRY_CAST([',@fld_nm,'] AS ',@ty,') IS NULL
)
   SET @fld_ty = ''',@ty,'''
ELSE
   SET @fld_ty = NULL
;'
     );
     RETURN @sql;
END
/*
EXEC test.sp__crt_tst_rtns '[dbo].[fnCrtFldNotNullSql]'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ============================================================
-- Author     : Terry Watts
-- Create date: 12-APR-2025
-- Description: removes double quotes an Line feeds from data
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:     EA
-- Tests:      test_018_fnCrtRemoveDoubleQuotesSql
--             test_037_sp_import_txt_file
-- ============================================================
CREATE FUNCTION [dbo].[fnCrtRemoveDoubleQuotesSql]
(
    @table              VARCHAR(60)
   ,@max_len_fld        INT
)
RETURNS VARCHAR(8000)
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)       = N'sp_import_txt_file'
   ,@table_no_brkts     VARCHAR(60)
   ,@nl                 CHAR(2)           = CHAR(13)+CHAR(10)
   ,@sql                VARCHAR(8000)
   ,@empty_str          VARCHAR(2)=''''
   ,@double_quote       VARCHAR(5)='"'
   ;
   SET @table_no_brkts = REPLACE(REPLACE(@table, '[',''),  ']','');
   --    SELECT dbo.fnPadRight(CONCAT(''['', column_name, '']''), ', @max_len_fld+2, ') AS column_name
SET @sql = CONCAT
(
'DECLARE
    @nl             CHAR(2) = CHAR(13)+CHAR(10)
   ,@Lf             CHAR(1) = CHAR(10)
   ,@empty_str      VARCHAR(1)=''''
   ,@double_quote   VARCHAR(1)=''"''
   ,@sql            VARCHAR(8000)
;
WITH cte AS
(
   SELECT CONCAT(''['', column_name, '']'') AS column_name
      ,ROW_NUMBER() OVER (ORDER BY ORDINAL_POSITION) AS row_num
      ,ordinal_position
      ,DATA_TYPE
      ,is_txt
   FROM list_table_columns_vw
   WHERE table_name = ''',@table_no_brkts, ''' AND is_txt = 1
)
,cte2 AS
(
   SELECT ''UPDATE ',@table,' SET '' AS sql
   UNION ALL
   SELECT
      CONCAT
      (  iif(row_num=1, '' '','','')
        ,column_name, '' = 
        TRIM(REPLACE(REPLACE('',column_name',','',CHAR(34),''',@empty_str,''''')
        ,CHAR(10),''',@empty_str,'''''
            )
         )''
      )
   FROM cte
   UNION ALL
   SELECT ''FROM ',@table,';''
)
SELECT @sql = 
string_agg(sql, ''', @NL, ''')
FROM cte2;'
);
   RETURN @sql;
END
/*
EXEC tSQLt.Run 'test.test_018_fnCrtRemoveDoubleQuotesSql';
EXEC tSQLt.Run 'test.test_037_sp_import_txt_file';
------------------------------------------------
DECLARE @sql VARCHAR(8000)
SELECT @sql = dbo.fnCrtRemoveDoubleQuotesSql('[User]', 12);
PRINT @sql
------------------------------------------------
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_<fn_nm>;
*/
GO

SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER OFF
GO
CREATE FUNCTION [dbo].[Regex_Replace](@input [nvarchar](max), @pattern [nvarchar](max), @replacement [nvarchar](max))
RETURNS [nvarchar](max) WITH EXECUTE AS CALLER
AS 
EXTERNAL NAME [RegEx].[Regex].[Regex_Replace]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================
-- Author:      Terry Watts
-- Create date: 16-JUN-2025
-- Description: checks if a word is a reserved word
--
-- Design:      Deepseek
-- Tests:       test.test_071_IsReservedWord
-- ==================================================================
CREATE FUNCTION [dbo].[fnIsReservedWord](@word NVARCHAR(128))
RETURNS BIT
AS
BEGIN
    DECLARE @isReserved BIT = 0;
    -- We do UPPER incase we're working in a SQL 
    SET @word = UPPER(LTRIM(RTRIM(@word)));
    SET @isReserved = 
      CASE 
         WHEN @word IN
(
  'ABS', 'ADD', 'ADDRESS', 'ALL', 'ALTER', 'AND', 'ANY', 'AS', 'ASC', 'AUTHORIZATION'
, 'BACKUP', 'BEGIN', 'BETWEEN', 'BIY', 'BREAK', 'BROWSE', 'BULK', 'BY'
, 'CASCADE', 'CASE', 'CAST', 'CHAR', 'CHARINDEX', 'CHAR_LENGTH', 'CHECK', 'CHECKPOINT'
, 'CEILING', 'CLOSE', 'CLUSTERED'
, 'COALESCE', 'COLLATE', 'COL_LENGTH', 'COL_NAME', 'COLUMN', 'COMMIT', 'COMPUTE', 'CONSTRAINT'
, 'CONTAINS', 'CONTAINSTABLE', 'CONTINUE', 'CONVERT', 'CREATE'
, 'CROSS', 'CURRENT', 'CURRENT_DATE', 'CURRENT_TIME'
, 'CURRENT_TIMESTAMP', 'CURRENT_USER', 'CURSOR', 'DATABASE', 'DATE', 'DBCC'
, 'DEALLOCATE', 'DECLARE', 'DEFAULT', 'DELETE', 'DENY', 'DESC'
, 'DISK', 'DISTINCT', 'DESCRIPTION', 'DISTRIBUTED', 'DOUBLE', 'DROP', 'DUMMY'
, 'DUMP', 'ELSE', 'END', 'ERRLVL', 'ESCAPE', 'EXCEPT', 'EXEC'
, 'EXECUTE', 'EXISTS', 'EXIT'
 , 'FETCH', 'FILE', 'FILLFACTOR', 'FLOAT', 'FOR'
, 'FOREIGN', 'FREETEXT', 'FREETEXTTABLE', 'FROM', 'FULL', 'FUNCTION'
, 'GOTO', 'GRANT', 'GROUP', 'HAVING', 'HOLDLOCK', 'IDENTITY'
, 'IDENTITY_INSERT', 'IDENTITYCOL', 'IF', 'IN', 'INDEX', 'INNER'
, 'INSERT', 'INT','INTERSECT', 'INTO', 'IS', 'JOIN', 'KEY', 'KILL', 'LEFT'
, 'LIKE', 'LINENO', 'LOAD', 'LOCATION', 'NAME', 'NATIONAL', 'NOCHECK', 'NONCLUSTERED'
, 'NOT', 'NULL', 'NULLIF', 'NVARCHAR', 'OF', 'OFF', 'OFFSETS', 'ON', 'OPEN'
, 'OPENDATASOURCE', 'OPENQUERY', 'OPENROWSET', 'OPENXML', 'OPTION'
, 'OR', 'ORDER', 'OUT', 'OUTER', 'OVER', 'PERCENT', 'PLAN', 'PRECISION'
, 'PRIMARY', 'PRINT', 'PROC', 'PROCEDURE', 'PUBLIC', 'RAISERROR'
, 'READ', 'REAL', 'READTEXT', 'RECONFIGURE', 'REFERENCES', 'REPLICATION'
, 'RESTORE', 'RESTRICT', 'RETURN', 'REVOKE', 'RIGHT', 'ROLLBACK'
, 'ROWCOUNT', 'ROWGUIDCOL', 'RULE', 'SAVE', 'SCHEMA', 'SELECT'
, 'SESSION_USER', 'SET', 'SETUSER', 'SHUTDOWN', 'SOME', 'STATISTICS'
, 'STATUS', 'SYSTEM_USER', 'TABLE', 'TEXTSIZE', 'THEN', 'TO', 'TOP', 'TRANSACTION'
, 'TRIGGER', 'TRUNCATE', 'TSEQUAL', 'TYPE', 'UNION', 'UNIQUE', 'UPDATE'
, 'UPDATETEXT', 'USE', 'USER', 'VALUES', 'VARCHAR', 'VARYING', 'VIEW'
, 'WAITFOR', 'WHEN', 'WHERE', 'WHILE', 'WITH', 'WRITETEXT'
)
      THEN 1
      WHEN EXISTS(SELECT 1 FROM sys.types WHERE name=@word) THEN 1
      ELSE 0
   END
    RETURN @isReserved;
END
/*
EXEC test.test_071_IsReservedWord;
*/
GO

GO
CREATE TYPE [dbo].[IdNmTbl] AS TABLE(
	[id] [int] IDENTITY(1,1) NOT NULL,
	[val] [varchar](4000) NULL,
	PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (IGNORE_DUP_KEY = OFF)
)
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================
-- Author:      Terry Watts
-- Create date: 16-JUN-2025
-- Description: delimits identifier if necessary
-- Design:      
-- Tests:       test_073_fnDeLimitIdentifier
-- ===============================================
CREATE FUNCTION [dbo].[fnDeLimitIdentifier](@q_id VARCHAR(120))
RETURNS VARCHAR(120)
AS
BEGIN
   DECLARE @v VARCHAR(120)
   DECLARE @vals IdNmTbl
   INSERT INTO @vals (val) select value from string_split(@q_id, '.');
   UPDATE @vals SET val = 
   iif(
      ((dbo.fnIsReservedWord(val)=1 OR CHARINDEX(' ', val)>0)) AND (CHARINDEX('[', val) <> 1) AND (CHARINDEX(']', val) <> dbo.fnLen(val))
   , CONCAT('[', val, ']')
   , val);
   SELECT @v = string_agg(val, '.') FROM @vals;
   RETURN @v;
END
/*
EXEC tSQLt.Run 'test.test_073_fnDeLimitIdentifier';
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_<fn_nm>;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 05-SEP-2025
-- Description: 
-- Design:      
-- Tests:       
-- =============================================
CREATE FUNCTION [dbo].[fnWrapFieldName]( @fld_nm VARCHAR(128))
RETURNS VARCHAR(128)
AS
BEGIN
   RETURN iif(dbo.fnIsReservedWord(@fld_nm)=1,CONCAT('[', @fld_nm, ']'), @fld_nm);
END
/*
EXEC tSQLt.Run 'test.test_072_fnWrapFieldName';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =================================================
-- Author:      Terry Watts
-- Create date: 13-JUN-2025
--
-- Description:
-- creates the SQL to create a table
-- based on the input string.
-- All fields are VARCHAR(MAX)
-- Delimits the qualified @tbl_nm if necessary
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    returns creat table SQL
--
-- Tests:
-- =============================================
CREATE FUNCTION [dbo].[fnCrtTblSql]
(
    @tbl_nm VARCHAR(60)
   ,@fields VARCHAR(8000)
)
RETURNS VARCHAR(8000)
AS
BEGIN
   DECLARE
       @sql      VARCHAR(8000)
      ,@joiner   VARCHAR(40)=' VARCHAR(8000)
   ,'
      ,@snippet  VARCHAR(8000)
      ,@NL       CHAR(2)     = CHAR(13) + CHAR(10)
      ,@tab      CHAR        = CHAR(9)
      ,@sep      CHAR        = CHAR(9)
;
   SET @sep = IIF(CHARINDEX( @tab,@fields)>0, @tab, ',');
   -- Replace spaces with underscores in field names
   --SET @fields = REPLACE(@fields,  ' ', '_');
   -- split the fields and add them as VARCHAR(8000)
/*   SELECT @snippet = string_agg
   (
      dbo.fnWrapFieldName(dbo.Regex_Replace(TRIM(value), '[ ]+', '_'))
     ,@joiner
   )
*/
   SELECT @snippet = string_agg
   (
      dbo.fnWrapFieldName(dbo.Regex_Replace(TRIM(value), '[ -/:]+', '_'))
     ,@joiner
   )
   FROM STRING_SPLIT(TRIM(@fields), @sep);
   SET @sql =
   CONCAT
   ('CREATE TABLE ', dbo.fnDelimitIdentifier(@tbl_nm),'
(
    '
, @snippet
, ' VARCHAR(8000)', @NL
,');'
);
   RETURN @sql;
END
/*
EXEC test.test_069_fnCrtTblSql;
PRINT dbo.fnCrtTblSql('TestTable','id, name,description, location');
EXEC tSQLt.Run 'test.test_069_fnCrtTblSql';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =================================================
-- Author:      Terry Watts
-- Create date: 24-NOV-2023
--
-- Description: removes square brackets from string
-- in any position in the string
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    [ ] brackets removed
--
-- Tests:
-- =============================================
CREATE FUNCTION [dbo].[fnDeSquareBracket](@s VARCHAR(4000))
RETURNS VARCHAR(4000)
AS
BEGIN
   RETURN REPLACE(REPLACE(@s, '[', ''), ']', '');
END
/*
   EXEC test.sp_crt_tst_rtns 'dbo.fnDeSquareBracket', 69
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry Watts
-- Create date: 30-MAR-2020
-- Description: returns true if the file exists, false otherwise
-- ===============================================================
CREATE FUNCTION [dbo].[fnFileExists](@path varchar(512))
RETURNS BIT
AS
BEGIN
     DECLARE @result INT
     EXEC master.dbo.xp_fileexist @path, @result OUTPUT
     RETURN cast(@result as bit)
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================
-- Author:      Terry Watts
-- Create date: 24-MAR-2025
-- Description: returns Last Index of a str in a str
-- or 0 if not found
-- ==================================================
CREATE FUNCTION [dbo].[fnFindLastIndexOf](@searchFor VARCHAR(100),@searchIn VARCHAR(500))
RETURNS INT
AS
BEGIN
   IF LEN(@searchfor) > LEN(@searchin)
      RETURN 0;
   DECLARE @r VARCHAR(500), @rsp VARCHAR(100)
   SELECT @r   = REVERSE(@searchin)
   SELECT @rsp = REVERSE(@searchfor)
   RETURN len(@searchin) - charindex(@rsp, @r) - len(@searchfor)+1;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================================================================
-- Author:      Terry Watts
-- Create date: 03-Nov-2023
--
-- Description: Gets the file name optionally with the extension from the supplied file path
--
-- Tests:
--
-- CHANGES:
-- 240307: added @with_ext flag parameter to signal to get either the file with or without the extension
-- ======================================================================================================
CREATE FUNCTION [dbo].[fnGetFileNameFromPath](@path VARCHAR(MAX), @with_ext BIT)
RETURNS VARCHAR(200)
AS
BEGIN
   DECLARE
    @t TABLE
    (
       id int IDENTITY(1,1) NOT NULL
      ,val VARCHAR(200)
    );
   DECLARE 
       @val VARCHAR(4000)
      ,@ndx INT = -1
   INSERT INTO @t(val)
   SELECT value from string_split(@path, NCHAR(92)); -- ASCII 92 = Backslash
   SET @val = (SELECT TOP 1 val FROM @t ORDER BY id DESC);
   IF @with_ext = 0
   BEGIN
      SET @ndx = CHARINDEX('.', @val);
      SET @val = IIF(@ndx=0, @val, SUBSTRING(@val, 1, @ndx-1));
   END
   RETURN @val;
END
/*
EXEC test.test_084_fnGetFileNameFromPath;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================================================================
-- Author:      Terry Watts
-- Create date: 05-APR-2024
-- Description: returns:
--    if @ty_nm is a text array type then returns the full type from a data type + max_len fields
--    else returns @ty_nm on its own.
--
--    This is useful when using sys rtns like sys.columns
--
-- Test: test.test_089_fnGetFullTypeName
-- ================================================================================================
CREATE FUNCTION [dbo].[fnGetFullTypeName]
(
    @ty_nm  VARCHAR(20)
   ,@len    INT
)
RETURNS VARCHAR(50)
AS
BEGIN
   RETURN 
      iif
      (
         @ty_nm in ('VARCHAR','VARCHAR')
         ,CONCAT
         (
            UPPER(@ty_nm), '('
           ,iif(@len=-1, 'MAX', FORMAT(@len, '####'))
           ,')'
         )
         ,UPPER(@ty_nm)
      );
END
/*
  PRINT dbo.fnGetFullTypeName('VARCHAR', -1);
  PRINT dbo.fnGetFullTypeName('VARCHAR', 20);
  PRINT dbo.fnGetFullTypeName('VARCHAR', 4000);
  PRINT dbo.fnGetFullTypeName('INT', 30);
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================================
-- Author:        Terry watts
-- Create date:   05-APR-2024
-- Description:   gets the output columns from a table function (TF)
-- Tests:         test_042_fnGetFnOutputCols
-- Preconditions  @q_rtn_nm is a table function
-- Postconditions OUTPUT table holds the output column meta data for the given TF
-- ===============================================================================
CREATE FUNCTION [dbo].[fnGetFnOutputCols]
(
    @q_rtn_nm     VARCHAR(60)
)
RETURNS @t TABLE
(
    name          VARCHAR(50)
   ,ordinal       INT
   ,ty_nm         VARCHAR(40)
   ,[len]         INT
   ,is_nullable   BIT
   ,is_results    BIT
)
AS
BEGIN
      INSERT INTO @t (name, ordinal, ty_nm, [len], is_nullable, is_results)
      --SELECT name, column_id as ordinal, TYPE_NAME(user_type_id) as ty_nm, max_length, is_nullable
      SELECT name, column_id as ordinal, dbo.fnGetFullTypeName(TYPE_NAME(user_type_id), max_length) as ty_nm, max_length, is_nullable, 0
      FROM sys.columns
      WHERE object_id=object_id(@q_rtn_nm)
      ORDER BY column_id
      ;
   RETURN;
END
/*
EXEC test.test_042_fnGetFnOutputCols;
SELECT * FROM dbo.fnGetFnOutputCols('test.fnCrtHlprSigParams');
SELECT * FROM dbo.fnGetFnOutputCols('test.fnCrtHlprSigParams');
SELECT name, column_id as ordinal, TYPE_NAME(user_type_id) as ty_nm, max_length, is_nullable
FROM sys.columns
WHERE object_id=object_id('test.fnCrtHlprSigParams')
ORDER BY column_id
;
SELECT *, column_id as ordinal, TYPE_NAME(user_type_id) as ty_nm, dbo.fnGetFullTypeName(TYPE_NAME(user_type_id), max_length) as ty_nm_full, max_length, is_nullable
FROM sys.columns
WHERE object_id=object_id('test.fnCrtHlprSigParams')
ORDER BY column_id
;
EXEC test.sp__crt_tst_rtns '[dbo].[fnGetFnOutputCols]';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: returns the log level key
-- =============================================
CREATE FUNCTION [dbo].[fnGetLogLevelKey] ()
RETURNS NVARCHAR(50)
AS
BEGIN
   RETURN N'LOG_LEVEL';
END
/*
EXEC test.sp_crt_tst_rtns 'dbo.fnGetLogLevelKey', 
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry Watts
-- Create date: 25-MAY-2020
-- Description: Get session context as int - default = -1
-- RETURNS      if    key/value present returns value as INT
--              if no key/value present returns NULL
--
-- See Also: fnGetSessionContextAsString, sp_set_session_context
--
-- CHANGES:
-- 14-JUL-2023: default = -1 (not found) was 0 before
-- 06-FEB-2024: simply returns value if key found else NULL
-- ===============================================================
CREATE FUNCTION [dbo].[fnGetSessionContextAsInt](@key NVARCHAR(100))
RETURNS INT
BEGIN
   RETURN CONVERT(INT, SESSION_CONTEXT(@key));
END
/*
PRINT CONCAT('[',dbo.fnGetSessionContextAsInt(N'cor_id'),']')
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 25-NOV-2023
-- Description: returns the log level
-- =============================================
CREATE FUNCTION [dbo].[fnGetLogLevel]()
RETURNS INT
AS
BEGIN
   RETURN dbo.fnGetSessionContextAsInt(dbo.fnGetLogLevelKey());
END
/*
EXEC test.sp_crt_tst_rtns 'dbo.fnGetLogLevel', 80;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 15-JAN-2020
-- Description: returns standard NL char(s)
-- =============================================
CREATE FUNCTION [dbo].[fnGetNL]()
RETURNS VARCHAR(2)
AS
BEGIN
   RETURN NCHAR(13)+NCHAR(10)
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================================================================
-- Author:      Terry watts
-- Create date: 24-APR-2024
-- Description: returns:
--   a string of n tabs (3 spcs each)
--
-- Test: test.test_086_sp_crt_tst_hlpr_script
-- ================================================================================================
CREATE FUNCTION [dbo].[fnGetNTabs]( @n    INT)
RETURNS VARCHAR(50)
AS
BEGIN
   RETURN REPLICATE(' ', @n*3);
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
  PRINT CONCAT('[',dbo.fnGetNTabs(NULL),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(-1),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(0),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(1),']');
  PRINT CONCAT('[',dbo.fnGetNTabs(3),']');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [test].[RtnDetails](
	[qrn] [varchar](90) NULL,
	[schema_nm] [varchar](60) NULL,
	[rtn_nm] [varchar](60) NULL,
	[trn] [int] NULL,
	[cora] [nchar](1) NULL,
	[ad_stp] [bit] NULL,
	[rtn_ty] [varchar](2) NULL,
	[rtn_ty_code] [varchar](2) NULL,
	[is_clr] [bit] NULL,
	[tst_rtn_nm] [varchar](50) NULL,
	[hlpr_rtn_nm] [varchar](50) NULL,
	[max_prm_len] [int] NULL,
	[sc_fn_ret_ty] [varchar](20) NULL,
	[prm_cnt] [int] NULL,
	[display_tables] [bit] NULL
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ============================================================================================================================
-- Author:      Terry Watts
-- Create date: 11-NOV-2023
-- Description: take off of MS sp_helptext
-- gets the routine definition
--
-- PRECONDITIONS:
-- test.RtnDetails table pop'd
--
-- POSTCONDITIONS:
--  POST 01: if successful returns the script
--  POST 02: if not successful returns the appropriate error message along with 
--           the corresponding negatated MS error code as follows:
--    .1: if rtn is not in the current database:                     -15250, 'Error 01: rtn is not in the current database'
--    .2: if rtn does not exist:                                     -15009, 'Error 02: rtn does not exist'
--    .3: if a system object and it is not in MASTER.sys.syscomments -15197, 'Error 03: system-object check failed'
--    .4: if rtn has no script rows:                                 -15197, 'Error 04: rtn has no lines'
--    .5: if rtn has no script rows*:                                -15471, 'Error 05: rtn has no lines*'
--
-- CHANGES:
-- 17-DEC-2024: now gets the rtn details from  test.RtnDetails table
-- ============================================================================================================================
CREATE FUNCTION [dbo].[fnGetRtnDef]()
RETURNS
@rtnDef TABLE
(
    id   INT
   ,line VARCHAR(255) --collate catalog_default
)
AS
BEGIN
   DECLARE
    @qrn VARCHAR(120) -- can be [db_nm.][schema_nm.][rtn_nm]
   ,@dbname          SYSNAME
   ,@objid           INT
   ,@BlankSpaceAdded INT
   ,@BasePos         INT
   ,@CurrentPos      INT
   ,@TextLength      INT
   ,@LineId          INT
   ,@AddOnLen        INT
   ,@LFCR            INT --Lengths of line feed carriage return
   ,@DefinedLength   INT
   ,@schema_nm       VARCHAR(50)
   ,@ad_stp          BIT            = 0
   ,@tstd_rtn        VARCHAR(100)
   ,@n               INT
   ,@SyscomText      VARCHAR(4000)
   ,@Line            VARCHAR(255)
   SELECT
       @qrn       = qrn
      ,@schema_nm = schema_nm
      ,@tstd_rtn  = rtn_nm
      ,@ad_stp    = ad_stp
   FROM test.RtnDetails;
   /* NOTE: Length of @SyscomText is 4000 to replace the length of
   ** text column in syscomments.
   ** lengths on @Line, #CommentText Text column and
   ** value for @DefinedLength are all 255. These need to all have
   ** the same values. 255 was selected in order for the max length
   ** display using down level clients
   */
   SELECT @DefinedLength = 255
   SELECT @BlankSpaceAdded = 0 --Keeps track of blank spaces at end of lines. Note Len function ignores  trailing blank spaces*/
   -- Make sure the @objname is local to the current database.
   SELECT @dbname = parsename(@qrn, 3); -- 1 = Object name, 2 = Schema name, 3 = Database name, 4 = Server name
   IF @dbname IS NULL
      SELECT @dbname = db_name();
   ELSE IF @dbname <> db_name()
   BEGIN
      -- raiserror(15250,-1,-1);
     INSERT INTO @rtnDef(id, line)  VALUES (-15250, 'Error 01: rtn is not in the current database');
     RETURN;
   END
   -- See if @objname exists.
   SELECT @objid = object_id(@qrn)
   IF (@objid IS NULL)
   BEGIN
     INSERT INTO @rtnDef(id, line)  VALUES (-15009, 'Error 02: rtn does not exist');
     RETURN;
   END
   IF @objid < 0 -- Handle system-objects
   BEGIN
      -- Check count of rows with text data
      IF (SELECT count(*) from MASTER.sys.syscomments WHERE id = @objid AND text IS NOT null) = 0
      BEGIN
         --raiserror(15197,-1,-1,@objname)
         INSERT INTO @rtnDef(id, line)  VALUES (-15197, 'Error 03: system-object check failed');
         RETURN;
      END
      DECLARE ms_crs_syscom CURSOR LOCAL FOR SELECT text FROM master.sys.syscomments WHERE id = @objid
      ORDER BY number, colid FOR READ ONLY
   END
   ELSE
   BEGIN
      -- Find out how many lines of text are coming back, and return if there are none.
      IF
      (
         SELECT count(*) 
         FROM syscomments c, sysobjects o 
         WHERE ((o.xtype NOT IN ('S', 'U')) AND (o.id = c.id AND o.id = @objid))
      ) = 0
      BEGIN
         --RAISERROR(15197,-1,-1,@objname)
         INSERT INTO @rtnDef(id, line)  VALUES (-15197, 'Error 04: rtn has no lines')
         RETURN;
      END
      IF (SELECT count(*) FROM syscomments WHERE id = @objid AND encrypted = 0) = 0
      BEGIN
         -- RAISERROR(15471,-1,-1,@objname)
         INSERT INTO @rtnDef(id, line)  VALUES (-15471, 'Error 05: rtn has no lines*')
         RETURN;
      END
      DECLARE ms_crs_syscom  CURSOR LOCAL
      FOR SELECT text FROM syscomments WHERE id = @objid AND encrypted = 0
      ORDER BY number, colid
      FOR READ ONLY
   END
   -- ASSERTION: Parameters validated
   -- else get the text
   SELECT @LFCR   = 2;
   SELECT @LineId = 1;
   OPEN ms_crs_syscom;
   FETCH NEXT from ms_crs_syscom into @SyscomText;
   WHILE @@fetch_status >= 0
   BEGIN
      SELECT  @BasePos    = 1;
      SELECT  @CurrentPos = 1;
      SELECT  @TextLength = LEN(@SyscomText);
      WHILE @CurrentPos != 0
      BEGIN
         --Looking for end of line followed by carriage return
         SELECT @CurrentPos = CHARINDEX(CHAR(13)+CHAR(10), @SyscomText, @BasePos);
         --If carriage return found
         IF @CurrentPos != 0
         BEGIN
            -- If new value for @Lines length will be > then set the length 
            -- then insert current contents of @line and proceed.
            WHILE (isnull(LEN(@Line),0) + @BlankSpaceAdded + @CurrentPos - @BasePos + @LFCR) > @DefinedLength
            BEGIN
               SELECT @AddOnLen = @DefinedLength - (ISNULL(LEN(@Line),0) + @BlankSpaceAdded);
               INSERT @rtnDef (id, line) VALUES
               (
                  @LineId
                  ,ISNULL(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N'')
               );
               SELECT
                   @Line            = NULL
                  ,@LineId          = @LineId + 1
                  ,@BasePos         = @BasePos + @AddOnLen
                  ,@BlankSpaceAdded = 0;
            END -- WHILE (isnull(LEN
            SELECT @Line    = ISNULL(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @CurrentPos-@BasePos + @LFCR), N'')
            SELECT @BasePos = @CurrentPos+2;
            INSERT @rtnDef (id, line) VALUES( @LineId, @Line);
            SELECT @LineId  = @LineId + 1;
            SELECT @Line    = NULL;
         END  -- IF @CurrentPos != 0
         ELSE --else carriage return not found
         BEGIN
            IF @BasePos <= @TextLength
            BEGIN
               --If new value for @Lines length will be > then the defined length
               WHILE (ISNULL(LEN(@Line),0) + @BlankSpaceAdded + @TextLength-@BasePos+1 ) > @DefinedLength
               BEGIN
                  SELECT @AddOnLen = @DefinedLength - (ISNULL(LEN(@Line),0) + @BlankSpaceAdded)
                  INSERT @rtnDef (id, line) VALUES
                  (
                     @LineId
                     ,ISNULL(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @AddOnLen), N'')
                  );
                  SELECT @Line = NULL, @LineId = @LineId + 1,
                  @BasePos = @BasePos + @AddOnLen, @BlankSpaceAdded = 0
               END
               SELECT @Line = isnull(@Line, N'') + ISNULL(SUBSTRING(@SyscomText, @BasePos, @TextLength-@BasePos+1 ), N'')
               IF LEN(@Line) < @DefinedLength and CHARINDEX(' ', @SyscomText, @TextLength+1 ) > 0
               BEGIN
                  SELECT @Line = @Line + ' ', @BlankSpaceAdded = 1
               END
            END
         END -- -- IF @CurrentPos != 0 ELSE
      END -- WHILE @CurrentPos != 0
      FETCH NEXT FROM ms_crs_syscom INTO @SyscomText
   END -- WHILE @@fetch_status >= 0
   IF @Line IS NOT NULL
      INSERT @rtnDef (id, line) VALUES( @LineId, @Line )
   --SELECT Text FROM CommentText ORDER BY LineId
   CLOSE       ms_crs_syscom;
   DEALLOCATE  ms_crs_syscom;
   --DROP TABLE  #CommentText
   RETURN;-- (0) -- sp_helptext
END
/*
   SELECT * FROM dbo.fnGetRtnDef();
   SELECT * FROM dbo.fnGetRtnDef('dbo.AsFloat');
   EXEC test.sp_crt_tst_rtns 'dbo.fnGetRtnDef'
   EXE tSQLt.Run 'test.test_015_fnGetRtnDesc';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==========================================================================
-- Author:      Terry Watts
-- Create date: 08-JAN-2020
-- Description: Removes specific characters from the right end of a string
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ==========================================================================
CREATE FUNCTION [dbo].[fnRTrim]
(
   @s VARCHAR(MAX)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE  
       @tcs    VARCHAR(20)
   IF (@s IS NULL ) OR (LEN(@s) = 0)
      RETURN @s;
   SET @tcs = CONCAT( NCHAR(9), NCHAR(10), NCHAR(13), NCHAR(32), NCHAR(160))
   WHILE CHARINDEX(Right(@s, 1) , @tcs) > 0 AND dbo.fnLen(@s) > 0 -- SUBSTRING(@s,  dbo.fnLen(@s)-1, 1) or Right(@s, 1)
      SET @s = SUBSTRING(@s, 1, dbo.fnLen(@s)-1); -- SUBSTRING(@s, 1, dbo.fnLen(@s)-1) or Left(@s, dbo.fnLen(@s)-1)
   RETURN @s;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================================
-- Author:      Terry Watts
-- Create date: 23-JUN-2023
-- Description: Removes specific characters from 
--              the beginning of a string
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ==================================================================
CREATE FUNCTION [dbo].[fnLTrim]
(
    @s VARCHAR(MAX)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE  
       @tcs    VARCHAR(20)
   IF (@s IS NULL ) OR (dbo.fnLen(@s) = 0)
      RETURN @s;
   SET @tcs = CONCAT( NCHAR(9), NCHAR(10), NCHAR(13), NCHAR(32), NCHAR(160))
   WHILE CHARINDEX(SUBSTRING(@s, 1, 1), @tcs) > 0 AND dbo.fnLen(@s) > 0
      SET @s = SUBSTRING(@s, 2, dbo.fnLen(@s)-1);
   RETURN @s;
END
/*
PRINT CONCAT('[', fnTrim(' '), ']')
PRINT CONCAT('[', fnLTrim(' '), ']')
PRINT CONCAT('[', fnLTrim2(' ', ' '), ']')
PRINT CONCAT('[', fnLTrim(CONCAT(0x20, 0x09, 0x0a, 0x0d, 0x20,'a', 0x20, 0x09, 0x0a, 0x0d, 0x20,' #cd# ')), ']');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================================
-- Author:      Terry Watts
-- Create date: 10-OCT-2019
-- Description: Trims leading and trailing whitesace including the 
--                normally untrimmable CHAR(160)
-- 23-JUN-2023: Fix handle all wspc like spc, tab, \n \r CHAR(160)
-- ================================================================
CREATE FUNCTION [dbo].[fnTrim]( @s VARCHAR(4000)
)
RETURNS VARCHAR(4000)
AS
BEGIN
  RETURN dbo.fnRTrim( dbo.fnLTrim(@s));
END
/*
PRINT CONCAT('[', dbo.fnTrim(CONCAT(0x20, 0x09, 0x0a, 0x0d, 0xA0, '  a  #cd# ', 0x20, 0x09, 0x0a, 0x0d, 0x0d,0xA0)), ']');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--===========================================================
-- Author:      Terry watts
-- Create date: 18-MAY-2020
-- Description: lists routine details
-- ===========================================================
CREATE VIEW [dbo].[SysRtns_vw]
AS
SELECT TOP 2000
    SCHEMA_NAME([schema_id])              AS schema_nm
   ,[name]                                AS rtn_nm
   ,IIF([type] IN ('P','PC'), 'P', 'F')   AS rtn_ty
   ,dbo.fnTrim([type])                    AS ty_code
   ,[type_desc]                           AS ty_nm
   ,IIF([type] IN ('FS','FT','PC'),1,0)   AS is_clr
   ,is_ms_shipped
   ,DATEFROMPARTS(YEAR(create_date), MONTH(create_date), Day(create_date)) AS created
   ,DATEFROMPARTS(YEAR(modify_date), MONTH(modify_date), Day(modify_date)) AS modified
FROM sys.objects
    WHERE
     [type] IN ('P', 'FN', 'TF', 'IF', 'AF', 'FT', 'IS', 'PC', 'FS')
ORDER BY [schema_nm], [type], [name]
;
/*
SELECT * FROM SysRtns_vw WHERE ty_code = 'P' AND schema_nm IN ('dbo','test')
SELECt top 500 * from sys.objects WHERE name like 'sp_%'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
--
-- Description: splits a qualified rtn name 
-- into a row containing the schema_nm and the rtn_nm
-- removes square brackets
--
-- RULES:
-- @qrn  schema   rtn
-- a.b   a        b
-- a     dbo      a
-- NULL  null     null
-- ''    null     null
--
-- Preconditions
-- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
--          but differnt schema then raise div by zero exception
-- Postconditions:
-- Post 01: if schema is not specifed then get it from the sys rtns PROVIDED ONLY ONE rtn named the @rtn_nm
-- 
-- Changes:
-- 231117: handle [ ] wrappers
-- 240403: handle errors like null @qual_rtn_nm softly as per rules above
-- 241207: changed schema from test to dbo
-- 241227: default schema is now the schema found in the sys rtns for the given rtn in @qrn
--         will throw a div by zero error if PRE 02 violated
-- ==============================================================================================================
CREATE FUNCTION [dbo].[fnSplitQualifiedName]
(
   @qrn VARCHAR(150) -- qualified routine name
)
RETURNS @t TABLE
(
    schema_nm  VARCHAR(50)
   ,rtn_nm     VARCHAR(100)
)
AS
BEGIN
   DECLARE
    @n          INT
   ,@schema_nm  VARCHAR(50)
   ,@rtn_nm     VARCHAR(100)
   -- Remove [ ] wrappers
   SET @qrn = dbo.fnDeSquareBracket(@qrn);
   IF @qrn IS NOT NULL AND @qrn <> ''
   BEGIN
      SET @n = CHARINDEX('.',@qrn);
      -- if rtn nm not qualified then assume schema = dbo
      SET @schema_nm = iif(@n=0, 'dbo',SUBSTRING( @qrn, 1   , @n-1));
      SET @rtn_nm    = iif(@n=0,  @qrn,SUBSTRING( @qrn, @n+1, dbo.fnLen(@qrn)-@n))
      -- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
      --          but differnt schema then raise div by zero exception
      IF( CHARINDEX('.', @qrn) = 0)
      BEGIN
         DECLARE @cnt INT;
         SELECT @cnt = COUNT(*) FROM dbo.SysRtns_vw WHERE rtn_nm = @qrn;
         -- Raise div by zero exception
         IF @cnt > 1 SET @cnt = @cnt/0;
      END
   END
   INSERT INTO @t (schema_nm, rtn_nm)
   VALUES( @schema_nm,@rtn_nm);
   RETURN;
END
/*
SELECT * FROM fnSplitQualifiedName('test.fnGetRtnNmBits')
SELECT * FROM fnSplitQualifiedName('a.b')
SELECT * FROM fnSplitQualifiedName('a.b.c')
SELECT * FROM fnSplitQualifiedName('a')
SELECT * FROM fnSplitQualifiedName(null)
SELECT * FROM fnSplitQualifiedName('')
EXEC test.sp__crt_tst_rtns '[dbo].[fnSplitQualifiedName]';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ============================================================================================================================
-- Author:      Terry Watts
-- Create date: 09-MAY-2020
-- Description: checks if the routine exists
--
-- Preconditions
-- PRE 02: if schema is not specifed in @qrn and there are more than 1 rtn with the rtn nm
--          but differnt schema then raise div by zero exception - delegated to fnSplitQualifiedName
--
-- Postconditions:
-- Post 01: RETURNS if @q_rtn_name exists then [schema_nm, rtn_nm, rtn_ty, ty_code,] , 0 otherwise
--
-- Changes 240723: now returns a single row table as above
--
-- Tests: test.test_029_fnChkRtnExists
-- ============================================================================================================================
CREATE FUNCTION [dbo].[fnGetRtnDetails]
(
    @qrn VARCHAR(120)
)
RETURNS @t TABLE
(
    qrn           VARCHAR(120)
   ,schema_nm     VARCHAR(32)
   ,rtn_nm        VARCHAR(60)
   ,rtn_ty        NCHAR(61)
   ,ty_code       VARCHAR(25)
   ,is_clr        BIT
)
AS
BEGIN
   DECLARE
       @schema       VARCHAR(20)
      ,@rtn_nm       VARCHAR(4000)
      ,@ty_nm        VARCHAR(20)
      ,@qrn2         VARCHAR(120)
   SELECT
       @schema = schema_nm
      ,@rtn_nm = rtn_nm
      ,@qrn2   = CONCAT(schema_nm, '.', rtn_nm)
   FROM fnSplitQualifiedName(@qrn);
   SELECT @ty_nm = ty_nm FROM dbo.sysRtns_vw WHERE schema_nm = @schema and rtn_nm = 'fn_CamelCase';
   INSERT INTO @t
   (
       qrn
      ,schema_nm
      ,rtn_nm
      ,rtn_ty
      ,ty_code
      ,is_clr
   )
   SELECT
       @qrn2
      ,schema_nm
      ,rtn_nm
      ,rtn_ty
      ,ty_code
      ,is_clr
   FROM dbo.sysRtns_vw WHERE schema_nm = @schema and rtn_nm = @rtn_nm;
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_029_fnChkRtnExists';
SELECT * FROM [dbo].[fnGetRtnDetails]('[dbo].[fnIsCharType]');
SELECT * FROM [dbo].[fnGetRtnDetails]('sp_assert_rtn_exists');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[TableColumns_vw]
AS
SELECT *
FROM INFORMATION_SCHEMA.COLUMNS
;
/*
SELECT * FROM dbo.TableColumns;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[fnGetTableColumns]
(
    @name       VARCHAR(128)
   ,@schema_nm  VARCHAR(128)
)
RETURNS
@t TABLE
(
    TABLE_CATALOG    VARCHAR(128)
   ,TABLE_SCHEMA     VARCHAR(128)
   ,TABLE_NAME       VARCHAR(128)
   ,COLUMN_NAME      VARCHAR(128)
   ,ORDINAL_POSITION INT
   ,IS_NULLABLE      BIT
   ,DATA_TYPE        VARCHAR(128)
)
AS
BEGIN
   INSERT INTO @t(
    TABLE_CATALOG
   ,TABLE_SCHEMA
   ,TABLE_NAME
   ,COLUMN_NAME
   ,ORDINAL_POSITION
   ,IS_NULLABLE
   ,DATA_TYPE
)
   SELECT
    TABLE_CATALOG
   ,TABLE_SCHEMA
   ,TABLE_NAME
   ,COLUMN_NAME
   ,ORDINAL_POSITION
   ,iif(IS_NULLABLE = 'YES', 1, 0)
   ,DATA_TYPE
   FROM TableColumns_vw
   WHERE
          (TABLE_SCHEMA = @schema_nm OR @schema_nm IS NULL)
      AND TABLE_NAME   = @name
      ORDER BY ORDINAL_POSITION
   ;
   RETURN;
END
/*
   SELECT * FROM dbo.fnGetTableColumns('Attendance', NULL);
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
-- Description: returns the type name from the type code
--e.g. sysobjects xtype code 
-- ======================================================
CREATE FUNCTION [dbo].[fnGetTyNmFrmTyCode]
(
   @ty_code VARCHAR(2)
)
RETURNS VARCHAR(30)
AS
BEGIN
   RETURN
   (
      CASE 
         WHEN @ty_code = 'AF' THEN 'CLR aggregate function'
         WHEN @ty_code = 'C'  THEN 'CHECK constraint'
         WHEN @ty_code = 'D'  THEN 'DEFAULT'
         WHEN @ty_code = 'EC' THEN 'Edge constraint'
         WHEN @ty_code = 'ET' THEN 'External tbl'
         WHEN @ty_code = 'F'  THEN 'Foreign key'
         WHEN @ty_code = 'FN' THEN 'Scalar function'
         WHEN @ty_code = 'FS' THEN 'CLR scalar function'
         WHEN @ty_code = 'FT' THEN 'CLR table function'
         WHEN @ty_code = 'IF' THEN 'Inline table function'
         WHEN @ty_code = 'IT' THEN 'Intrnl table'
         WHEN @ty_code = 'P'  THEN 'Procedure'
         WHEN @ty_code = 'PC' THEN 'CLR procedure'
         WHEN @ty_code = 'PG' THEN 'Plan guide'
         WHEN @ty_code = 'PK' THEN 'Primary key'
         WHEN @ty_code = 'R'  THEN 'Rule'
         WHEN @ty_code = 'RF' THEN 'Repl fltr proc'
         WHEN @ty_code = 'S'  THEN 'Sys base table'
         WHEN @ty_code = 'SN' THEN 'Synonym'
         WHEN @ty_code = 'SO' THEN 'Sequence object'
         WHEN @ty_code = 'SQ' THEN 'Service queue'
         WHEN @ty_code = 'TA' THEN 'CLR DML trigger'
         WHEN @ty_code = 'TF' THEN 'Table function'
         WHEN @ty_code = 'TR' THEN 'SQL DML trigger'
         WHEN @ty_code = 'TT' THEN 'Table type'
         WHEN @ty_code = 'U'  THEN 'Table'
         WHEN @ty_code = 'UQ' THEN 'Unique Key'
         WHEN @ty_code = 'V'  THEN 'View'
         WHEN @ty_code = 'X'  THEN 'Extended procedure'
         ELSE '???'
      END
   );
END
/*
PRINT dbo.fnGetTyNmFrmTyCode('TF')
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =========================================================
-- Author:      Terry Watts
-- Create date: 06-DEc-2024
-- Description: compares 2 SQL_VARIANTs
-- RULES:
-- R01: if a < b return 1, 0 otherwise
-- R02: if types are same then a normal comparison should be used
-- R03: NULL < NULL returns 0
-- R04: NULL < NON NULL returns 1
-- R05: NON NULL < NULL returns 0
-- R06: different types try to convert to strings and then compare
--
-- Postconditions
-- Post 01: if a < b return 1
-- Post 02: if types are same then a normal comparison should be used
-- Post 03: NULL < NULL returns 0
-- Post 04: NULL < NON NULL returns 1
-- Post 05: NON NULL < NULL returns 0
-- Post 06: different types try to convert to strings and then compare
-- =========================================================
CREATE FUNCTION [dbo].[fnIsLessThan]( @a SQL_VARIANT, @b SQL_VARIANT)
RETURNS BIT
AS
BEGIN
   DECLARE 
       @aTxt   VARCHAR(4000)
      ,@bTxt   VARCHAR(4000)
      ,@typeA  VARCHAR(50)
      ,@typeB  VARCHAR(50)
      ,@ret    BIT
      ,@res    INT
   ------------------------------------------------------
   -- Handle Null NULL
   ------------------------------------------------------
   IF @a IS NULL AND @b IS NULL RETURN 0;
   ------------------------------------------------------
   -- Handle Null not NULL scenarios
   ------------------------------------------------------
   IF @a IS NULL AND @b IS NOT NULL RETURN 1;
   IF @a IS NOT NULL AND @a IS NULL RETURN 0;
   ------------------------------------------------------
   -- ASSERTION: Both a and b are not NULL
   ------------------------------------------------------
   ------------------------------------------------------
   -- Handle different types
   ------------------------------------------------------
   SELECT @typeA = CONVERT(VARCHAR(500),SQL_VARIANT_PROPERTY(@a, 'BaseType'))
         ,@typeB = CONVERT(VARCHAR(500),SQL_VARIANT_PROPERTY(@b, 'BaseType'))
    ;
   IF @typeA <> @typeB
   BEGIN
      SELECT @aTxt = CONVERT(VARCHAR(500),@a)
            ,@bTxt = CONVERT(VARCHAR(500),@b);
      RETURN iif(@aTxt < @bTxt, 1, 0);
   END
   ------------------------------------------------------
   -- ASSERTION: Both a and b are the same type
   ------------------------------------------------------
   ------------------------------------------------------
   -- Handle types where the variant < operator
   -- does not return correct value
   ------------------------------------------------------
   ------------------------------------------------------
   -- Handle general case where variant < operator works
   ------------------------------------------------------
   RETURN iif(@a<@b, 1, 0);
END
/*
EXEC test.test_054_fnIsLT
EXEC tSQLt.Run 'test.test_054_fnIsLT';
EXEC tSQLt.RunAll;
PRINT DB_Name()
   DECLARE 
       @a      SQL_VARIANT = 2
      ,@b      SQL_VARIANT = '2'
      ,@aTxt   VARCHAR(4000) = CONVERT(VARCHAR(500),@a)
      ,@bTxt   VARCHAR(4000) = CONVERT(VARCHAR(500),@b)
      ;
   PRINT iif(@a<@b, 1, 0);
   DECLARE 
       @a      SQL_VARIANT =  2
      ,@b      SQL_VARIANT = 'abc'
      ,@aTxt   VARCHAR(4000)
      ,@bTxt   VARCHAR(4000)
      ;
   SELECT @aTxt = CONVERT(VARCHAR(500),@a)
         ,@bTxt = CONVERT(VARCHAR(500),@b)
   PRINT iif(@a<@b, 1, 0);
   PRINT iif(@b<@a, 1, 0);
   PRINT iif(@aTxt<@bTxt, 1, 0);
   PRINT iif(@bTxt<@aTxt, 1, 0);
   PRINT CONCAT('[',@aTxt, ']');
   PRINT CONCAT('[',@bTxt, ']');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================
-- Author:      Terry Watts
-- Create date: 08-DEC-2024
-- Description: determines if a sql_variant is an
-- integral type: {int, smallint, tinyint, bigint, money, smallmoney}
-- test: [test].[t 025 fnIsFloat]
--
-- Changes:
-- 241128: added optional check for non negative ints
-- ====================================================================
CREATE FUNCTION [dbo].[fnIsTxtInt]( @v VARCHAR(50), @must_be_positive BIT)
RETURNS BIT
AS
BEGIN
   DECLARE @val INT
   ,@ret BIT
   -- SETUP
   IF @must_be_positive IS NULL  SET @must_be_positive = 0;
   -- PROCESS
   SET @val = TRY_CONVERT(INT, @v);
   SET @ret = iif(@val IS NULL, 0, 1);
      IF @ret = 1 AND @must_be_positive = 1
      BEGIN
         SET @ret = iif(@val >=0, 1, 0);
      END
   RETURN @ret;
END
/*
   DECLARE
       @v_str  VARCHAR(4000)
      ,@ret    BIT = 0
      ,@val    INT
--   DECLARE @type SQL_VARIANT
--   DECLARE @ty   VARCHAR(500)
--   SELECT @type = SQL_VARIANT_PROPERTY(@v, 'BaseType');
--   SET @ty = CONVERT(VARCHAR(20), @type);
   SET @v_str = CONVERT(VARCHAR(4000), @v);
   WHILE(1=1)
   BEGIN
      IF dbo.fnLen(@v_str) = 0
         BREAK;
      IF @must_be_positive IS NULL  SET @must_be_positive = 0;
      SET @val = TRY_CONVERT(INT, @v);
      SET @ret = iif(@val IS NULL, 0, 1);
      IF @ret = 1 AND @must_be_positive = 1
      BEGIN
         --SET @val =  CONVERT(INT, @v);
         SET @ret = iif(@val >=0, 1, 0);
      END
      BREAK;
   END
   RETURN @ret;
END
*/
/*
PRINT CONVERT(INT, NULL);
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_044_fnIsInt';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 5-SEP-2025
-- Description: 
-- Design:      
-- Tests:       
-- =============================================
CREATE FUNCTION [dbo].[fnIsValidTableColumnName]
(
   @field_nm VARCHAR(128)
)
RETURNS BIT
AS
BEGIN
   DECLARE
       @IsValid   BIT = 0
   ;
   WHILE 1=1
   BEGIN
      -- Rule 1: Check if empty or null
      -- Rule 1: Check if empty or null
       IF @field_nm IS NULL OR LTRIM(RTRIM(@field_nm)) = ''
         BREAK;

       -- Rule 2: Check length (max 128 chars)
       IF LEN(@field_nm) > 128
            BREAK;

       -- Rule 3: Check if starts with letter or underscore
       IF @field_nm NOT LIKE '[a-zA-Z_]%'
            BREAK;

       -- Rule 4: Check for invalid characters (allow letters, digits, underscore only)
       IF @field_nm LIKE '%[^a-zA-Z0-9_]%'
            BREAK;

      -- Rule 5: Check if the name is a reserved word or requires escaping
      -- QUOTENAME will wrap invalid/reserved names in brackets; compare to original
      IF QUOTENAME(@field_nm) != @field_nm
         BREAK;

      -- finally is true
      SET @IsValid = 1;
      BREAK;
   END
   RETURN @IsValid;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_<fn_nm>;
EXEC test.sp__crt_tst_rtns 'dbo.fnIsValidTableColumnName';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from 
--              the beginning end of a string
-- =============================================
CREATE FUNCTION [dbo].[fnLTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   DECLARE @len INT;
   IF @str IS NOT NULL AND @trim_chr IS NOT NULL
      WHILE Left(@str, 1) = @trim_chr
      BEGIN
         SET @len = dbo.fnLen(@str)-1;
         IF @len < 0
            BREAK;
         SET @str = Substring(@str, 2, dbo.fnLen(@str)-1);
      END
   RETURN @str
END
/*
PRINT CONCAT('1: [',  dbo.fnLTrim2('  ', ' '), ']');
PRINT CONCAT('2: [',  dbo.fnLTrim2(' ', ' '), ']');
PRINT CONCAT('3: [',  dbo.fnLTrim2('', ' '), ']');
PRINT CONCAT('4: [', Right('', 1), ']');
PRINT CONCAT('5: [', dbo.fnLTrim2(' s 5   ', ' '), ']');
PRINT CONCAT('6: [', dbo.fnLTrim2(' ', ' '), ']');
PRINT CONCAT('7: [', dbo.fnLTrim2('', ' '), ']');
PRINT CONCAT('8: [', dbo.fnLTrim2(NULL, ' '), ']');
PRINT CONCAT('9: [', dbo.fnLTrim2(' ', NULL), ']');
PRINT CONCAT('10:[', dbo.fnLTrim2('', NULL), ']');
IF dbo.fnLTrim2(NULL, NULL) IS NULL PRINT 'IS NULL';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[fnMax] (@p1 INT, @p2 INT)
RETURNS INT
AS
BEGIN
   RETURN CASE WHEN @p1 > @p2 THEN @p1 ELSE @p2 END 
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [dbo].[fnMin] (@p1 INT, @p2 INT)
RETURNS INT
AS
BEGIN
   RETURN CASE WHEN @p1 > @p2 THEN @p2 ELSE @p1 END;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ========================================================
-- Author:      Terry Watts
-- Create date: 06-SEP-2025
-- Description: returns 1 if name needs brackets.
--    i.e. is a reserver word or has some wierd characters
-- Design:      
-- Tests:       
-- ========================================================
CREATE FUNCTION [dbo].[fnNameNeedsBrackets](@name VARCHAR(60))
RETURNS BIT
AS
BEGIN
   DECLARE
    @v BIT = 0
   ,@c CHAR
   ;
   SET @c = iif(dbo.fnLen(@name)> 0, SUBSTRING(@name, 1, 1), NULL);
   SET @v = CASE
   WHEN dbo.fnIsReservedWord(@name)= 1 THEN 1
   --WHEN @name LIKE '%[ --+*$&@{}()-+=~|`'']%' THEN 1
   WHEN @name LIKE '%[ *&=~`]%' THEN 1
   WHEN @name IS NULL      THEN 1
   WHEN @name LIKE '%[!@#$-]%' THEN 1
   WHEN @name = ''         THEN 1
   WHEN CHARINDEX('%',@name) > 0         THEN 1
   WHEN CHARINDEX('^',@name) > 0         THEN 1
   WHEN CHARINDEX('(',@name) > 0         THEN 1
   WHEN CHARINDEX(')',@name) > 0         THEN 1
   WHEN CHARINDEX('+',@name) > 0         THEN 1
   WHEN CHARINDEX('|',@name) > 0         THEN 1
   WHEN CHARINDEX('\\',@name) > 0         THEN 1
   WHEN CHARINDEX('/',@name) > 0         THEN 1
   WHEN CHARINDEX('?',@name) > 0         THEN 1
   WHEN @c IS NOT NULL AND @c LIKE '[0123456789]' THEN 1 -- leading charcter cannot be numeric
   ELSE 0
   END;
   RETURN @v;
END
/*
EXEC tSQLt.Run 'test.test_077_fnNameNeedsBrackets';
EXEC tSQLt.RunAll;
PRINT dbo.fnIsReservedWord('a');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================    
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Pads Left
-- =============================================    
CREATE FUNCTION [dbo].[fnPadLeft2]( @s VARCHAR(500), @width INT, @pad VARCHAR(1)=' ')
RETURNS VARCHAR (1000)
AS
BEGIN
   DECLARE 
    @ret  VARCHAR(1000)
   ,@len INT
   IF @s IS null
      SET @s = '';
   SET @len = dbo.fnLen(@s);
   RETURN iif(@len < @width
      , RIGHT( CONCAT( REPLICATE( @pad, @width-@len), @s), @width)
      , RIGHT(@s, @width))
END
/*
SELECT CONCAT('[', dbo.fnPadLeft2('', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadLeft2(NULL, 25, '.'), ']  ');
PRINT CONCAT('[', dbo.fnPadLeft2(NULL, 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('', 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('asdfg', 12, 'x'),']')
PRINT CONCAT('[', dbo.fnPadLeft2('asdfg', 3, 'x'),']')
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Pads Left
-- =============================================    
CREATE FUNCTION [dbo].[fnPadLeft]( @s VARCHAR(500), @width INT)
RETURNS VARCHAR (4000)
AS
BEGIN
   RETURN dbo.fnPadLeft2(@s, @width, ' ');
END
/*
PRINT CONCAT('[', dbo.fnPadLeft('abcd', 10), ']');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================    
-- Author:      Terry Watts
-- Create date: 23-JUN-2023
-- Description: Pads Right with specified padding character
-- =============================================    
CREATE FUNCTION [dbo].[fnPadRight2]
(
    @s      VARCHAR(MAX)
   ,@width  INT
   ,@pad    VARCHAR(1)
)
RETURNS VARCHAR (1000)
AS
BEGIN
   DECLARE 
      @ret  VARCHAR(1000)
     ,@len  INT
   IF @s IS null
      SET @s = '';
   SET @len = ut.dbo.fnLen(@s)
   RETURN LEFT( CONCAT( @s, REPLICATE( @pad, @width-@len)), @width)
END
/*
SELECT CONCAT('[', dbo.fnPadRight2('a very long string indeed - its about time we had a beer', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadRight2('', 25, '.'), ']  ');
SELECT CONCAT('[', dbo.fnPadRight2(NULL, 25, '.'), ']  ');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================    
-- Author:  Terry Watts
-- Create date: 04-OCT-2019
-- Description: Pads Right
-- =============================================    
CREATE FUNCTION [dbo].[fnPadRight]( @s VARCHAR(500), @width INT)
RETURNS VARCHAR (1000)
AS
BEGIN
   RETURN dbo.fnPadRight2( @s, @width, ' ' )
END
/*
SELECT CONCAT(', ]', dbo.fnPadRight([name], 25), ']  ', [type])
FROM [tg].[test].[fnCrtPrmMap]( '          @table_nm                  VARCHAR(50)  
         ,@folder                    VARCHAR(260)  
         ,@workbook_nm               VARCHAR(260)   OUTPUT  
         ,@sheet_nm                  VARCHAR(50)    OUTPUT  
         ,@view_nm                   VARCHAR(50)    OUTPUT  
         ,@error_msg                 VARCHAR(200)   OUTPUT  ')
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from the right end of a string
-- =============================================
CREATE FUNCTION [dbo].[fnRTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   IF @str IS NOT NULL AND @trim_chr IS NOT NULL
      WHILE Right(@str, 1)= @trim_chr AND dbo.fnLen(@str) > 0
         SET @str = Left(@str, dbo.fnLen(@str)-1);
   RETURN @str
END
/*
PRINT CONCAT('[',  dbo.fnRTrim2('  ', ' '), ']');
PRINT CONCAT('[',  dbo.fnRTrim2(' ', ' '), ']');
PRINT CONCAT('[',  dbo.fnRTrim2('', ' '), ']');
PRINT CONCAT('[', Right('', 1), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' s 5   ', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' ', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2('', ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(NULL, ' '), ']');
PRINT CONCAT('[', dbo.fnRTrim2(' ', NULL), ']
PRINT CONCAT('[', dbo.fnRTrim2('', NULL), ']');
IF dbo.fnRTrim2(NULL, NULL) IS NULL PRINT 'IS NULL';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================================
-- Author:      Terry Watts
-- Create date: 11-APR-2025
--
-- Description: splits a composoite string of 2 parts separated by a separator 
-- into a row containing the first part (a), and the second part (b)
--
--
-- Postconditions:
-- Post 01: if @composit contains sep then returns a 1 row table wher col a = first part 
--             and b  contains the second part when @composit is split using @sep
-- Changes:
-- ==============================================================================================================
CREATE FUNCTION [dbo].[fnSplitPair2]
(
    @composit VARCHAR(1000) -- qualified routine name
   ,@sep CHAR(1)
)
RETURNS @t TABLE
(
    a  VARCHAR(1000)
   ,b  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @n   INT
   ,@a   VARCHAR(50)
   ,@b   VARCHAR(100)
   IF @composit IS NOT NULL AND @composit <> '' AND @sep IS NOT NULL AND @sep <> ''
   BEGIN
      SET @n = CHARINDEX(@sep, @composit);
      IF @n = 0
      BEGIN
         INSERT INTO @t(a) VALUES( @composit);
         RETURN;
      END
      SET @a = SUBSTRING( @composit, 1   , @n-1);
      SET @b = SUBSTRING( @composit, @n+1, dbo.fnLen(@composit)-@n+1);
      INSERT INTO @t(a, b) VALUES( @a, @b);
   END
   --ELSE INSERT INTO @t(a) VALUES( 'IF @composit: false');
   RETURN;
END
/*
SELECT a, b FROM dbo.fnSplitPair2('a.b', '.');
EXEC tSQLt.Run 'test.test_024_fnSplitPair2';
SELECT * FROM fnSplitQualifiedName('test.fnGetRtnNmBits')
SELECT * FROM fnSplitQualifiedName('a.b')
SELECT * FROM fnSplitQualifiedName('a.b.c')
SELECT * FROM fnSplitQualifiedName('a')
SELECT * FROM fnSplitQualifiedName(null)
SELECT * FROM fnSplitQualifiedName('')
EXEC test.sp__crt_tst_rtns 'dbo].[fnSplitPair2';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================
-- Author:      Terry Watts
-- Create date: 08-FEB-2020
-- Description: returns true (1) if table exists else false (0)
-- schema default is dbo
-- Parameters:  @q_table_nm can be qualified
-- Returns      1 if exists, 0 otherwise
-- =============================================================
CREATE FUNCTION [dbo].[fnTableExists](@q_table_nm VARCHAR(100))
RETURNS BIT
AS
BEGIN
   DECLARE
       @schema    VARCHAR(28)
      ,@table_nm  VARCHAR(60)
   ;
   SELECT
       @schema    = schema_nm
      ,@table_nm  = rtn_nm
   FROM fnSplitQualifiedName(@q_table_nm);
   RETURN iif(EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = @table_nm AND TABLE_SCHEMA = @schema), 1, 0);
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 16-DEC-2021
-- Description: Removes specific characters from 
--              the beginning end of a string
-- =============================================
CREATE FUNCTION [dbo].[fnTrim2]
(
    @str VARCHAR(MAX)
   ,@trim_chr VARCHAR(1)
)
RETURNS  VARCHAR(MAX)
AS
BEGIN
   RETURN dbo.fnRTrim2(dbo.fnLTrim2(@str, @trim_chr), @trim_chr);
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 05-JUL-2020
-- Description: creates the test helper routine name
-- =============================================
CREATE FUNCTION [test].[fnCreateTestRtnName]
(
       @tstd_rtn_nm  VARCHAR(100)
      ,@tst_rtn_num  INT 
      ,@tst_rtn_ty   VARCHAR(1)-- M: main test, H = helper
)
RETURNS VARCHAR(50)
AS
BEGIN
   RETURN 
      CONCAT
      (
         CASE
            WHEN @tst_rtn_ty = 'M' THEN 'test'
            ELSE 'hlpr'
         END
         ,'_'
        ,CASE
            WHEN @tst_rtn_num IS NOT NULL THEN FORMAT(@tst_rtn_num, '000')
            ELSE ''
         END
         ,'_', @tstd_rtn_nm
      );
END
/*
PRINT test.fnCreateTestRtnName('fnLen',43, 'M');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
--
-- Description: creates the test helper signature line for the hlpr script like:
-- ALTER PROCEDURE test.hlpr_106_fnGetParams
--    @qrn       VARCHAR(120)
--   ,@ordinal   INT
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- Test rtn: test.test_086_sp_crt_tst_hlpr_script
--
-- ====================================================================================
CREATE FUNCTION [test].[fnCrtCodeMnTstSig]()
RETURNS @t TABLE
(
    id    INT IDENTITY (1,1)
   ,line  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @tst_rtn_nm   VARCHAR(50)
   ,@cora         NCHAR(1)
   SELECT
      @tst_rtn_nm = tst_rtn_nm
     ,@cora       = cora
   FROM test.RtnDetails;
   INSERT INTO @t( line)
   VALUES
       (CONCAT(iif(@cora='C', 'CREATE', 'ALTER'), ' PROCEDURE test.', @tst_rtn_nm));
   RETURN;
END
/*
SELECT * FROM test.fnCrtCodeMnTstSig()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry Watts
-- Create date: 10-NOV-2023
-- Description: gets the rtn description from its meta data
--
-- PRECONDITIONS:
-- PRE 01: the tested rtn details are set
--
-- POSTCONDITIONS:
-- POST01: some rows must be returned or exception 54321
--
-- CHANGES:
--231112: renamed this rtn from and moved to test:
--        dbo.sp_get_rtn_description -> test.sp_get_rtn_desc
-- ===============================================================
CREATE FUNCTION [test].[fnGetRtnDesc]()
RETURNS @t TABLE
(
    id   INT            IDENTITY(1,1)
   ,line VARCHAR(MAX)  NULL
)
AS
BEGIN
   DECLARE
    @fn VARCHAR(35) = 'fnGetRtnDesc'
   ,@desc_st_row     INT = NULL
   ,@desc_end_row    INT = NULL
   ,@schema_nm       VARCHAR(50)
   ,@ad_stp          BIT            = 0
   ,@tstd_rtn        VARCHAR(100)
   ,@qrn             VARCHAR(100)
   ;
   SELECT
       @qrn       = qrn
      ,@schema_nm = schema_nm
      ,@tstd_rtn  = rtn_nm
      ,@ad_stp    = ad_stp
   FROM test.RtnDetails;
   if(@ad_stp=1) INSERT INTO @t(line) VALUES(CONCAT('-- ', @fn));
   INSERT INTO @t(line) 
   SELECT line
   FROM dbo.fnGetRtnDef();
   SET @desc_st_row = (SELECT TOP 1 id FROM @t WHERE line LIKE '--%Description%');
   SET @desc_end_row= (SELECT TOP 1 id FROM @t WHERE line LIKE '%====%' AND id>@desc_st_row);
   DELETE FROM @t WHERE id NOT BETWEEN @desc_st_row AND @desc_end_row-1;
   UPDATE @t
   SET line = dbo.fnTrim(REPLACE(line, '-- Description:', '--'));
   RETURN;
END
/*
SELECT * from Test.RtnDetails;
SELECT * from Test.ParamDetails;
SELECT * FROM test.fnGetRtnDesc();
SELECT * FROM dbo.fnGetRtnDef();
EXEC tSQLt.RunAll;
SELECT * FROM test.RtnDetails;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================
-- Author:      Terry Watts
-- Create date: 16-Dec-2023
-- Description: encapsulates the helper header comment
-- 05 Create the test rtn Header->fnCrtHlprCodeTstHdr
--
-- PRECONDITIONS: test.RtnDetails pop'd
-- ======================================================
CREATE FUNCTION [test].[fnCrtCodeTstHdr]( @is_hlpr      BIT = 1)
RETURNS 
@t TABLE 
(
    id      INT IDENTITY(1,1) NOT NULL
   ,line    VARCHAR(500)
)
AS
BEGIN
   DECLARE 
       @line         VARCHAR(500)
      ,@qrn          VARCHAR(500)
      ,@tst_rtn_nm   VARCHAR(50)
      ,@dt           DATE = GetDate()
      ,@ad_stp       BIT
      ,@maxLineLen   INT
   SELECT
       @qrn       = qrn
      ,@tst_rtn_nm= iif(@is_hlpr = 1, hlpr_rtn_nm, tst_rtn_nm)
      ,@ad_stp    = ad_stp
    FROM test.RtnDetails;
   SELECT @maxLineLen = MAX(dbo.fnLen(dbo.fnTrim(line)))
   FROM test.fnGetRtnDesc(); -- @qrn, @ad_stp)
   SET @line = CONCAT('--',REPLICATE('=', @maxLineLen));
   INSERT INTO @t( line) VALUES
    ('SET ANSI_NULLS ON')
   ,('GO')
   ,('SET QUOTED_IDENTIFIER ON')
   ,('GO')
   ;
/*
      INSERT INTO @t( line) 
      SELECT line 
      FROM 
         test.fnCrtCodeDropRtn(@is_hlpr);
*/
   INSERT INTO @t( line) VALUES
    (@line)
   ,('-- Author:           Terry Watts')
   ,(CONCAT('-- Create date:      ', FORMAT(@dt, 'dd-MMM-yyyy')))
   ,(CONCAT('-- Rtn:              test.',@tst_rtn_nm))
   ,(CONCAT('-- Description: ',iif(@is_hlpr=1,'test helper','main test routine'),' for the ',@qrn, ' routine ',iif(@is_hlpr=1,'tests ', '')))
   ,('--')
   ,('-- Tested rtn description:')
   INSERT INTO @t(line)
   SELECT line FROM test.fnGetRtnDesc(); -- @qrn, @ad_stp
   INSERT INTO @t( line) VALUES (@line)
   -- Reset the comment line length to be long enough to cover the new lines from the tested rtn desc
   SELECT @maxLineLen = MAX(dbo.fnLen(dbo.fnTrim(line))) FROM @t;
   SET @line =  CONCAT('--', REPLICATE('=', @maxLineLen));
   UPDATE @t SET line = @line where line like '--===%'
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
   SELECT line FROM test.fnCrtCodeTstHdr('test.test_086_sp_crt_tst_hlpr_script', 1)
   SELECT * FROM test.fnCrtCodeTstHdr('dbo.fnSysRtnCfg', 1)
   SELECT * FROM test.fnCrtCodeTstHdr('test.sp_crt_tst_hlpr_script', 0)
   SELECT * FROM test.fnCrtCodeTstHdr('test.sp_crt_tst_hlpr_script', 1)
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [test].[ParamDetails](
	[ordinal] [int] IDENTITY(1,1) NOT NULL,
	[param_nm] [varchar](50) NULL,
	[type_nm] [varchar](32) NULL,
	[parameter_mode] [varchar](10) NULL,
	[is_chr_ty] [bit] NULL,
	[is_result] [bit] NULL,
	[is_output] [bit] NULL,
	[is_nullable] [bit] NULL,
	[tst_ty] [nchar](3) NULL,
	[is_exception] [bit] NULL,
 CONSTRAINT [PK_ParamDetails] PRIMARY KEY CLUSTERED 
(
	[ordinal] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description: 
-- Creates the helper decl bloc for the act params output by teh teted rtn like:
--   ,@act_row_cnt     INT
--   ,@act_file_path   VARCHAR(4000)            -- comma separated
--   ,@act_range       VARCHAR(4000)            -- comma separated
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions: return table with the CoreParams
--
-- Called by: test.fnCrtHlprCodeDecl
-- ==================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeDeclActParams]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
       @tab1           NCHAR(3) = '   '
      ,@tab2           NCHAR(6) = '      '
      ,@rtn_ty_code    VARCHAR(2)
      ,@sc_fn_ret_ty   VARCHAR(20)
      ,@ad_stp         BIT
      ,@max_prm_len    INT
      ;
    SELECT
       @rtn_ty_code  = rtn_ty_code
      ,@ad_stp       = ad_stp
      ,@sc_fn_ret_ty = sc_fn_ret_ty
      ,@max_prm_len  = max_prm_len + 5
   FROM test.RtnDetails;
   IF @ad_stp = 1
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab1, '-- fnCrtHlprCodeDeclActParams'))
      ;
   -- IF a Procedure declare any act out params and set to exp params initially
   INSERT INTO @t (line)
   SELECT
       CONCAT
         (
             @tab1, ',@act_', dbo.fnPadRight(param_nm, @max_prm_len), ' ', dbo.fnPadRight(UPPER(type_nm), 15)
             -- 241219: only assign the expected value if it is an out param, else assing NULL
          --  ,iif( , CONCAT(' = @exp_', param_nm), '')
         )
   FROM test.ParamDetails
   WHERE tst_ty='EXP' AND is_output = 0;
   ;
   -- 241217: this duplicates @act_row_cnt ?? removed - need to test against FN, TF
   -- Add the output cols as act
   IF @rtn_ty_code = 'P'
   BEGIN
      INSERT INTO @t (line)
      SELECT
          CONCAT(@tab1, ',@act_', dbo.fnPadRight(param_nm, @max_prm_len), ' ', dbo.fnPadRight(UPPER(type_nm), 15), ' = @exp_', param_nm)
      FROM test.ParamDetails
      WHERE is_output = 1
      ;
   END
   IF @rtn_ty_code = 'FN'
   BEGIN
      INSERT INTO @t (line)
      SELECT
          CONCAT(@tab1, ',@act_', dbo.fnPadRight(param_nm, @max_prm_len), ' ', dbo.fnPadRight(UPPER(type_nm), 15), ' = @exp_', param_nm)
      FROM test.ParamDetails
      WHERE is_output = 1
      ;
   END
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeDeclActParams();
SELECT * FROM test.ParamDetails;
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description: 
-- Creates the helper decl bloc for the  core params as follows:
-- DECLARE
--     @fn          VARCHAR(35) = N'hlpr_093_sp_class_creator'
--    ,@act_row_cnt INT
--    ,@act_ex_num  INT
--    ,@act_ex_msg  VARCHAR(500)
--    ,@error_msg   VARCHAR(1000)
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions: return table with the CoreParams
--
-- Called by: test.fnCrtHlprCodeDecl
-- ==================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeDeclCoreParams]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1               NCHAR(3) = '   '
   ,@tab2               NCHAR(6) = '      '
   ,@rtn_ty_code        VARCHAR(2)
   ,@ad_stp             BIT
   ,@max_prm_len        INT
   ,@tst_proc_hlpr_nm   VARCHAR(60)
    SELECT
       @tst_proc_hlpr_nm= hlpr_rtn_nm
      ,@ad_stp          = ad_stp
      ,@rtn_ty_code     = rtn_ty_code
      ,@max_prm_len     = max_prm_len +10
    FROM test.RtnDetails
   IF @ad_stp = 1
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab1, '-- fnCrtHlprCodeDeclCoreParams'))
   INSERT INTO @t (line) VALUES
       (CONCAT(@tab1, 'DECLARE'))
      ,(CONCAT(@tab1, dbo.fnPadRight(' @fn'        , @max_prm_len+2), 'VARCHAR(35)', '    = N''',@tst_proc_hlpr_nm, ''''))
      ,(CONCAT(@tab1, dbo.fnPadRight(',@error_msg' , @max_prm_len+2), 'VARCHAR(1000)'))
   --IF @rtn_ty_code = 'P'
   -- INSERT INTO @t (line) VALUES (CONCAT(@tab1, dbo.fnPadRight(',@act_RC', @max_prm_len+1), ' INT'))
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeDeclCoreParams();
EXEC test.sp_get_rtn_details 'dbo].AsInt', @display_tables = 1;
SELECT * FROM test.RtnDetails;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description:
-- Creates the helper decl bloc
-- -- ==================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeDecl]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
     @tab1              NCHAR(3) = '   '
    ,@ad_stp            BIT
    SELECT
      @ad_stp           = ad_stp
    FROM test.RtnDetails
IF @ad_stp = 1
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab1, '-- fnCrtHlprCodeDecl'))
   INSERT INTO @t (line)
   SELECT line
   FROM test.fnCrtHlprCodeDeclCoreParams();
   INSERT INTO @t (line)
   SELECT line
   FROM test.fnCrtHlprCodeDeclActParams();
   RETURN;
END
/*
SELECT line from test.fnCrtHlprCodeDecl();
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================
-- Author:      Terry Watts
-- Create date: 17-Apr-2024
-- Description: creates the log parameter list for a test helper
-- when listing the paramaters intially with sp_log
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions: return table with the tst, inp and exp prms
-- =============================================================
CREATE FUNCTION [test].[fnCrtHlprLogParams]()
RETURNS @t TABLE
(
    id    INT
   ,line  VARCHAR(80)
)
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)= 'fnCrtHlprLogParams'
   ,@tab                VARCHAR(3) = '   '
   ,@rtn_ty_code        NCHAR(2)
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@detld_rtn_ty_code  VARCHAR(2)
   ,@qrn                VARCHAR(100)
   ,@sc_fn_ret_ty       VARCHAR(50)
   ,@ad_stp             BIT         = 0
   ,@tst_rtn_nm         VARCHAR(60)
   ,@max_prm_len        INT
   SELECT
       @tst_rtn_nm   = tst_rtn_nm
      ,@ad_stp       = ad_stp
      ,@rtn_ty_code  = rtn_ty_code
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;
   ------------------------------------------
   -- Create the input params
   ------------------------------------------
   SELECT @max_prm_len = MAX(dbo.fnLen(param_nm)) FROM test.paramDetails
   --INSERT INTO @t (line) SELECT @max_prm_len as max_prm_len;
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          dbo.fnPadRight(lower(param_nm), @max_prm_len+4)
         ,':['', @'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len+4)
         ,','']', iif(@ad_stp = 1, ' -- TST', '')
       --  ,iif(ordinal = 1, CONCAT('-- ', @fn), '')
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'TST'
   ;
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          'inp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,':['', @inp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- INP', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'INP'
   ;
   ------------------------------------------
   -- Create the exp paams
   ------------------------------------------
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          'exp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,':['', @exp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- EXP 1', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 0
   ;
   ----------------------------------------------------
   -- Add @exp_RC param if tstd rtn is a procedure
   ----------------------------------------------------
   IF(@rtn_ty_code = 'P')
   INSERT INTO @t (line) VALUES
   (
      CONCAT
      (
          dbo.fnPadRight('exp_RC', @max_prm_len + 4)
         ,':['', @exp_'
         ,dbo.fnPadRight('RC', @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- SP', '')
      )
   )
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          dbo.fnPadRight(lower(param_nm), @max_prm_len+4)
         ,':['', @exp_'
         ,dbo.fnPadRight(lower(param_nm), @max_prm_len)
         ,','']', iif(@ad_stp = 1, ' -- EXP 2', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 1
   ;
   INSERT INTO @t (line) VALUES
    (''';')
    ;
   RETURN;
END
/*
   EXEC tSQLt.Run 'test.test_056_fnCrtHlprLogParams';
select line FROM test.fnCrtHlprLogParams()
EXEC tSQLt.Run 'test.test_051_fnCrtHlprLogParams';
EXEC test.sp__crt_tst_rtns 'dbo].[fnSplitKeyValuePairs'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 17-Dec-2023
-- Description: creates the scriptlet for stage 07 of test.sp_crt_tst_hlpr
--
-- POSTCONDITIONS:
-- RETURNS: @rtnDef
-- POST 01:
--
-- 241205: added sp_lop starting with parameter list
--         simplified logic and sorted tab issues
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeBegin]()
RETURNS @t TABLE 
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1           VARCHAR(3) = '   '
   ,@tab2           VARCHAR(6) = '      '
   ,@ad_stp         BIT
   ,@rtn_ty         VARCHAR(2)
   ,@max_prm_len    INT
   SELECT
       @rtn_ty       = rtn_ty
      ,@max_prm_len  = max_prm_len
      ,@ad_stp       = ad_stp
   FROM
      test.RtnDetails;
   ------------------------------------------------------------------------------------------------
   -- Add the As - BEGIN-DECL
   ------------------------------------------------------------------------------------------------
   INSERT INTO @t (line) VALUES
    (CONCAT('AS', IIF(@ad_stp = 1 ,' -- fnCrtHlprCodeBegin', '')))
   ,('BEGIN')
   INSERT INTO @t(line)
   SELECT line
   FROM test.fnCrtHlprCodeDecl();
   INSERT INTO @t (line) VALUES
    ('')
   ,(CONCAT(@tab1,'BEGIN TRY'))
   ,(CONCAT(@tab2,'EXEC test.sp_tst_hlpr_st @tst_num;'))
   ,('')
   ,(CONCAT(@tab2,'EXEC sp_log 1, @fn ,'' starting'))
   ;
   INSERT INTO @t (line) SELECT line FROM test.fnCrtHlprLogParams();
   INSERT INTO @t (line) VALUES
    ('')
   ,(CONCAT(@tab2,'-- SETUP: ??'))
   ,('')
   ;
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeBegin();
EXEC test.sp_get_rtn_details 'dbo.sp_class_creator', @ad_stp=1, @display_tables = 1;
EXEC tSQLt.Run 'test.test_025_sp_crt_tst_hlpr_script';
EXEC tSQLt.RunAll;
SELECT * FROM test.RtnDetails;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the test helper code to call a stored procedure
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- POSTCONDITIONS:
-- POST 01:
--
-- Called by: fnCrtHlprCodeCallBloc
--
-- Changes:
-- 241126: now that we have added @display tables as a parameter to test helper fns for P and TF
--          but not FN then the first rtn param ordinal position will b 3 if FNs else 4
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallProc]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1) NOT NULL
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(100)
   ,@tab1         VARCHAR(3) = dbo.fnGetNTabs(1)
   ,@tab2         VARCHAR(6) = dbo.fnGetNTabs(2)
   ,@tab3         NCHAR(9)    = dbo.fnGetNTabs(3)
   ,@tab4         NCHAR(12)   = dbo.fnGetNTabs(4)
   ,@tab5         NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@rtn_ty_code  NCHAR(2)
   ,@ad_stp       BIT
   ,@max_prm_len  INT
   ,@line         VARCHAR(60) = REPLICATE('-', 60)
   ,@first_exp_prm_ndx  INT
   ,@rtn_ty       VARCHAR(2)
   SELECT
       @qrn          = qrn
      ,@ad_stp       = ad_stp
      ,@max_prm_len  = max_prm_len
      ,@rtn_ty       = rtn_ty
   FROM test.RtnDetails;
   SET @first_exp_prm_ndx =
   (
      SELECT TOP 1 ordinal
      FROM test.ParamDetails
      WHERE is_output=1
      ORDER BY ordinal
   )
   INSERT INTO @t (line) VALUES  (CONCAT(@tab4, 'EXEC @act_RC = ', @qrn, iif( @ad_stp = 1, '-- fnCrtHlprCodeCallProc', '')));
   INSERT INTO @t (line)
      SELECT
         CONCAT
         (
             @tab5
            ,dbo.fnPadRight
             (
               CONCAT
               (
               -- 241116: display tables affects the first ordinal as it depends on rtn type
               -- P and TF have the extra display tables parameter, FNs do not
                   iif(ordinal >iif(@rtn_ty = 'FN',3, 3),',',' ')
               ,'@'
               ,param_nm
             )
             ,@max_prm_len+3)
             ,' = @', IIF(is_output=1, 'act', 'inp'), '_'
             ,param_nm
             ,iif(is_output=1, dbo.fnPadLeft(' OUTPUT', @max_prm_len-len(param_nm)+8), '')
          )
      FROM test.ParamDetails
      WHERE tst_ty='INP';
   INSERT INTO @t (line) VALUES
     (CONCAT(@tab5,';'))
   ;
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeCallProc()
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
EXEC tSQLt.RunAll;
EXEC test.sp_set_rtn_details 'test.sp_pop_param_details', 41, @display_tables = 1
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===========================================================================
-- Author:      Terry Watts
-- Create date: 24-APRE-2024
-- Description: creates the scriptlet for stage 10 of test.sp_crt_tst_hlpr
-- ===========================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeChkExps]()
RETURNS @rtnDef TABLE 
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(100)
   ,@tab          NCHAR(3)  = '   '
   ,@tab2         NCHAR(6)  = dbo.fnGetNTabs(2)
   ,@tab3         NCHAR(9)  = dbo.fnGetNTabs(3)
   ,@tab4         NCHAR(12) = dbo.fnGetNTabs(4)
   ,@rtn_ty_code  NCHAR(2)
   ,@ad_stp       BIT
   ,@max_prm_len  INT
   ,@line         VARCHAR(60) = REPLICATE('-', 60)
   ,@st_ordinal   INT
   SELECT
       @qrn          = qrn
      ,@ad_stp       = ad_stp
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;
   SELECT 
      @max_prm_len = MAX(dbo.fnLen(param_nm))
     ,@st_ordinal  = MIN(ordinal)-1
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP';
   IF @ad_stp = 1
      INSERT INTO @rtnDef (line) VALUES
      (CONCAT(@tab3, '-- fnCrtHlprCodeChkExps',''))
   ----------------------------------------------
   -- Row count chk setup
   ----------------------------------------------
    --INSERT INTO @rtnDef (line) VALUES
    --(CONCAT(@tab3, '--IF @exp_', dbo.fnPadRight('row_cnt', @max_prm_len),' IS NOT NULL SELECT @act_row_cnt = COUNT(*) FROM [<TODO: enter table name here>]'));
   ----------------------------------------------
   -- Add the exp checks not exp exception chks
   ----------------------------------------------
   INSERT INTO @rtnDef (line) SELECT
      CONCAT
      (
          @tab3
         ,'IF @exp_', dbo.fnPadRight(param_nm, @max_prm_len)
         ,' IS NOT NULL EXEC tSQLt.AssertEquals'
         , ' @exp_' , dbo.fnPadRight(param_nm, @max_prm_len)
         ,', @act_' , dbo.fnPadRight(param_nm, @max_prm_len)
         , ',''',FORMAT(ordinal+80 - - @st_ordinal, '000'), ' ',param_nm, ''';'
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP' AND is_exception = 0;
   RETURN;
END
/*
EXEC test.sp_set_rtn_details 'test.sp_crt_tst_mn'
SELECT * FROM test.fnCrtHlprCodeChkExps();
         -- fnCrtHlprCodeChkExps
         IF @exp_row_cnt IS NOT NULL EXEC tSQLt.AssertEquals @exp_row_cnt, @act_row_cnt,'087row_cnt';
         IF @exp_id      IS NOT NULL EXEC tSQLt.AssertEquals @exp_id     , @act_id     ,'088id';
         IF @exp_line    IS NOT NULL EXEC tSQLt.AssertEquals @exp_line   , @act_line   ,'089line';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the test helper code for a scalar fn
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- POSTCONDITIONS:
-- POST 01:
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallFn]()
RETURNS @t TABLE 
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(100)
   ,@rtn_ty_code  NCHAR(2)
   ,@ad_stp       BIT
   ,@prm_cnt      INT
   ,@tab1         VARCHAR(3) = dbo.fnGetNTabs(1)
   ,@tab2         VARCHAR(6) = dbo.fnGetNTabs(2)
   ,@tab3         NCHAR(9)    = dbo.fnGetNTabs(3)
   ,@tab4         NCHAR(12)   = dbo.fnGetNTabs(4)
   ,@tab5         NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@tab6         NCHAR(18)   = dbo.fnGetNTabs(6)
   SELECT
       @qrn    = qrn
      ,@ad_stp = ad_stp
      ,@prm_cnt= prm_cnt
   FROM test.RtnDetails;
   INSERT INTO @t (line) VALUES     (IIF(@ad_stp = 1 ,'-- fnCrtHlprCodeCallFn', ''));
   -------------------------------------------------------------------------
   -- Handle single parameter inline, but multiple parameters on separate lines
   -------------------------------------------------------------------------
   IF @prm_cnt = 1
   BEGIN
      -- Handle single parameter  inline
      INSERT INTO @t (line) SELECT
      (CONCAT(@tab4, 'SET @act_out_val = ', @qrn, '( @inp_,',param_nm,')'))
      FROM test.ParamDetails
      WHERE tst_ty='INP'
      ;
   END
   ELSE
   BEGIN
      -- Handle multiple parameters on separate lines
      INSERT INTO @t (line) VALUES
      (CONCAT(@tab4, 'SET @act_out_val = ', @qrn))
     ,(CONCAT(@tab4, '('))
   -- Add the parameters
   INSERT INTO @t (line) SELECT
      CONCAT( @tab5, STRING_AGG(CONCAT('@inp_',param_nm), ', '))
      FROM test.ParamDetails
      WHERE tst_ty='INP';
   INSERT INTO @t (line) VALUES
    (CONCAT(@tab4, ');'))
   ;
   END
      INSERT INTO @t (line) VALUES ('');
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeCallFn();
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_??';
    @inp_input_str,  @inp_sep,  @inp_ndx
   SELECT * FROM test.RtnDetails
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the test helper code for a scalar fn
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- POSTCONDITIONS:
-- POST 01:
--
-- Called by: fnCrtHlprCodeCallBloc
--
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallTF]()
RETURNS @t TABLE
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1            VARCHAR(3) = dbo.fnGetNTabs(1)
   ,@tab2            VARCHAR(6) = dbo.fnGetNTabs(2)
   ,@tab3            NCHAR(9)    = dbo.fnGetNTabs(3)
   ,@tab4            NCHAR(12)   = dbo.fnGetNTabs(4)
   ,@tab5            NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@line            VARCHAR(1000)
   ,@qrn             VARCHAR(100)
   ,@ad_stp          BIT
   ,@st_inp_ordinal  INT
   ,@inp_prm_cnt     INT = 0
   ,@display_tables  BIT
   ;
   SELECT
       @qrn            = qrn
      ,@ad_stp         = ad_stp
      ,@display_tables = display_tables
   FROM test.RtnDetails;
   SELECT @inp_prm_cnt = COUNT(*) FROM test.ParamDetails
   WHERE tst_ty='INP'
   ;
   INSERT INTO @t (line) VALUES
    (CONCAT(@tab4,'DROP TABLE IF EXISTS test.results', IIF(@ad_stp = 1 ,' -- fnCrtHlprCodeCallTF', '')))
   ,('')
   ;
   SELECT @st_inp_ordinal = MIN(ordinal)
   FROM test.ParamDetails
   WHERE tst_ty='INP'
   ;
   --------------------------------
   -- Handle 0 or 1 params inline
   --------------------------------
   IF @inp_prm_cnt = 0
   BEGIN
      SET @line = CONCAT(@tab4, 'SELECT * INTO test.Results FROM ', @qrn, '();');
      INSERT INTO @t (line) VALUES (@line);
   END
   IF @inp_prm_cnt = 1
   BEGIN
      SET @line = CONCAT(@tab4, 'SELECT * INTO test.Results FROM ', @qrn, '(');
      SET  @line =
      (
         SELECT TOP 1 CONCAT( @line, '@inp_', param_nm)
         FROM test.ParamDetails
         WHERE tst_ty ='INP'
      );
      SET  @line = CONCAT(@line, ');');
      INSERT INTO @t (line) VALUES (@line);
   END
   IF @inp_prm_cnt > 1
   BEGIN
      -------------------------------------
      -- Handle multiple params 1 per line
      -------------------------------------
      INSERT INTO @t (line) VALUES
          (CONCAT(@tab4, 'SELECT * INTO test.Results FROM ', @qrn))
         ,(CONCAT(@tab4, '('))
      ;
      -- Add params 1per line
      INSERT INTO @t (line)
      SELECT CONCAT( @tab5, iif(ordinal = @st_inp_ordinal,' ',',') , '@inp_', param_nm)
      FROM test.ParamDetails
      WHERE tst_ty ='INP';
      -- Close off fn ()
      INSERT INTO @t (line) VALUES
       (CONCAT(@tab4, ');'))
      ,('')
      ;
   END
   -- If not inline separate rtn call from next by 1 blnk line
   IF @inp_prm_cnt <2
      INSERT INTO @t (line) VALUES ('');
   -- If display tables then display tables
   INSERT INTO @t (line) VALUES (CONCAT(@tab4, 'IF @display_tables=1 SELECT * FROM test.results'));
   RETURN;
END
/*
SELECT * FROM test.fnCrtHlprCodeCallTF();
EXEC test.sp__crt_tst_rtns 'test].[fnCrtHlprCodeCallTF', @ad_stp=1
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 18-Apr-2024
-- Description: creates the tested rtn call dependant on the rtn type code
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:
-- Returns: lines of detailed test
--
-- Method:
-- delegate to a specific rtn based on rtn type
--
-- Called by: sp_crt_tst_hlpr_script
--
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCallBloc]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1         VARCHAR(3)  = dbo.fnGetNTabs(1)
   ,@tab2         VARCHAR(6)  = dbo.fnGetNTabs(2)
   ,@tab3         CHAR(9)     = dbo.fnGetNTabs(3)
   ,@tab4         CHAR(12)    = dbo.fnGetNTabs(4)
   ,@tab5         NCHAR(15)   = dbo.fnGetNTabs(5)
   ,@line         VARCHAR(60) = REPLICATE('-', 60)
   ,@line_star    VARCHAR(100)= N' --' + REPLICATE('*', 60)
   ,@qrn          VARCHAR(100)
   ,@rtn_ty_code  VARCHAR(2)
   ,@ad_stp       BIT
   ,@nl           VARCHAR(2) = CHAR(13)+CHAR(10)
   SELECT
       @qrn         = qrn
      ,@rtn_ty_code = rtn_ty_code
      ,@ad_stp      = ad_stp
   FROM test.RtnDetails
   IF @ad_stp = 1 INSERT INTO @t (line) VALUES (CONCAT(@tab2,'-- fnCrtHlprCodeCallBloc rtn ty:', @rtn_ty_code));
   WHILE 1=1
   BEGIN
      -- Add the rtn type if debugging
 --     IF @ad_stp = 1 INSERT INTO @t (line) VALUES( CONCAT(@tab2, '-- @rtn_ty_code:', @rtn_ty_code));
      INSERT INTO @t (line) VALUES
        (CONCAT(@tab2, 'WHILE 1 = 1'))
       ,(CONCAT(@tab2, 'BEGIN'))
       ,(CONCAT(@tab3, 'BEGIN TRY'))
       ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''010: Calling the tested routine: ', @qrn, ''';'))
       ,(CONCAT(@tab4, @line))
      IF @rtn_ty_code = 'P'
      BEGIN
         INSERT INTO @t (line)
            SELECT line FROM test.fnCrtHlprCodeCallProc();
            -- 250403: get the act row count 
         INSERT INTO @t (line) VALUES
         (@nl)
        ,(CONCAT(@tab4,'SELECT @act_row_cnt = @@ROWCOUNT;'))
         BREAK;
      END
      IF @rtn_ty_code = 'FN'
      BEGIN
         INSERT INTO @t (line)
            SELECT line FROM test.fnCrtHlprCodeCallFn();
         BREAK;
      END
      IF @rtn_ty_code = 'TF'
      BEGIN
         INSERT INTO @t (line)
            SELECT line FROM test.fnCrtHlprCodeCallTF();
         BREAK;
      END
      -- If here then unrecognised @rtn_ty_code
      INSERT INTO @t (line) VALUES( CONCAT('-- Unrecognised @rtn_ty_code:', @rtn_ty_code));
      BREAK;
   END -- while
   INSERT INTO @t (line) VALUES
       (CONCAT(@tab4, @line))
      ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''020: returned from ', @qrn, ''';'))
      ,('')
      ,(CONCAT(@tab4,'IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL'))
      ,(CONCAT(@tab4,'BEGIN'))
      ,(CONCAT(@tab5,'EXEC sp_log 4, @fn, ''030: oops! Expected exception was not thrown'';'))
      ,(CONCAT(@tab5, 'THROW 51000, '' Expected exception was not thrown'', 1;'))
      ,(CONCAT(@tab4,'END'))
      ,(CONCAT(@tab3,'END TRY'))
      ,(CONCAT(@tab3,'BEGIN CATCH'))
      ,(CONCAT(@tab4, 'SET @act_ex_num = ERROR_NUMBER();'))
      ,(CONCAT(@tab4, 'SET @act_ex_msg = ERROR_MESSAGE();'))
      ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''040: caught  exception: '', @act_ex_num, '' '',      @act_ex_msg;'))
      ,(CONCAT(@tab4, 'EXEC sp_log 1, @fn, ''050: check ex num: exp: '', @exp_ex_num, '' act: '', @act_ex_num;'))
      ,('')
      ,(CONCAT(@tab4, 'IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL'))
      ,(CONCAT(@tab4, 'BEGIN'))
      ,(CONCAT(@tab5, 'EXEC sp_log 4, @fn, ''060: an unexpected exception was raised'';'))
      ,(CONCAT(@tab5, 'THROW;'))
      ,(CONCAT(@tab4, 'END'))
      ,('')
      ,(CONCAT(@tab4, @line))
      ,(CONCAT(@tab4, '-- ASSERTION: if here then expected exception'))
      ,(CONCAT(@tab4, @line))
      ,(CONCAT(@tab4, 'IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, ''ex_num mismatch'';'))
      ,(CONCAT(@tab4, 'IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, ''ex_msg mismatch'';'))
      ,(CONCAT(@tab4, ''))
      ,(CONCAT(@tab4,'EXEC sp_log 2, @fn, ''070 test# '',@tst_num, '': exception test PASSED;'''))
      ,(CONCAT(@tab4, 'BREAK'))
      ,(CONCAT(@tab3, 'END CATCH'))
      ,('')
      ,(CONCAT(@tab3, '-- TEST:'))
      ,(CONCAT(@tab3,'EXEC sp_log 2, @fn, ''080: running tests   '';'))
   ;
    INSERT INTO  @t (line) 
    SELECT line FROM test.fnCrtHlprCodeChkExps();
    INSERT INTO  @t (line) VALUES
     ('')
    ,(CONCAT(@tab3, @line))
    ,(CONCAT(@tab3, '-- Passed tests'))
    ,(CONCAT(@tab3, @line))
    ,(CONCAT(@tab3, 'BREAK'))
    ,(CONCAT(@tab2, 'END --WHILE'))
   ;
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
EXEC tSQLt.RunAll
SELECT * FROM test.fnCrtHlprCodeCall('SP',1);
SELECT * FROM test.fnCrtHlprCodeCall('F',1);
SELECT * FROM test.fnCrtHlprCodeCall('TF',1);
SELECT * FROM test.RtnDetails;
EXEC test.sp__crt_tst_rtns 'dbo.sp_Import_Role', @trn=26, @ad_stp=1;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================
-- Author:      Terry Watts
-- Create date: 16-Apr-2024
-- Description: creates the helper close bloc
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:
-- =============================================================
CREATE FUNCTION [test].[fnCrtHlprCodeCloseBloc]()
RETURNS @t TABLE 
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1               VARCHAR(3) = '   '
   ,@tab2               VARCHAR(6) = '      '
   ,@rtn_ty_code        NCHAR(2)
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@detld_rtn_ty_code  VARCHAR(2)
   ,@qrn                VARCHAR(100)
   ,@sc_fn_ret_ty       VARCHAR(50)
   ,@ad_stp             BIT = 0
   ,@tst_rtn_nm         VARCHAR(60)
   SELECT
       @tst_rtn_nm = tst_rtn_nm
      ,@ad_stp     = ad_stp
   FROM test.RtnDetails;
   INSERT INTO @t (line)
   VALUES
    ('')
   ,(CONCAT(@tab2,'-- CLEANUP: ??', IIF(@ad_stp=1, ' -- fnCrtHlprCodeCloseBloc','')))
   ,('')
   ,(CONCAT(@tab2,'EXEC sp_log 1, @fn, ''990: all subtests PASSED'';'))
   ,(CONCAT(@tab1,'END TRY'))
   ,(CONCAT(@tab1,'BEGIN CATCH'))
   ,(CONCAT(@tab2,'EXEC test.sp_tst_hlpr_hndl_failure;'))
   ,(CONCAT(@tab2,'THROW;'))
   ,(CONCAT(@tab1,'END CATCH'))
   ,('')
   ,(CONCAT(@tab1,'EXEC test.sp_tst_hlpr_hndl_success;'))
   ,('END')
   ,('/*')
   ,('EXEC tSQLt.RunAll;')
   ,(CONCAT('EXEC tSQLt.Run ''test.', @tst_rtn_nm, ''';'))
   ,('*/')
   ;
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================
-- Author:        Terry Watts
-- Create date:   17-Apr-2024
-- Description:   creates the helper sig parameter list
-- Design:        
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
-- Postconditions: return table with the tst, inp and exp prms
-- Tests:
--    test_042_sp_pop_param_details
--    test_041_fnCrtHlprSigParams
-- =============================================================
CREATE FUNCTION [test].[fnCrtHlprSigParams]()
RETURNS @t TABLE
(
    id    INT IDENTITY(1,1)
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab                VARCHAR(3) = '   '
   ,@rtn_ty_code        NCHAR(2)
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@detld_rtn_ty_code  VARCHAR(2)
   ,@qrn                VARCHAR(100)
   ,@sc_fn_ret_ty       VARCHAR(50)
   ,@ad_stp             BIT         = 0
   ,@tst_rtn_nm         VARCHAR(60)
   ,@max_prm_len        INT
   SELECT
       @tst_rtn_nm   = tst_rtn_nm
      ,@ad_stp       = ad_stp
      ,@rtn_ty_code  = rtn_ty_code
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;
   SELECT @max_prm_len = MAX(dbo.fnLen(param_nm)) + 5 
   FROM test.ParamDetails;
   ------------------------------------------
   -- Create the input paams
   ------------------------------------------
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab
         ,iif(param_nm = 'tst_num' AND tst_ty='TST', ' ',',')
         ,'@',IIF(tst_ty = 'INP', 'inp_',IIF(tst_ty = 'EXP', 'exp_',''))
         ,dbo.fnPadRight(lower(param_nm), IIF(tst_ty IN ('INP', 'EXP'), @max_prm_len, @max_prm_len+4))
         ,' ', type_nm
         ,iif(@ad_stp = 1 AND param_nm = 'tst_num', ' -- fnCrtHlprSigParams', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty IN ('TST', 'INP')
   ;
   ------------------------------------------
   -- Create the exp paams
   ------------------------------------------
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab
         ,iif(param_nm = 'tst_num', ' ',',')
         ,'@',IIF(tst_ty = 'INP', 'inp_',IIF(tst_ty = 'EXP', 'exp_',''))
         ,dbo.fnPadRight(lower(param_nm)
         ,IIF(tst_ty IN ('INP', 'EXP'), @max_prm_len, @max_prm_len+4))
         ,' ', type_nm
         ,iif(tst_ty = 'EXP', dbo.fnPadLeft('= NULL', 22 - dbo.fnLen(type_nm)),'')
         ,iif(param_nm = 'tst_num', CONCAT(' -- fnCrtHlprSigParams ',@max_prm_len+6), '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 0
   ;
   ----------------------------------------------------
   -- If tstd rtn is a procedure then add @exp_RC param
   ----------------------------------------------------
   /*IF(@rtn_ty_code = 'P')
   INSERT INTO @t (line) VALUES
   (CONCAT(@tab, dbo.fnPadRight(',@exp_RC', @max_prm_len + 6), ' INT'))
   */
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab
         ,iif(param_nm = 'tst_num', ' ',',')
         ,'@',IIF(tst_ty = 'INP', 'inp_',IIF(tst_ty = 'EXP', 'exp_',''))
         ,dbo.fnPadRight(lower(param_nm), IIF(tst_ty IN ('INP', 'EXP'), @max_prm_len, @max_prm_len+4))
         , ' ', type_nm
         ,iif(tst_ty = 'EXP', dbo.fnPadLeft('= NULL', 22 - dbo.fnLen(type_nm)),'')
         ,iif(param_nm = 'tst_num', CONCAT(' -- fnCrtHlprSigParams ',@max_prm_len+6), '')
      )
   FROM test.ParamDetails
   WHERE tst_ty ='EXP' AND is_exception = 1
   ;
   RETURN;
END
/*
EXEC test.test_041_fnCrtHlprSigParams;
EXEC test.sp_set_rtn_details 'test.sp_tst_hlpr_st', @display_tables=1;
SELECT * FROM test.RtnDetails;
SELECT * FROM test.ParamDetails;
SELECT * FROM test.fnCrtHlprSigParams()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
--
-- Description: creates the test helper signature line for the hlpr script like:
-- ALTER PROCEDURE test.hlpr_106_fnGetParams
--    @qrn       VARCHAR(120)
--   ,@ordinal   INT
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- Test rtn: test.test_086_sp_crt_tst_hlpr_script
--
-- ====================================================================================
CREATE FUNCTION [test].[fnCrtHlprCodeHlprSig]()
RETURNS @t TABLE
(
    id    INT IDENTITY (1,1)
   ,line  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @qrn          VARCHAR(120)
   ,@schema_nm    VARCHAR(50)
   ,@rtn_nm       VARCHAR(60)
   ,@rtn_ty       NCHAR(1)
   ,@trn          VARCHAR(90)
   ,@tst_rtn_nm   VARCHAR(50)
   ,@hlpr_rtn_nm  VARCHAR(50)
   ,@ad_stp       BIT
   ,@cora         NCHAR(1)
   ,@tab          VARCHAR(3) = '   '
   SELECT
       @qrn       = qrn
      ,@schema_nm = schema_nm
      ,@rtn_nm     = rtn_nm
      ,@trn        = trn
      ,@tst_rtn_nm = tst_rtn_nm
      ,@hlpr_rtn_nm= hlpr_rtn_nm
      ,@ad_stp     = ad_stp
      ,@cora       = cora
   FROM test.RtnDetails;
   SELECT @rtn_ty = rtn_ty
   FROM test.RtnDetails;
   INSERT INTO @t( line)
   VALUES
       (CONCAT(iif(@cora='C','CREATE','ALTER'),' PROCEDURE test.', @hlpr_rtn_nm, IIF(@ad_stp=1,' -- fnCrtHlprCodeHlprSig','')))
   -- Add the rtn params
   INSERT INTO @t( line)
   SELECT line
   FROM test.fnCrtHlprSigParams();
   RETURN;
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
EXEC tSQLt.Run 'test.test_057_sp_crt_tst_hlpr';
EXEC tSQLt.RunAll;
EXEC test.sp_get_rtn_details 'dbo.fnEatWhitespace';
SELECT * FROM test.fnCrtHlprCodeHlprSig();
EXEC test.sp_get_rtn_details 'dbo.sp_get_excel_data';
SELECT * FROM test.fnCrtHlprCodeHlprSig();
SELECT * FROM test.fnEatWhitespace();
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ============================================================================================================================
-- Author:      Terry Watts
-- Create date: 03-MAY-2024
-- Description: provides teh suffix for a pparameter based on its test ty in Test.ParamDetails
--
-- PRECONDITIONS:
-- test.ParamDetails pop'd
--
-- POSTCONDITIONS:
-- POST 01:
--
-- Tests:
-- ============================================================================================================================
CREATE FUNCTION [test].[fnGetParamWithSuffix](@param_nm      VARCHAR(20))
RETURNS VARCHAR(50)
AS
BEGIN
   DECLARE
       @rtn_nm      VARCHAR(4000)
      ,@tst_ty      VARCHAR(3)
   SELECT
        @tst_ty  = tst_ty
   FROM test.ParamDetails
   WHERE
      param_nm=@param_nm;
   RETURN LOWER(CONCAT('@', IIF(@tst_ty='TST', '',CONCAT(@tst_ty, '_')), @param_nm));
END
/*
EXEC test.sp_get_rtn_details 'dbo.sp_grep_rtns', @display_tables=1;
PRINT test.fnGetParamWithSuffix('ss_principal_id');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2024
-- Description: creates the parameter list for
-- the helper call in the mn tst rtn
-- =============================================
CREATE FUNCTION [test].[fnCrtMnCodeCallHlprPrms]()
RETURNS
@t TABLE
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1         VARCHAR(3) = '   '
   ,@tab2         VARCHAR(6) = '      '
   ,@max_prm_len  INT
   ,@ad_stp       BIT        = 0
   ,@rtn_ty_code  NCHAR(2)
   ,@tst_rtn_nm   VARCHAR(60)
   SELECT
       @tst_rtn_nm   = tst_rtn_nm
      ,@ad_stp       = ad_stp
      ,@rtn_ty_code  = rtn_ty_code
      ,@max_prm_len  = max_prm_len
   FROM test.RtnDetails;
   -----------------------------------------------------------------
   -- Add the hdr parameters @tst_num, @tst_key
   -----------------------------------------------------------------
   INSERT INTO @t (line) 
   SELECT
      CONCAT
      (
         @tab2, iif(ordinal=1, ' ', ',')
        ,dbo.fnPadRight
               (
                  iif(param_nm = 'display_tables' AND tst_ty='TST', CONCAT('@', param_nm), test.fnGetParamWithSuffix(param_nm))
                 , @max_prm_len+5
               ) 
            , ' = '
        , iif(is_chr_ty=1, iif(ordinal=1, '''001''',''''''), '0')
        , iif(ordinal=1 AND @ad_stp = 1, ' -- fnCrtMnCodeCallHlprPrms', '')
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'TST';
   -----------------------------------------------------------------
   -- Add the tested rtn parameters
   -----------------------------------------------------------------
   INSERT INTO @t (line) 
   SELECT
      CONCAT
      (
         @tab2, iif(ordinal=1, ' ', ',')
      , dbo.fnPadRight(test.fnGetParamWithSuffix(param_nm), @max_prm_len+5), ' = ', iif(is_chr_ty=1, '''''', '0'))
   FROM test.ParamDetails
   WHERE tst_ty = 'INP';
   -----------------------------------------------------------------
   -- Add the expected parameters
   -----------------------------------------------------------------
   INSERT INTO @t (line)
   SELECT
      CONCAT
      (
          @tab2, iif(ordinal=1, ' ', ',')
         ,dbo.fnPadRight(test.fnGetParamWithSuffix(param_nm), @max_prm_len+5), ' = NULL'
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP' AND is_exception = 0;
   INSERT INTO @t (line) 
   SELECT
      CONCAT
      (
          @tab2, iif(ordinal=1, ' ', ',')
         ,dbo.fnPadRight(test.fnGetParamWithSuffix(param_nm), @max_prm_len+5), ' = NULL'
      )
   FROM test.ParamDetails
   WHERE tst_ty = 'EXP' AND is_exception = 1;
   -----------------------------------------------------------------
   -- Close the Decl statement
   -----------------------------------------------------------------
   INSERT INTO @t (line) VALUES(CONCAT(@tab1, ';'));
   RETURN;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================================================
-- Author:      Terry Watts
-- Create date: 16-Apr-2024
-- Description: Add the EXEC test.<test helper proc> call and params
--
-- Preconditions: Test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:
-- Returns: @rtnDef
-- Post 01:
--
-- Called By: sp_crt_tst_mn_script
-- ==============================================================================================
CREATE FUNCTION [test].[fnCrtMnCodeCallHlpr]()
RETURNS @t TABLE
(
    id    INT
   ,line  VARCHAR(500)
)
AS
BEGIN
   DECLARE
    @tab1               VARCHAR(3) = '   '
   ,@trn                INT
   ,@tst_proc_hlpr_nm   VARCHAR(60)
   ,@rtn_nm             VARCHAR(60)
   ,@ad_stp             BIT = 0
   ;
   SELECT
       @tst_proc_hlpr_nm = hlpr_rtn_nm
      ,@ad_stp           = ad_stp
      ,@trn              = trn
      ,@rtn_nm           = rtn_nm
   FROM test.RtnDetails
   ;
   -----------------------------------------------------------------
   -- Add the EXEC test.<test helper proc> call
   -----------------------------------------------------------------
   INSERT INTO @t (line) VALUES (CONCAT(@tab1, 'EXEC test.',@tst_proc_hlpr_nm, iif(@ad_stp=1, '  -- fnCrtMnCodeCallHlpr','')));
   -----------------------------------------------------------------
   -- Add the helper parameters
   -----------------------------------------------------------------
    INSERT INTO @t (line)
    SELECT line FROM test.fnCrtMnCodeCallHlprPrms();
   RETURN;
END
/*
SELECT * FROM test.fnCrtMnCodeCallHlpr();
EXEC tSQLt.Run 'test.test_067_sp_crt_tst_mn';
SELECT * FROM test.RtnDetails
SELECT * FROM test.ParamDetails
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
--
-- Description: creates the close bloc for the main test rtn
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
--
-- Test rtn: test.test_086_sp_crt_tst_hlpr_script
--
-- ====================================================================================
CREATE FUNCTION [test].[fnCrtMnCodeClose]()
RETURNS @t TABLE
(
    id    INT IDENTITY (1,1)
   ,line  VARCHAR(1000)
)
AS
BEGIN
   DECLARE
    @tst_rtn_nm   VARCHAR(50)
   ,@tab1         NCHAR(3) = '   '
   ,@ad_stp       BIT
   SELECT
      @tst_rtn_nm = tst_rtn_nm
      ,@ad_stp    = ad_stp
   FROM test.RtnDetails;
   INSERT INTO @t( line)
   VALUES
    ('')
   ,(CONCAT(@tab1,'EXEC sp_log 2, @fn, ''99: All subtests PASSED''', IIF(@ad_stp=1, ' -- CLS-1','')))
   ,(CONCAT(@tab1, 'EXEC test.sp_tst_mn_cls;'))
   ,('END')
   ,('/*')
   ,('EXEC tSQLt.RunAll;')
   ,(CONCAT('EXEC tSQLt.Run ''test.', @tst_rtn_nm,''';'))
   ,('*/')
   RETURN;
END
/*
SELECT * FROM test.fnCrtCodeMnTstSig()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: settings key for the failes test sub number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntFailedTstNumKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Failed test num';
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: settings key for the current failed test number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntFailedTstSubNumKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Failed test sub num';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 03-DEC-2024
-- Description: gets the current sub test id key
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntSubTstKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Current sub test';
END
/*
PRINT test.fnGetCrntSubTstKey()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry Watts
-- Create date: 03-DEC-2024
-- Description: gets the current sub test identifier
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntSubTst]()
RETURNS VARCHAR(100)
AS
BEGIN
   RETURN CONVERT(VARCHAR(100), SESSION_CONTEXT(test.fnGetCrntSubTstKey()));
END
/*
PRINT test.fnGetCrntSubTst();
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================
-- Author:      Terry
-- Create date: 03-DEC-2024
-- Description: Gets the current failed test num from settings
-- Tests: test_049_SetGetCrntTstValue
-- =============================================================
CREATE FUNCTION [test].[fnGetCrntTst1OffSetupFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Tst1OffSetupFn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current close fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstClsFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'TCLS fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current tested fn name from settings
-- Key:         N'Tested fn'
-- Tests:       test.test 030 chkTestConfig
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstdFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Tested fn';
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current tested fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstdFn]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstdFnKey()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: Gets the current ErrorStateKey key
-- Tests: test_049_SetGetCrntTstValue
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstErrStKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Error state';
END
/*
EXEC tSQLt.Run 'test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: accessor: error_state
-- Tests: test_049_SetGetCrntTstValue
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstErrSt]()
RETURNS INT
AS
BEGIN
   RETURN CONVERT( INT, SESSION_CONTEXT(test.fnGetCrntTstErrStKey()));
END
/*
PRINT [test].[fnGetCrntTstErrSt]()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current test fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Test fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current test fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstFn]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstFnKey()));
END
/*
PRINT [test].[fnGetCurrentTestFnName]()
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current close fn name from settings
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstHlprFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Hlpr fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 20-NOV-2024
-- Description: Gets the current test hlpr fn name from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstHlprFn]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstHlprFnKey()));
END
/*
PRINT [test].[fnGetCrntTstHlprFn]()
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: settigns key for the current test number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstNumKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Test num';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry
-- Create date: 05-FEB-2021
-- Description: Gets the current test helper fn name from settings
-- Key:         N'Test num'
-- Tests:       test.test 030 chkTestConfig
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstNum]()
RETURNS VARCHAR(60)
AS
BEGIN
   RETURN CONVERT(VARCHAR(60), SESSION_CONTEXT(test.fnGetCrntTstNumKey()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test_030_chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstNumKey();
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===========================================================================
-- Author:      Terry
-- Create date: 20-NOV-2024
-- Description: gets the settings key for the current test number like T001
-- Tests: [test].[test 030 chkTestConfig]
-- ===========================================================================
CREATE FUNCTION [test].[fnGetCrntTstNum2Key]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Test num2';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =================================================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2024
-- Description: Gets the current tst_num2 from the session context
--              This is the 3 digit int number only part of the sub test identifier
-- Key:         N'Test num'
-- Tests:       test.test 030 chkTestConfig
-- =================================================================================
CREATE FUNCTION [test].[fnGetCrntTstNum2]()
RETURNS VARCHAR(3)
AS
BEGIN
   RETURN CONVERT(VARCHAR(3), SESSION_CONTEXT(test.fnGetCrntTstNum2Key()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test_030_chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstNumKey();
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 04-FEB-2021
-- Description: Gets the current per test fn name from settings
-- ===============================================================
CREATE FUNCTION [test].[fnGetCrntTstSetupFnKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'TSU fn';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: Gets the display log flag key
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetDisplayLogFlgKey]()
RETURNS NVARCHAR(30)
AS
BEGIN
   RETURN N'Display Log Flag';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: Gets the display log flag
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetDisplayLogFlg]()
RETURNS BIT
AS
BEGIN
   RETURN CONVERT(BIT, SESSION_CONTEXT(test.fnGetDisplayLogFlgKey()));
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =========================================================================
-- Author:      Terry Watts
-- Create date: 03-Dec-2023
-- Description: gets the next test rtn number
--
--- changes:
-- 240419: speeded up this routine by NOT USING the SQL# IsNumeric routine
-- 241111: first look for the first unused trn less than the max used trn
--         if not found take the max used trn + 1
-- =========================================================================
CREATE FUNCTION [test].[fnGetNxtTstRtnNum]()
RETURNS INT
AS
BEGIN
   DECLARE @ret INT
   -- first look for the first unused trn less than the max used trn
   SET @ret =
   (
      SELECT TOP 1 FORMAT(trn+1, '000') AS nxt_trn
      FROM
      (
         SELECT SUBSTRING(rtn_nm, 6,3) AS trn, LEAD(SUBSTRING(rtn_nm, 6,3)) OVER(ORDER BY rtn_nm) AS nxt_trn
         FROM SysRtns_vw 
         WHERE
             schema_nm = 'test'
         AND ty_code   = 'P'
         AND rtn_nm like 'test%'
         AND iif(SUBSTRING(rtn_nm, 6,3) LIKE '[0-9][0-9][0-9]', CONVERT(int, SUBSTRING(rtn_nm, 6,3)), 0) > 0
      ) X
      WHERE nxt_trn>trn + 1
   );
   -- If not found take the max used trn + 1
   IF @ret IS NULL
      SELECT @ret = next_rtn_num
      FROM
      (
         SELECT CONVERT(INT, last_rtn_num)+1 AS next_rtn_num
         FROM
         (
            SELECT MAX(SUBSTRING(rtn_nm, 6,3)) as last_rtn_num 
            FROM SysRtns_vw 
            WHERE 
               schema_nm='test'
               AND ty_code = 'P'
               AND rtn_nm like 'test%'
               AND IIF(SUBSTRING(rtn_nm, 6,3) LIKE '[0-9][0-9][0-9]', CONVERT(int, SUBSTRING(rtn_nm, 6,3)), 0) > 0
         ) X
      ) Y;
   IF @ret IS NULL SET @ret = 0;
   RETURN @ret;
END
/*
PRINT test.fnGetNxtTstRtnNum();
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =========================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2024
-- Description: returns test hdr or footer line
-- =========================================================
CREATE FUNCTION [test].[fnGetTstHdrFooterLine]
(
    @is_mn_tst BIT
   ,@is_Hdr    BIT            -- 1:hdr, 0 = footer
   ,@tst_num   VARCHAR(100)
   ,@msg       VARCHAR(100)
)
RETURNS VARCHAR(500)
AS
BEGIN
   DECLARE
       @len  INT
      ,@line VARCHAR(160)
      ,@NL   VARCHAR(2)    = NCHAR(13) + NCHAR(10)
      ,@len2 INT
   ;
   SET @line = REPLICATE(iif(@is_mn_tst=1, '*','+'), 160);
   SET @len = dbo.fnLen(@tst_num);
   SET @len2 = 120;
   IF @is_mn_tst = 0 SET @len2 = @len2 +1;
   IF @is_Hdr = 0 SET @len2 = @len2 +2;
   RETURN
      CONCAT
      (
          @NL
         ,SUBSTRING(@line,1,30)
         ,iif(@is_mn_tst=1, ' Main Test',' Sub-test')
         ,' ', @tst_num, ' '
         ,@msg, ' '
         ,SUBSTRING(@line,1,dbo.fnMax(5, @len2 - @len)) -- + iif(@is_mn_tst=0, 1, 0)
         ,@NL
         ,@NL
      );
END
/*
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: settings key for the failes test sub number
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetTstPassCntKey]()
RETURNS NVARCHAR(60)
AS
BEGIN
   RETURN N'Passed test count';
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===============================================================
-- Author:      Terry
-- Create date: 06-FEB-2021
-- Description: Gets the failed test number  from settings
-- Tests: [test].[test 030 chkTestConfig]
-- ===============================================================
CREATE FUNCTION [test].[fnGetTstPassCnt]()
RETURNS INT
AS
BEGIN
   DECLARE @cnt INT;
   SET @cnt = CONVERT(INT, SESSION_CONTEXT(test.[fnGetTstPassCntKey]()));
   IF @cnt IS NULL  -- handle null as we are incrmenting this
      SET @cnt = 0;
   RETURN @cnt
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--====================================================================================
-- Author:           Terry Watts in concert with ChapGPT
-- Create date:      10-Jul-2025
-- Rtn:              test.test_061_sp_aggregate_row_to_string
-- Description: main test routine for the dbo.sp_aggregate_row_to_string routine 
--====================================================================================
CREATE PROCEDURE [dbo].[sp_aggregate_row_to_string]
    @TableName   SYSNAME,
    @WhereClause NVARCHAR(MAX), -- e.g., 'ID = 1'
    @Sep         NVARCHAR(10) = ',',  -- separator between columns
    @Result      NVARCHAR(MAX) OUTPUT
AS
BEGIN
    DECLARE @sql NVARCHAR(MAX) = '';
    DECLARE @colExpr NVARCHAR(MAX) = '';
    DECLARE @sepLiteral NVARCHAR(20) = QUOTENAME(@sep, ''''); -- e.g. ','  "','"
    SET @sep = ISNULL(@Sep, ',');
    -- Cursor to loop over all columns
    DECLARE col_cursor CURSOR FOR
    SELECT name
    FROM sys.columns
    WHERE object_id = OBJECT_ID(@TableName);
    DECLARE @col SYSNAME;
    DECLARE @first BIT = 1;
    OPEN col_cursor;
    FETCH NEXT FROM col_cursor INTO @col;
    WHILE @@FETCH_STATUS = 0
    BEGIN
        IF @first = 1
        BEGIN
            SET @colExpr = CONCAT('ISNULL(CAST(', QUOTENAME(@col), ' AS NVARCHAR(MAX)), '''')');
            SET @first = 0;
        END
        ELSE
        BEGIN
            SET @colExpr = CONCAT(@colExpr, ' + ', @sepLiteral, ' + ISNULL(CAST(', QUOTENAME(@col), ' AS NVARCHAR(MAX)), '''')');
        END
        FETCH NEXT FROM col_cursor INTO @col;
    END
    CLOSE col_cursor;
    DEALLOCATE col_cursor;
    -- Build the final dynamic SQL
    SET @sql = '
        SELECT @ResultOut = ' + @colExpr + '
        FROM ' + QUOTENAME(@TableName) + '
        WHERE ' + @WhereClause;
    -- Execute it
    EXEC sp_executesql
        @sql,
        N'@ResultOut NVARCHAR(MAX) OUTPUT',
        @ResultOut = @Result OUTPUT;
END
/*
DECLARE @act_file_cols NVARCHAR(MAX);
EXEC sp_aggregate_row_to_string 'Enrollment','enrollment_id = 1',',', @act_file_cols OUTPUT;
PRINT @act_file_cols;
SELECT * FROM Enrollment WHERE enrollment_id = 1;
--> 12023-1908112
EXEC test.sp__crt_tst_rtns '[dbo].[sp_aggregate_row_to_string]';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 03-APR-2020
-- Description: Inserts a log row in the app log
--
--              Splits into column based on tabs in the the message or 
   -- set @tmp = LEFT(CONCAT(REPLICATE( '  ', @sf), REPLACE(LEFT( @tmp, 500), @NL, '--')), 500);
   -- set @tmp = LEFT(CONCAT( REPLACE(LEFT( @tmp, 500), @NL, '--')), 500);
-- =============================================
CREATE PROCEDURE [dbo].[sp_appLog_display]
    @rtns   VARCHAR(MAX) = NULL -- like 'dbo.fnA,test.sp_b'
   ,@msg    VARCHAR(4000)= NULL     -- no %%
   ,@level  INT          = NULL
   ,@id     INT          = NULL -- starting id
   ,@dir    BIT          = 1 -- ASC
AS
BEGIN
DECLARE
    @fn                 VARCHAR(35)   = N'sp_appLog_display '
   ,@sql                VARCHAR(4000)
   ,@need_where         BIT = 0
   ,@nl                 VARCHAR(2)   = CHAR(13) + CHAR(10)
   ,@fns                IdNmTbl
   ,@s                  VARCHAR(4000)
   ;
   SET NOCOUNT ON;
   INSERT into @fns(val) SELECT value FROM string_split(@rtns,',');
   SELECT @s = string_agg(CONCAT('''', val, ''''),',') FROM @fns;
--   PRINT(@s);
   SET @need_where = 
      IIF(    @rtns  IS NOT NULL
           OR @level IS NOT NULL
           OR @id    IS NOT NULL
           OR @msg   IS NOT NULL
           ,1, 0);
   SET @sql = CONCAT(
'SELECT
  id
,[level]
,rtn AS [rtn',   REPLICATE('_',20), ']
,SUBSTRING(msg, 1  , 128) AS ''msg1', REPLICATE('_',100), '''
,SUBSTRING(msg, 129, 128) AS ''msg2', REPLICATE('_',100), '''
,SUBSTRING(msg, 257, 128) AS ''msg3', REPLICATE('_',100), '''
,SUBSTRING(msg, 385, 128) AS ''log4', REPLICATE('_',100), '''
FROM AppLog
'
,iif(@need_where= 0, '', CONCAT('WHERE '                                                            , @nl))
,iif(@rtns  IS NULL, '', CONCAT(' rtn IN (', @s, ')'                                                , @nl))
,iif(@msg   IS NULL, '', CONCAT(IIF(@rtns IS NULL                   ,'', ' AND'),' msg LIKE (''%', @msg, '%'')'         , @nl))
,iif(@level IS NULL, '', CONCAT(IIF(@rtns IS NULL                   ,'', ' AND'),' level = ', @level, @nl))
,iif(@id    IS NULL, '', CONCAT(IIF(@rtns IS NULL AND @level IS NULL,'', ' AND'),' id >= '  , @id   , @nl))
,'ORDER BY ID ', iif(@dir=1, 'ASC','DESC'), ';'
);
 --  PRINT CONCAT(@fn, '100: executing sql:', @sql);
   EXEC (@sql);
/*   IF dbo.fnGetLogLevel() = 0
      PRINT CONCAT( @fn,'999: leaving:');*/
END
/*
EXEC tSQLt.RunAll;
EXEC sp_appLog_display;
EXEC sp_appLog_display @rtns='S2_UPDATE_TRIGGER',@msg='@fixup_row_id: 4'
EXEC sp_appLog_display @id=140;
000: starting @fixup_row_id: 4, @imp_file_nm: [ImportCorrections_221018-Crops.txt], @fixup_stg_id: 4, @search_clause: [ agricult
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[AppLog](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[timestamp] [varchar](30) NOT NULL,
	[schema_nm] [varbinary](20) NULL,
	[rtn] [varchar](60) NULL,
	[hit] [int] NULL,
	[log] [varchar](max) NULL,
	[msg] [varchar](max) NULL,
	[level] [int] NULL,
	[row_count] [int] NULL,
 CONSTRAINT [PK_AppLog] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
ALTER TABLE [dbo].[AppLog] ADD  CONSTRAINT [DF_AppLog_timestamp]  DEFAULT (getdate()) FOR [timestamp]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =========================================================================
-- Author:      Terry Watts
-- Create date: 22-MAR-2020
-- Description: Logs to output and to the AppLog table
-- Level: 0 DEBUG
--        1 INFO
--        2 NOTE
--        3 WARNING (CONTINUE)
--        4 ERROR   (STOP)
--
-- Changes:
-- 231014: Added support of table logging: add a row to table for each log 
--            Level and msg
-- 231016: Added fn and optional row count columns
-- 231017: @fn no longer needs the trailing ' :'
-- 231018: @fn, @row_count are stored as separate fields
-- 231115: added Level
-- 231116: always append to the AppLog table - bit print is conditional on level
-- 240309: Trimmed the  @fn paameter as it is left padded
-- 240314: Logic Change: now if less than min log level do not log or print msg
-- 231221: added hold, values:
--          0: print cache first then this msg on same line immediatly
--          1: cache msg for later - dont print it now 
--          2: dump cache first then print this msg on a new line immediatly
-- 240422: separate lines into a separate display line if msg contains \r\n
-- =================================================================================
CREATE PROCEDURE [dbo].[sp_log]
 @level  INT = 1
,@fn     VARCHAR(45)=NULL
,@msg00  VARCHAR(MAX)=NULL,@msg01  VARCHAR(MAX)=NULL,@msg02  VARCHAR(MAX)=NULL,@msg03  VARCHAR(MAX)=NULL,@msg04  VARCHAR(MAX)=NULL,@msg05  VARCHAR(MAX)=NULL,@msg06  VARCHAR(MAX)=NULL,@msg07  VARCHAR(MAX)=NULL,@msg08  VARCHAR(MAX)=NULL,@msg09  VARCHAR(MAX)=NULL
,@msg10  VARCHAR(MAX)=NULL,@msg11  VARCHAR(MAX)=NULL,@msg12  VARCHAR(MAX)=NULL,@msg13  VARCHAR(MAX)=NULL,@msg14  VARCHAR(MAX)=NULL,@msg15  VARCHAR(MAX)=NULL,@msg16  VARCHAR(MAX)=NULL,@msg17  VARCHAR(MAX)=NULL,@msg18  VARCHAR(MAX)=NULL,@msg19  VARCHAR(MAX)=NULL
,@msg20  VARCHAR(MAX)=NULL,@msg21  VARCHAR(MAX)=NULL,@msg22  VARCHAR(MAX)=NULL,@msg23  VARCHAR(MAX)=NULL,@msg24  VARCHAR(MAX)=NULL,@msg25  VARCHAR(MAX)=NULL,@msg26  VARCHAR(MAX)=NULL,@msg27  VARCHAR(MAX)=NULL,@msg28  VARCHAR(MAX)=NULL,@msg29  VARCHAR(MAX)=NULL
,@msg30  VARCHAR(MAX)=NULL,@msg31  VARCHAR(MAX)=NULL,@msg32  VARCHAR(MAX)=NULL,@msg33  VARCHAR(MAX)=NULL,@msg34  VARCHAR(MAX)=NULL,@msg35  VARCHAR(MAX)=NULL,@msg36  VARCHAR(MAX)=NULL,@msg37  VARCHAR(MAX)=NULL,@msg38  VARCHAR(MAX)=NULL,@msg39  VARCHAR(MAX)=NULL
,@msg40  VARCHAR(MAX)=NULL,@msg41  VARCHAR(MAX)=NULL,@msg42  VARCHAR(MAX)=NULL,@msg43  VARCHAR(MAX)=NULL,@msg44  VARCHAR(MAX)=NULL,@msg45  VARCHAR(MAX)=NULL,@msg46  VARCHAR(MAX)=NULL,@msg47  VARCHAR(MAX)=NULL,@msg48  VARCHAR(MAX)=NULL,@msg49  VARCHAR(MAX)=NULL
,@msg50  VARCHAR(MAX)=NULL,@msg51  VARCHAR(MAX)=NULL,@msg52  VARCHAR(MAX)=NULL,@msg53  VARCHAR(MAX)=NULL,@msg54  VARCHAR(MAX)=NULL,@msg55  VARCHAR(MAX)=NULL,@msg56  VARCHAR(MAX)=NULL,@msg57  VARCHAR(MAX)=NULL,@msg58  VARCHAR(MAX)=NULL,@msg59  VARCHAR(MAX)=NULL
,@msg60  VARCHAR(MAX)=NULL,@msg61  VARCHAR(MAX)=NULL,@msg62  VARCHAR(MAX)=NULL,@msg63  VARCHAR(MAX)=NULL,@msg64  VARCHAR(MAX)=NULL,@msg65  VARCHAR(MAX)=NULL,@msg66  VARCHAR(MAX)=NULL,@msg67  VARCHAR(MAX)=NULL,@msg68  VARCHAR(MAX)=NULL,@msg69  VARCHAR(MAX)=NULL
,@msg70  VARCHAR(MAX)=NULL,@msg71  VARCHAR(MAX)=NULL,@msg72  VARCHAR(MAX)=NULL,@msg73  VARCHAR(MAX)=NULL,@msg74  VARCHAR(MAX)=NULL,@msg75  VARCHAR(MAX)=NULL,@msg76  VARCHAR(MAX)=NULL,@msg77  VARCHAR(MAX)=NULL,@msg78  VARCHAR(MAX)=NULL,@msg79  VARCHAR(MAX)=NULL
,@msg80  VARCHAR(MAX)=NULL,@msg81  VARCHAR(MAX)=NULL,@msg82  VARCHAR(MAX)=NULL,@msg83  VARCHAR(MAX)=NULL,@msg84  VARCHAR(MAX)=NULL,@msg85  VARCHAR(MAX)=NULL,@msg86  VARCHAR(MAX)=NULL,@msg87  VARCHAR(MAX)=NULL,@msg88  VARCHAR(MAX)=NULL,@msg89  VARCHAR(MAX)=NULL
,@msg90  VARCHAR(MAX)=NULL,@msg91  VARCHAR(MAX)=NULL,@msg92  VARCHAR(MAX)=NULL,@msg93  VARCHAR(MAX)=NULL,@msg94  VARCHAR(MAX)=NULL,@msg95  VARCHAR(MAX)=NULL,@msg96  VARCHAR(MAX)=NULL,@msg97  VARCHAR(MAX)=NULL,@msg98  VARCHAR(MAX)=NULL,@msg99  VARCHAR(MAX)=NULL
,@msg100 VARCHAR(MAX)=NULL,@msg101 VARCHAR(MAX)=NULL,@msg102 VARCHAR(MAX)=NULL,@msg103 VARCHAR(MAX)=NULL,@msg104 VARCHAR(MAX)=NULL,@msg105 VARCHAR(MAX)=NULL,@msg106 VARCHAR(MAX)=NULL,@msg107 VARCHAR(MAX)=NULL,@msg108 VARCHAR(MAX)=NULL,@msg109 VARCHAR(MAX)=NULL
,@msg110 VARCHAR(MAX)=NULL,@msg111 VARCHAR(MAX)=NULL,@msg112 VARCHAR(MAX)=NULL,@msg113 VARCHAR(MAX)=NULL,@msg114 VARCHAR(MAX)=NULL,@msg115 VARCHAR(MAX)=NULL,@msg116 VARCHAR(MAX)=NULL,@msg117 VARCHAR(MAX)=NULL,@msg118 VARCHAR(MAX)=NULL,@msg119 VARCHAR(MAX)=NULL
,@msg120 VARCHAR(MAX)=NULL,@msg121 VARCHAR(MAX)=NULL,@msg122 VARCHAR(MAX)=NULL,@msg123 VARCHAR(MAX)=NULL,@msg124 VARCHAR(MAX)=NULL,@msg125 VARCHAR(MAX)=NULL,@msg126 VARCHAR(MAX)=NULL,@msg127 VARCHAR(MAX)=NULL,@msg128 VARCHAR(MAX)=NULL,@msg129 VARCHAR(MAX)=NULL
,@msg130 VARCHAR(MAX)=NULL,@msg131 VARCHAR(MAX)=NULL,@msg132 VARCHAR(MAX)=NULL,@msg133 VARCHAR(MAX)=NULL,@msg134 VARCHAR(MAX)=NULL,@msg135 VARCHAR(MAX)=NULL,@msg136 VARCHAR(MAX)=NULL,@msg137 VARCHAR(MAX)=NULL,@msg138 VARCHAR(MAX)=NULL,@msg139 VARCHAR(MAX)=NULL
,@msg140 VARCHAR(MAX)=NULL,@msg141 VARCHAR(MAX)=NULL,@msg142 VARCHAR(MAX)=NULL,@msg143 VARCHAR(MAX)=NULL,@msg144 VARCHAR(MAX)=NULL,@msg145 VARCHAR(MAX)=NULL,@msg146 VARCHAR(MAX)=NULL,@msg147 VARCHAR(MAX)=NULL,@msg148 VARCHAR(MAX)=NULL,@msg149 VARCHAR(MAX)=NULL
,@msg150 VARCHAR(MAX)=NULL,@msg151 VARCHAR(MAX)=NULL,@msg152 VARCHAR(MAX)=NULL,@msg153 VARCHAR(MAX)=NULL,@msg154 VARCHAR(MAX)=NULL,@msg155 VARCHAR(MAX)=NULL,@msg156 VARCHAR(MAX)=NULL,@msg157 VARCHAR(MAX)=NULL,@msg158 VARCHAR(MAX)=NULL,@msg159 VARCHAR(MAX)=NULL
,@msg160 VARCHAR(MAX)=NULL,@msg161 VARCHAR(MAX)=NULL,@msg162 VARCHAR(MAX)=NULL,@msg163 VARCHAR(MAX)=NULL,@msg164 VARCHAR(MAX)=NULL,@msg165 VARCHAR(MAX)=NULL,@msg166 VARCHAR(MAX)=NULL,@msg167 VARCHAR(MAX)=NULL,@msg168 VARCHAR(MAX)=NULL,@msg169 VARCHAR(MAX)=NULL
,@msg170 VARCHAR(MAX)=NULL,@msg171 VARCHAR(MAX)=NULL,@msg172 VARCHAR(MAX)=NULL,@msg173 VARCHAR(MAX)=NULL,@msg174 VARCHAR(MAX)=NULL,@msg175 VARCHAR(MAX)=NULL,@msg176 VARCHAR(MAX)=NULL,@msg177 VARCHAR(MAX)=NULL,@msg178 VARCHAR(MAX)=NULL,@msg179 VARCHAR(MAX)=NULL
,@msg180 VARCHAR(MAX)=NULL,@msg181 VARCHAR(MAX)=NULL,@msg182 VARCHAR(MAX)=NULL,@msg183 VARCHAR(MAX)=NULL,@msg184 VARCHAR(MAX)=NULL,@msg185 VARCHAR(MAX)=NULL,@msg186 VARCHAR(MAX)=NULL,@msg187 VARCHAR(MAX)=NULL,@msg188 VARCHAR(MAX)=NULL,@msg189 VARCHAR(MAX)=NULL
,@msg190 VARCHAR(MAX)=NULL,@msg191 VARCHAR(MAX)=NULL,@msg192 VARCHAR(MAX)=NULL,@msg193 VARCHAR(MAX)=NULL,@msg194 VARCHAR(MAX)=NULL,@msg195 VARCHAR(MAX)=NULL,@msg196 VARCHAR(MAX)=NULL,@msg197 VARCHAR(MAX)=NULL,@msg198 VARCHAR(MAX)=NULL,@msg199 VARCHAR(MAX)=NULL
,@msg200 VARCHAR(MAX)=NULL,@msg201 VARCHAR(MAX)=NULL,@msg202 VARCHAR(MAX)=NULL,@msg203 VARCHAR(MAX)=NULL,@msg204 VARCHAR(MAX)=NULL,@msg205 VARCHAR(MAX)=NULL,@msg206 VARCHAR(MAX)=NULL,@msg207 VARCHAR(MAX)=NULL,@msg208 VARCHAR(MAX)=NULL,@msg209 VARCHAR(MAX)=NULL
,@msg210 VARCHAR(MAX)=NULL,@msg211 VARCHAR(MAX)=NULL,@msg212 VARCHAR(MAX)=NULL,@msg213 VARCHAR(MAX)=NULL,@msg214 VARCHAR(MAX)=NULL,@msg215 VARCHAR(MAX)=NULL,@msg216 VARCHAR(MAX)=NULL,@msg217 VARCHAR(MAX)=NULL,@msg218 VARCHAR(MAX)=NULL,@msg219 VARCHAR(MAX)=NULL
,@msg220 VARCHAR(MAX)=NULL,@msg221 VARCHAR(MAX)=NULL,@msg222 VARCHAR(MAX)=NULL,@msg223 VARCHAR(MAX)=NULL,@msg224 VARCHAR(MAX)=NULL,@msg225 VARCHAR(MAX)=NULL,@msg226 VARCHAR(MAX)=NULL,@msg227 VARCHAR(MAX)=NULL,@msg228 VARCHAR(MAX)=NULL,@msg229 VARCHAR(MAX)=NULL
,@msg230 VARCHAR(MAX)=NULL,@msg231 VARCHAR(MAX)=NULL,@msg232 VARCHAR(MAX)=NULL,@msg233 VARCHAR(MAX)=NULL,@msg234 VARCHAR(MAX)=NULL,@msg235 VARCHAR(MAX)=NULL,@msg236 VARCHAR(MAX)=NULL,@msg237 VARCHAR(MAX)=NULL,@msg238 VARCHAR(MAX)=NULL,@msg239 VARCHAR(MAX)=NULL
,@msg240 VARCHAR(MAX)=NULL,@msg241 VARCHAR(MAX)=NULL,@msg242 VARCHAR(MAX)=NULL,@msg243 VARCHAR(MAX)=NULL,@msg244 VARCHAR(MAX)=NULL,@msg245 VARCHAR(MAX)=NULL,@msg246 VARCHAR(MAX)=NULL,@msg247 VARCHAR(MAX)=NULL,@msg248 VARCHAR(MAX)=NULL,@msg249 VARCHAR(MAX)=NULL
,@row_count INT = NULL
AS
BEGIN
   DECLARE
       @fnThis          VARCHAR(35) = 'sp_log'
      ,@min_log_level   INT
      ,@lvl_msg         VARCHAR(MAX)
      ,@log_msg         VARCHAR(4000)
      ,@row_count_str   VARCHAR(30) = NULL
   SET NOCOUNT ON
   SET @min_log_level = COALESCE(dbo.fnGetSessionContextAsInt(N'LOG_LEVEL'), 1); -- Default: INFO
   SET @lvl_msg = 
   CASE
      WHEN @level = 0 THEN 'DEBUG'
      WHEN @level = 1 THEN 'INFO '
      WHEN @level = 2 THEN 'NOTE '
      WHEN @level = 3 THEN 'WARN '
      WHEN @level = 4 THEN 'ERROR'
      ELSE '???? '
   END;
   SET @fn= dbo.fnPadRight(@fn, 45);
   IF @row_count IS NOT NULL SET @row_count_str = CONCAT(' rowcount: ', @row_count)
   SET @log_msg = CONCAT
   (
       @msg00 ,@msg01 ,@msg02 ,@msg03, @msg04, @msg05, @msg06 ,@msg07 ,@msg08 ,@msg09 
      ,@msg10 ,@msg11 ,@msg12 ,@msg13, @msg14, @msg15, @msg16 ,@msg17 ,@msg18 ,@msg19
      ,@msg20 ,@msg21 ,@msg22 ,@msg23, @msg24, @msg25, @msg26 ,@msg27 ,@msg28 ,@msg29
      ,@msg30 ,@msg31 ,@msg32 ,@msg33, @msg34, @msg35, @msg36 ,@msg37 ,@msg38 ,@msg39
      ,@msg40 ,@msg41 ,@msg42 ,@msg43, @msg44, @msg45, @msg46 ,@msg47 ,@msg48 ,@msg49
      ,@msg50 ,@msg51 ,@msg52 ,@msg53, @msg54, @msg55, @msg56 ,@msg57 ,@msg58 ,@msg59
      ,@msg60 ,@msg61 ,@msg62 ,@msg63, @msg64, @msg65, @msg66 ,@msg67 ,@msg68 ,@msg69
      ,@msg70 ,@msg71 ,@msg72 ,@msg73, @msg74, @msg75, @msg76 ,@msg77 ,@msg78 ,@msg79
      ,@msg80 ,@msg81 ,@msg82 ,@msg83, @msg84, @msg85, @msg86 ,@msg87 ,@msg88 ,@msg89
      ,@msg90 ,@msg91 ,@msg92 ,@msg93, @msg94, @msg95, @msg96 ,@msg97 ,@msg98 ,@msg99
      ,@msg100,@msg101,@msg102,@msg103,@msg104,@msg105,@msg106,@msg107,@msg108,@msg109 
      ,@msg110,@msg111,@msg112,@msg113,@msg114,@msg115,@msg116,@msg117,@msg118,@msg119 
      ,@msg120,@msg121,@msg122,@msg123,@msg124,@msg125,@msg126,@msg127,@msg128,@msg129 
      ,@msg130,@msg131,@msg132,@msg133,@msg134,@msg135,@msg136,@msg137,@msg138,@msg139 
      ,@msg140,@msg141,@msg142,@msg143,@msg144,@msg145,@msg146,@msg147,@msg148,@msg149 
      ,@msg150,@msg151,@msg152,@msg153,@msg154,@msg155,@msg156,@msg157,@msg158,@msg159 
      ,@msg160,@msg161,@msg162,@msg163,@msg164,@msg165,@msg166,@msg167,@msg168,@msg169 
      ,@msg170,@msg171,@msg172,@msg173,@msg174,@msg175,@msg176,@msg177,@msg178,@msg179 
      ,@msg180,@msg181,@msg182,@msg183,@msg184,@msg185,@msg186,@msg187,@msg188,@msg189 
      ,@msg190,@msg191,@msg192,@msg193,@msg194,@msg195,@msg196,@msg197,@msg198,@msg199 
      ,@msg200,@msg201,@msg202,@msg203,@msg204,@msg205,@msg206,@msg207,@msg208,@msg209 
      ,@msg210,@msg211,@msg212,@msg213,@msg214,@msg215,@msg216,@msg217,@msg218,@msg219 
      ,@msg220,@msg221,@msg222,@msg223,@msg224,@msg225,@msg226,@msg227,@msg228,@msg229 
      ,@msg230,@msg231,@msg232,@msg233,@msg234,@msg235,@msg236,@msg237,@msg238,@msg239 
      ,@msg240,@msg241,@msg242,@msg243,@msg244,@msg245,@msg246,@msg247,@msg248,@msg249 
      ,@row_count_str
   );
   -- Always log to log table
   INSERT INTO AppLog (rtn, msg, [level], row_count)
   VALUES (dbo.fnTrim(@fn), @log_msg, @level, @row_count);
   -- Only display if required
   IF @level >=@min_log_level
   BEGIN
      PRINT CONCAT(@lvl_msg, ' ',@fn, ': ', @log_msg);
   END
END
/*
EXEC tSQLt.RunAll;
SELECT * From AppLog
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================================
-- Author:      Terry Watts
-- Create date: 25-MAR-2020
-- Description: Raises an exception coallescing the error messages
-- with a space between the messages
--
-- Ensures @state is positive
-- if @ex_num < 50000 message and raise to 50K+ @ex_num
-- ================================================================
CREATE PROCEDURE [dbo].[sp_raise_exception]
       @ex_num    INT           = 53000
      ,@msg0      VARCHAR(max)  = NULL
      ,@msg1      VARCHAR(max)  = NULL
      ,@msg2      VARCHAR(max)  = NULL
      ,@msg3      VARCHAR(max)  = NULL
      ,@msg4      VARCHAR(max)  = NULL
      ,@msg5      VARCHAR(max)  = NULL
      ,@msg6      VARCHAR(max)  = NULL
      ,@msg7      VARCHAR(max)  = NULL
      ,@msg8      VARCHAR(max)  = NULL
      ,@msg9      VARCHAR(max)  = NULL
      ,@msg10     VARCHAR(max)  = NULL
      ,@msg11     VARCHAR(max)  = NULL
      ,@msg12     VARCHAR(max)  = NULL
      ,@msg13     VARCHAR(max)  = NULL
      ,@msg14     VARCHAR(max)  = NULL
      ,@msg15     VARCHAR(max)  = NULL
      ,@msg16     VARCHAR(max)  = NULL
      ,@msg17     VARCHAR(max)  = NULL
      ,@msg18     VARCHAR(max)  = NULL
      ,@msg19     VARCHAR(max)  = NULL
      ,@msg20     VARCHAR(max)  = NULL
      ,@fn        VARCHAR(35)   = NULL
AS
BEGIN
   DECLARE
       @fnThis    VARCHAR(35) = 'sp_raise_exception'
      ,@msg       VARCHAR(max)
   ;
   DECLARE @msgs TABLE (txt VARCHAR(MAX));
   INSERT INTO @msgs (txt)
   SELECT TRIM(value)
   FROM (VALUES
       (@msg0), (@msg1), (@msg2), (@msg3), (@msg4),
       (@msg5), (@msg6), (@msg7), (@msg8), (@msg9),
       (@msg10), (@msg11), (@msg12), (@msg13), (@msg14),
       (@msg15), (@msg16), (@msg17), (@msg18), (@msg19), (@msg20)
   ) AS V(value)
   WHERE value IS NOT NULL AND LTRIM(RTRIM(value)) <> '';
   SELECT @msg = STRING_AGG(txt, ' ') FROM @msgs;
   IF @ex_num IS NULL SET @ex_num = 53000; -- default
      EXEC sp_log 4, @fnThis, '000: throwing exception ', @ex_num, ' ', @msg, ' st: 1';
   ------------------------------------------------------------------------------------------------
   -- Validate
   ------------------------------------------------------------------------------------------------
   -- check ex num >= 50000 if not add 50000 to it
   IF @ex_num < 50000
   BEGIN
      SET @ex_num = abs(@ex_num) + 50000;
      EXEC sp_log 3, @fnThis, '010: supplied exception number is too low changing to ', @ex_num;
   END
   ------------------------------------------------------------------------------------------------
   -- Throw the exception
   ------------------------------------------------------------------------------------------------
   ;THROW @ex_num, @msg, 1;
END
/*
EXEC sp_raise_exception 53000, 'test exception msg 1',' msg 2', @state=2, @fn='test_fn'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 21-JAN-2020
-- Description: 1 line check null or mismatch and throw message
--              ASSUMES data types are the same
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_equal]
    @a         SQL_VARIANT
   ,@b         SQL_VARIANT
   ,@msg0      VARCHAR(200)   = NULL
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = 50001
   ,@fn        VARCHAR(35)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis VARCHAR(35) = 'sp_assert_equal'
   ,@aTxt   VARCHAR(100)= CONVERT(VARCHAR(20), @a)
   ,@bTxt   VARCHAR(100)= CONVERT(VARCHAR(20), @b)
   EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';
   IF dbo.fnChkEquals(@a ,@b) <> 0
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, @a:[',@aTxt, '] = @b:[', @bTxt, ']';
      RETURN 0;
   END
   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fnThis, '020: @a:[',@aTxt, '] <> @b:[', @bTxt, '], raising exception';
   EXEC sp_raise_exception
       @msg0   = @msg0 
      ,@msg1   = @msg1 
      ,@msg2   = @msg2 
      ,@msg3   = @msg3 
      ,@msg4   = @msg4 
      ,@msg5   = @msg5 
      ,@msg6   = @msg6 
      ,@msg7   = @msg7 
      ,@msg8   = @msg8 
      ,@msg9   = @msg9 
      ,@msg10  = @msg10
      ,@msg11  = @msg11
      ,@msg12  = @msg12
      ,@msg13  = @msg13
      ,@msg14  = @msg14
      ,@msg15  = @msg15
      ,@msg16  = @msg16
      ,@msg17  = @msg17
      ,@msg18  = @msg18
      ,@msg19  = @msg19
      ,@msg20  = @msg20
      ,@ex_num = @ex_num
      ,@fn     = @fn
END
/*
   EXEC tSQLt.RunAll;
   EXEC sp_assert_equal 1, 1;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 30-MAR-2020
-- Description: assert the given file exists or throws exception @ex_num* 'the file[<@file>] does not exist', @state
-- * if @ex_num default: 53200, state=1
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_file_exists]
    @file      VARCHAR(500)
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = 53200
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE
       @fn_       VARCHAR(35)   = N'ASSERT_FILE_EXISTS'
      ,@msg       VARCHAR(MAX)
   EXEC sp_log @log_level, @fn_, '000: checking file [', @file, '] exists';
   IF dbo.fnFileExists( @file) = 1
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fn, '010: OK,File [',@file,'] exists';
      RETURN 0;
   END
   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   SET @msg = CONCAT('File [',@file,'] does not exist');
   EXEC sp_log 3, @fn, '020:', @msg, ' raising exception';
   EXEC sp_raise_exception
       @ex_num = @ex_num
      ,@msg1   = @msg
      ,@msg2   = @msg1
      ,@msg3   = @msg2 
      ,@msg4   = @msg3 
      ,@msg5   = @msg4 
      ,@msg6   = @msg5 
      ,@msg7   = @msg6 
      ,@msg8   = @msg7 
      ,@msg9   = @msg8 
      ,@msg10  = @msg9 
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@msg20  = @msg19
      ,@fn     = @fn
   ;
END
/*
EXEC sp_assert_file_exists 'non existant file', ' second msg',@fn='test fn', @state=5  -- expect ex: 53200, 'the file [non existant file] does not exist', ' extra detail: none', @state=1, @fn='test fn';
EXEC sp_assert_file_exists 'C:\bin\grep.exe'   -- expect OK
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: asserts that a is greater than b
--              raises an exception if not
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_gtr_than]
       @a         SQL_VARIANT
      ,@b         SQL_VARIANT
      ,@msg       VARCHAR(200)  = NULL
      ,@msg2      VARCHAR(200)  = NULL
      ,@msg3      VARCHAR(200)  = NULL
      ,@msg4      VARCHAR(200)  = NULL
      ,@msg5      VARCHAR(200)  = NULL
      ,@msg6      VARCHAR(200)  = NULL
      ,@msg7      VARCHAR(200)  = NULL
      ,@msg8      VARCHAR(200)  = NULL
      ,@msg9      VARCHAR(200)  = NULL
      ,@msg10     VARCHAR(200)  = NULL
      ,@msg11     VARCHAR(200)  = NULL
      ,@msg12     VARCHAR(200)  = NULL
      ,@msg13     VARCHAR(200)  = NULL
      ,@msg14     VARCHAR(200)  = NULL
      ,@msg15     VARCHAR(200)  = NULL
      ,@msg16     VARCHAR(200)  = NULL
      ,@msg17     VARCHAR(200)  = NULL
      ,@msg18     VARCHAR(200)  = NULL
      ,@msg19     VARCHAR(200)  = NULL
      ,@msg20     VARCHAR(200)  = NULL
      ,@ex_num    INT            = 53502
      ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE
       @fnThis VARCHAR(35) = 'sp_assert_gtr_than'
      ,@aTxt   VARCHAR(100)= CONVERT(VARCHAR(100), @a)
      ,@bTxt   VARCHAR(100)= CONVERT(VARCHAR(100), @b)
   EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';
   -- a>b -> b<a 
   IF dbo.fnIsLessThan(@b ,@a) = 1
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, @a:[',@aTxt, '] IS GTR THN @b:[', @bTxt, ']';
      RETURN 0;
   END
   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fnThis, '020: [',@aTxt, '] IS GTR THN [', @bTxt, '] IS FALSE, raising exception';
   EXEC sp_raise_exception
          @msg1   = @msg
         ,@msg2   = @msg2
         ,@msg3   = @msg3
         ,@msg4   = @msg4
         ,@msg5   = @msg5
         ,@msg6   = @msg6
         ,@msg7   = @msg7
         ,@msg8   = @msg8
         ,@msg9   = @msg9
         ,@msg10  = @msg10
         ,@msg11  = @msg11
         ,@msg12  = @msg12
         ,@msg13  = @msg13
         ,@msg14  = @msg14
         ,@msg15  = @msg15
         ,@msg16  = @msg16
         ,@msg17  = @msg17
         ,@msg18  = @msg18
         ,@msg19  = @msg19
         ,@msg20  = @msg20
         ,@ex_num = @ex_num
         ,@fn     = @fn
   ;
END
/*
EXEC sp_assert_gtr_than 4, 5;
EXEC sp_assert_gtr_than 5, 4;
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_055_sp_assert_gtr_than';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if exp = act
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_equal]
    @a         SQL_VARIANT
   ,@b         SQL_VARIANT
   ,@msg       VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT             = NULL
   ,@fn        VARCHAR(60)    = N'*'
   ,@log_level INT            = 0
AS
BEGIN
DECLARE
    @fnThis    VARCHAR(35) = 'sp_assert_not_equal'
   ,@aTxt      VARCHAR(100)= CONVERT(VARCHAR(20), @a)
   ,@bTxt      VARCHAR(100)= CONVERT(VARCHAR(20), @b)
   ,@std_msg   VARCHAR(200)
    EXEC sp_log @log_level, @fnThis, '000: starting @a:[',@aTxt, '] @b:[', @bTxt, ']';
   -- a<>b MEANS a<b OR b<a -> !(!a<b AND !(b<a))
   IF ((dbo.fnIsLessThan(@a ,@b) = 1) OR (dbo.fnIsLessThan(@b ,@a) = 1))
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
      EXEC sp_log @log_level, @fnThis, '010: OK, [',@aTxt, '] <> [', @bTxt, ']';
      RETURN 0;
   END
   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   --EXEC sp_log 3, @fnThis, '020: [', @aTxt , '] equals [',@bTxt,'], raising exception';
   IF @ex_num IS NULL SET @ex_num = 50003;
   SET @std_msg = CONCAT(@fnThis, ' [', @aTxt , '] equals [',@bTxt,'] ');
   EXEC sp_raise_exception
       @msg1   = @std_msg
      ,@msg2   = @msg
      ,@msg3   = @msg2
      ,@msg4   = @msg3
      ,@msg5   = @msg4
      ,@msg6   = @msg5
      ,@msg7   = @msg6
      ,@msg8   = @msg7
      ,@msg9   = @msg8
      ,@msg10  = @msg9
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@msg20  = @msg19
      ,@ex_num = @ex_num
      ,@fn     = @fn
   ;
END
/*
-- Smoke test 
EXEC sp_assert_not_equal 0, 1, 'Failed: tested routine not qualified'
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_047_sp_assert_not_equal';
EXEC test.sp__crt_tst_rtns '[dbo].[sp_assert_not_equal]'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 27-MAR-2020
-- Description: Raises exception if @a is null or empty
-- =============================================
CREATE PROCEDURE [dbo].[sp_assert_not_null_or_empty]
    @val       VARCHAR(3999)
   ,@msg1      VARCHAR(200)   = NULL
   ,@msg2      VARCHAR(200)   = NULL
   ,@msg3      VARCHAR(200)   = NULL
   ,@msg4      VARCHAR(200)   = NULL
   ,@msg5      VARCHAR(200)   = NULL
   ,@msg6      VARCHAR(200)   = NULL
   ,@msg7      VARCHAR(200)   = NULL
   ,@msg8      VARCHAR(200)   = NULL
   ,@msg9      VARCHAR(200)   = NULL
   ,@msg10     VARCHAR(200)   = NULL
   ,@msg11     VARCHAR(200)   = NULL
   ,@msg12     VARCHAR(200)   = NULL
   ,@msg13     VARCHAR(200)   = NULL
   ,@msg14     VARCHAR(200)   = NULL
   ,@msg15     VARCHAR(200)   = NULL
   ,@msg16     VARCHAR(200)   = NULL
   ,@msg17     VARCHAR(200)   = NULL
   ,@msg18     VARCHAR(200)   = NULL
   ,@msg19     VARCHAR(200)   = NULL
   ,@msg20     VARCHAR(200)   = NULL
   ,@ex_num    INT            = NULL
   ,@fn        VARCHAR(35)    = '*'
   ,@log_level INT            = 0
AS
BEGIN
   DECLARE 
       @fnThis    VARCHAR(35) = N'sp_assert_not_null_or_empty'
      ,@valTxt    VARCHAR(20)= @val
   ;
   EXEC sp_log @log_level, @fnThis, '000: starting,' ,@msg1,': @val:[',@val,']';
   IF dbo.fnLen(@val) > 0
   BEGIN
      ----------------------------------------------------
      -- ASSERTION OK
      ----------------------------------------------------
       IF dbo.fnLen(@valTxt) < 20 SET @valTxt= CONCAT(@valTxt, '   ');
      EXEC sp_log @log_level, @fnThis, '010: OK, ASSERTION: val: [',@valTxt, '] IS NOT NULL';
      RETURN 0;
   END
   ----------------------------------------------------
   -- ASSERTION ERROR
   ----------------------------------------------------
   EXEC sp_log 3, @fn, '020: @val IS NULL OR EMPTY, raising exception';
   IF @ex_num IS NULL SET @ex_num = 50005;
   DECLARE @msg0 VARCHAR(20)= 'val is NULL or empty'
   EXEC sp_raise_exception
       @ex_num = @ex_num
      ,@msg1   = @msg0
      ,@msg2   = @msg1
      ,@msg3   = @msg2
      ,@msg4   = @msg3
      ,@msg5   = @msg4
      ,@msg6   = @msg5
      ,@msg7   = @msg6
      ,@msg8   = @msg7
      ,@msg9   = @msg8
      ,@msg10  = @msg9
      ,@msg11  = @msg10
      ,@msg12  = @msg11
      ,@msg13  = @msg12
      ,@msg14  = @msg13
      ,@msg15  = @msg14
      ,@msg16  = @msg15
      ,@msg17  = @msg16
      ,@msg18  = @msg17
      ,@msg19  = @msg18
      ,@msg20  = @msg19
      ,@fn     = @fn
      ;
END
/*
EXEC tSQLt.Run 'test.test_049_sp_assert_not_null_or_empty';
EXEC tSQLt.RunAll;
EXEC sp_assert_not_null_or_empty NULL
EXEC sp_assert_not_null_or_empty ''
EXEC sp_assert_not_null_or_empty 'Fred'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================================
-- Author:      Terry Watts
-- Create Date: 14-JUN-2025
-- Description: assert the table exists
-- Parameters:
--    @table to check if existscan be qualified
--    @exp_exists if 1 asserts @table exists else asserts @table does not exist
-- Returns      1 if exists
-- =============================================================================
CREATE PROCEDURE [dbo].[sp_assert_tbl_exists]
    @table_nm        VARCHAR(100)
   ,@exp_exists      BIT         = 1
   ,@ex_num          INT         = 50001
AS
BEGIN
   DECLARE
    @fn              VARCHAR(35)   = N'sp_assert_tbl_exists'
   ,@sql             NVARCHAR(MAX)
   ,@act_exists      BIT
   ,@schema_nm       VARCHAR(50)
   ,@msg             VARCHAR(100)
   ,@nm_has_spcs     BIT
   ;
   SET NOCOUNT ON;
   SET @act_exists =dbo.fnTableExists(@table_nm);
   SET @nm_has_spcs = CHARINDEX(' ', @table_nm);
   IF @ex_num IS NULL SET @ex_num = 50001;
   IF @act_exists = @exp_exists
   BEGIN
      SET @msg = CONCAT('table ', iif(@nm_has_spcs=1, '[', ''), @table_nm, iif(@nm_has_spcs=1, ']', ''), iif(@exp_exists = 1, ' exists ', 'does not exist'), ' as expected');
      EXEC sp_log 1, @fn, @msg;
   END
   ELSE
   BEGIN -- failed test
      SET @msg = CONCAT('table ', @table_nm, iif(@exp_exists = 1, ' does not exist but should', 'exists but should not'));
      EXEC sp_raise_exception @ex_num, @msg, @fn=@fn;
   END
   RETURN 1;
END
/*
EXEC test.test_070_sp_assert_tbl_exists;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================================
-- Author:      Terry Watts
-- Create Date: 06-AUG-2023
-- Description: Checks that the given table is populated    or not
-- Normal mode: this checks to see if the table has atleast 1 row
--
-- However it can be use to Checks that the given table is NOT populated
-- by setting @exp_cnt to 0
--
-- Called by sp_chk_tbl_not_pop
-- ======================================================================
CREATE PROCEDURE [dbo].[sp_assert_tbl_pop]
    @table           VARCHAR(60)
   ,@msg             VARCHAR(MAX)   = NULL
   ,@display_msgs    BIT            = 0
   ,@exp_cnt         INT            = NULL
   ,@ex_num          INT            = 56687
   ,@ex_msg          VARCHAR(500)   = NULL
   ,@fn              VARCHAR(35)    = N'*'
   ,@log_level       INT            = 0
   ,@display_row_cnt BIT            = 1
AS
BEGIN
   DECLARE 
    @fnThis          VARCHAR(35)   = N'sp_assert_tbl_pop'
   ,@sql             NVARCHAR(MAX)
   ,@act_cnt         INT           = -1
   ,@schema_nm       VARCHAR(50)
   ;
   SET NOCOUNT ON;
   SELECT 
       @table     = rtn_nm 
      ,@schema_nm = schema_nm
   FROM dbo.fnSplitQualifiedName(@table)
   ;
   SET @sql = CONCAT('SELECT @act_cnt = COUNT(*) FROM [', @schema_nm, '].[', @table, ']');
   EXEC sp_executesql @sql, N'@act_cnt INT OUT', @act_cnt OUT
   IF @display_row_cnt = 1
   BEGIN
      EXEC sp_log 1, @fnThis, @msg, 'table:[', @table, '] has ', @act_cnt, ' rows';
   END
   IF @exp_cnt IS NOT null
   BEGIN
      IF @exp_cnt <> @act_cnt
      BEGIN
         IF @ex_msg IS NULL
            SET @ex_msg = CONCAT('Table: ', @table, ' row count: exp ',@exp_cnt,'  act:', @act_cnt);
         EXEC sp_log 4, @fnThis ,'040: @exp_cnt (', @exp_cnt, ')<> @act_cnt (', @act_cnt, ') raising exception: ',@ex_msg;
         EXEC sp_raise_exception @ex_num, @ex_msg, 1, @fn=@fn;
      END
   END
   ELSE
   BEGIN -- Check at least 1 row
      IF @act_cnt = 0
      BEGIN
         IF @ex_msg IS NULL
            SET @ex_msg = CONCAT('Table: ', @table, ' does not have any rows');
         EXEC sp_log 4, '070: table ',@table,' has no rows: ', @ex_msg;
         THROW @ex_num, @ex_msg, 1;
      END
   END
END
/*
   -- This should not create an exception as dummytable has rows
   EXEC dbo.sp_assert_tbl_po 'use'
   EXEC dbo.sp_assert_tbl_po 'dummytable'
   
   -- This should create the following exception:
   -- Msg 56687, Level 16, State 1, Procedure dbo.sp_assert_tbl_po, Line 27 [Batch Start Line 37]
   -- Table: [AppLog] does not have any rows
    
   EXEC dbo.sp_assert_tbl_po 'AppLog'
   IF EXISTS (SELECT 1 FROM [dummytable]) PRINT '1' ELSE PRINT '0'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ========================================================================================================
-- Author:      Terry Watts
-- Create date: 28-MAR-2020
-- Description: standard error handling:
--              get the exception message, log messages
--              clear the log cache first
-- NB: this does not throw
--
-- CHANGES
-- 231221: added clear the log cache first
-- 240315: added ex num, ex msg as optional out parmeters
-- 241204: it is possible that ERROR_MESSAGE() or ERROR_NUMBER() are throwing exceptions 
--        -this can happen inside tranactions when low level errors like select * from non existant table
-- 241221: error proc and error line do not always work - for example when executing SQL statements that
--         return a low error number like the following: 207:Invalid column name    
-- ========================================================================================================
CREATE PROCEDURE [dbo].[sp_log_exception]
       @fn        VARCHAR(35)
      ,@msg01     VARCHAR(4000) = NULL
      ,@msg02     VARCHAR(1000) = NULL
      ,@msg03     VARCHAR(1000) = NULL
      ,@msg04     VARCHAR(1000) = NULL
      ,@msg05     VARCHAR(1000) = NULL
      ,@msg06     VARCHAR(1000) = NULL
      ,@msg07     VARCHAR(1000) = NULL
      ,@msg08     VARCHAR(1000) = NULL
      ,@msg09     VARCHAR(1000) = NULL
      ,@msg10     VARCHAR(1000) = NULL
      ,@msg11     VARCHAR(1000) = NULL
      ,@msg12     VARCHAR(1000) = NULL
      ,@msg13     VARCHAR(1000) = NULL
      ,@msg14     VARCHAR(1000) = NULL
      ,@msg15     VARCHAR(1000) = NULL
      ,@msg16     VARCHAR(1000) = NULL
      ,@msg17     VARCHAR(1000) = NULL
      ,@msg18     VARCHAR(1000) = NULL
      ,@msg19     VARCHAR(1000) = NULL
      ,@ex_num    INT            = NULL OUT
      ,@ex_msg    VARCHAR(500)  = NULL OUT
      ,@ex_proc   VARCHAR(80)   = NULL OUT
      ,@ex_line   VARCHAR(20)   = NULL OUT
AS
BEGIN
   DECLARE 
       @fnThis    VARCHAR(35) = 'sp_log_exception'
      ,@NL        VARCHAR(2)  =  NCHAR(13) + NCHAR(10)
      ,@msg       VARCHAR(500)
      ,@fnHdr     VARCHAR(100)
      ,@isTrans   BIT = 0
      ,@line      VARCHAR(4000)
   SET @ex_num = -1; -- unknown
   SET @msg    = 'UNKNOWN MESSAGE';
   --EXEC sp_log 4, @fnThis, '510: starting';
   SELECT
       @ex_num = ERROR_NUMBER()
      ,@ex_proc= ERROR_PROCEDURE()
      ,@ex_line= CAST(ERROR_LINE() AS VARCHAR(20))
      ,@ex_msg = ERROR_MESSAGE();
   SET @fnHdr = CONCAT(@ex_proc, '(',@ex_line,'): ')
   BEGIN TRY
      SET @msg =
      CONCAT
      (
         '500: caught exception ', @ex_num, ': ', @ex_msg, ' ', 
          @msg01
         ,iif(@msg02 IS NOT NULL, CONCAT(' ', @msg02 ), '')
         ,iif(@msg03 IS NOT NULL, CONCAT(' ', @msg03 ), '')
         ,iif(@msg04 IS NOT NULL, CONCAT(' ', @msg04 ), '')
         ,iif(@msg05 IS NOT NULL, CONCAT(' ', @msg05 ), '')
         ,iif(@msg06 IS NOT NULL, CONCAT(' ', @msg06 ), '')
         ,iif(@msg07 IS NOT NULL, CONCAT(' ', @msg07 ), '')
         ,iif(@msg08 IS NOT NULL, CONCAT(' ', @msg08 ), '')
         ,iif(@msg09 IS NOT NULL, CONCAT(' ', @msg09 ), '')
         ,iif(@msg10 IS NOT NULL, CONCAT(' ', @msg10 ), '')
         ,iif(@msg11 IS NOT NULL, CONCAT(' ', @msg11 ), '')
         ,iif(@msg12 IS NOT NULL, CONCAT(' ', @msg12 ), '')
         ,iif(@msg13 IS NOT NULL, CONCAT(' ', @msg13 ), '')
         ,iif(@msg14 IS NOT NULL, CONCAT(' ', @msg14 ), '')
         ,iif(@msg15 IS NOT NULL, CONCAT(' ', @msg15 ), '')
         ,iif(@msg16 IS NOT NULL, CONCAT(' ', @msg16 ), '')
         ,iif(@msg17 IS NOT NULL, CONCAT(' ', @msg17 ), '')
         ,iif(@msg18 IS NOT NULL, CONCAT(' ', @msg18 ), '')
         ,iif(@msg19 IS NOT NULL, CONCAT(' ', @msg19 ), '')
      );
      SET @line = REPLICATE('*', dbo.fnMin(300, dbo.fnLen(@msg)+46));
      PRINT CONCAT(@nl, @line);
      EXEC sp_log 4, @fnThis, @fnHdr, @msg;
      PRINT CONCAT(@line, @nl);
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fnThis, '590: failed. exception was: ', @ex_num, ': ', @ex_msg;
      SET @ex_num = ERROR_NUMBER();
      SET @ex_msg = ERROR_MESSAGE();
      EXEC sp_log 4, @fnThis,  '580: sp_log failed, exception: ',@ex_num, ': @ex_msg';
      SET @ex_msg ='*** system error: failed to get error msg ***';
   END CATCH
END
GO

GO
CREATE TYPE [dbo].[ChkFldsNotNullDataType] AS TABLE(
	[ordinal] [int] NOT NULL,
	[col] [varchar](120) NOT NULL,
	[sql] [varchar](4000) NOT NULL
)
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--================================================================================================
-- Author:        Terry Watts
-- Create date:   15-Nov-2024
-- Description:   check there are no NULL entries supplied columns
--
-- PRECONDITIONS: none
--
-- POSTCONDITIONS:
-- POST 01: returns 0 and no inccurrences in any of the specified fields in the specified table 
-- OR throws exception 56321, msg: 'mandatory field:['<@table?'].'<field> has Null value
--================================================================================================
CREATE PROCEDURE [dbo].[sp_chk_flds_not_null]
    @table            VARCHAR(60)
   ,@non_null_flds    VARCHAR(MAX) = NULL
   ,@display_results  BIT           = 0
   ,@msg              VARCHAR(100) = ''
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = N'sp_chk_flds_not_null'
   ,@max_len_fld  INT
   ,@col          VARCHAR(32)
--   ,@msg          VARCHAR(200)
   ,@sql          NVARCHAR(MAX)
   ,@ndx          INT = 1
   ,@end          INT
   ,@nl           NCHAR(2) = NCHAR(13) + NCHAR(10)
   ,@flds         ChkFldsNotNullDataType
    ;
   EXEC sp_log 1, @fn, '000: starting:
table           :[', @table          , ']
non_null_flds   :[', @non_null_flds  , ']
display_results :[', @display_results, ']'
   ;
   IF @non_null_flds IS NULL
      RETURN;
   BEGIN TRY
      SET @sql = CONCAT('SELECT @max_len_fld = MAX(dbo.fnLen(column_name)) FROM list_table_columns_vw WHERE table_name = ''', @table, ''';');
      EXEC sp_log 0, @fn, '010: getting max field len: @sql:', @sql;
      EXEC sp_executesql @sql, N'@max_len_fld INT OUT', @max_len_fld OUT;
      EXEC sp_log 1, @fn, '020: @max_len_fld: ', @max_len_fld;
      ----------------------------------------------------------------
      -- Create script to run non null chks on a set of fields
      ----------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: Creating script to run non null chks on a set of fields';
      INSERT INTO @flds (ordinal, col, sql) 
      SELECT
          ordinal
         ,value
         ,CONCAT
         (
            'IF EXISTS (SELECT 1 FROM ['
            , @table,'] WHERE ',CONCAT('[',value,']'), ' IS NULL) EXEC sp_raise_exception 56321, ''mandatory field:['
            , @table,'].',CONCAT('[',value,'] has Null value'';')
         ) as sql
         FROM
         (
            SELECT ordinal, TRIM(dbo.fnDeSquareBracket(value)) as value FROM string_split( @non_null_flds, ',', 1)
         ) X
      IF @display_results = 1 SELECT * FROM @flds;
      --THROW 51000, 'debug',20;
      ----------------------------------------------------------------
      -- Execute script: run non null chks on each required field
      ----------------------------------------------------------------
      SELECT @end = COUNT(*) FROM @flds;
      WHILE @ndx < = @end
      BEGIN
         SELECT 
             @sql = sql
            ,@col = col
         FROM @flds
         WHERE ordinal = @ndx;
         --SET @msg = CONCAT('040: checking col: ', dbo.fnPadRight( CONCAT( '[', @col, ']'), @max_len_fld +1), ' has no NULL values');
         --SET @msg = CONCAT('050: check sql: ', @sql);
         --EXEC sp_log 1, @fn, @msg;
         EXEC (@sql);
         SET @ndx = @ndx + 1
      END
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, 'table: ', @table, ' col ', @col,'has a null value. ', @msg;
      SELECT * FROM @flds;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, '999: there are no null values in the checked columns';
END
/*
EXEC tSQLt.Run 'test.test_030_sp_chk_flds_not_null';
SELECT * FROM @flds
*/
GO

GO
EXEC sys.sp_addextendedproperty @name=N'microsoft_database_tools_support', @value=1 , @level0type=N'SCHEMA',@level0name=N'dbo', @level1type=N'PROCEDURE',@level1name=N'sp_creatediagram'
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[FieldInfo](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[nm] [varchar](50) NULL,
	[ty] [varchar](15) NULL,
PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 17-JUN-2025
-- Description: infers the field types froma staging table
--    based on its data
--    pops the FieldInfo table
--
-- Design:      EA: Dorsu Model.Use Case Model.Create and populate a table from a data file.Infer the field types from the staged data
-- Tests:       test_074_sp_infer_field_types
--
-- Preconditions: PRE01: table must exist or exception 50001 'Table '<@q_table_nm> does not exist
-- Postconditions: POST01: pops the FieldInfo table
-- =============================================
CREATE PROCEDURE [dbo].[sp_infer_field_types]
   @q_table_nm VARCHAR(100)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn           VARCHAR(35)   = N'sp_infer_field_types'
      ,@sql          NVARCHAR(4000)
      ,@schema       VARCHAR(40)
      ,@table_nm     VARCHAR(60)
      ,@fld_ty       VARCHAR(25)
      ,@fld_id       INT
      ,@fld_nm       VARCHAR(50)
      ,@len          INT
  ;
   EXEC sp_log 1, @fn, '000: starting:
@q_table_nm:[',@q_table_nm,']
';
   BEGIN TRY
      -- Preconditions: PRE01: table must exist or exception 60001 'Table '<@q_table_nm> does not exist
      exec sp_assert_tbl_exists @q_table_nm;
      SELECT
          @schema = a
         ,@table_nm = b
      FROM dbo.fnSplitPair2(@q_table_nm, '.');
      IF @table_nm IS NULL
      BEGIN
         EXEC sp_log 1, @fn, '005: schema not specified - defaulting to dbo';
         SELECT
             @table_nm = @schema
            ,@schema   = 'dbo'
         ;
      END
      EXEC sp_log 1, @fn, '010: starting:
   @schema:  [',@schema,']
   @table_nm:[',@table_nm,']
   ';
      -- Clear the field info table
      TRUNCATE TABLE FieldInfo;
      -- Get the field info for the table
      SET @sql = CONCAT('INSERT INTO FieldInfo(nm) SELECT COLUMN_NAME
   FROM INFORMATION_SCHEMA.COLUMNS
   WHERE TABLE_NAME = '''  , @table_nm, '''
     AND TABLE_SCHEMA = ''', @schema, ''';'
     );
      EXEC sp_log 1, @fn, '020: @sql:
', @sql;
      EXEC (@sql);
      EXEC sp_log 1, @fn, '030:';
      --SELECT * FROM FieldInfo;
      -- For each field in the staged data
      DECLARE _cursor CURSOR FOR SELECT id, nm  FROM FieldInfo;
      OPEN _cursor;
      FETCH NEXT FROM _cursor INTO @fld_id, @fld_nm;
      EXEC sp_log 1, @fn, '035:';
      -- For each fields
      WHILE @@FETCH_STATUS = 0
      BEGIN
         EXEC sp_log 1, @fn, '040: @fld_id: ',@fld_id, ' @fld_nm[',@fld_nm,']';
         -- For each field type we are interested in:
         -- Chk if all data item in that field are:
         WHILE 1=1
         BEGIN
            SET @fld_ty = NULL;
            EXEC sp_log 1, @fn, '050: trying BIT';
            -- Bit?	Set field type = bit
            SET @sql = dbo.fnCrtFldNotNullSql(@q_table_nm, @fld_nm, 'BIT');
            EXEC sp_log 1, @fn, '055: @sql: ',
@sql;
            EXEC sp_executesql @sql, N'@fld_ty VARCHAR(15) OUT', @fld_ty OUT;
            IF @fld_ty IS NOT NULL BREAK;
            -- Int?	Set field type = int
            EXEC sp_log 1, @fn, '060: trying INT';
            SET @sql = dbo.fnCrtFldNotNullSql(@q_table_nm, @fld_nm, 'INT');
            EXEC sp_log 1, @fn, '065: @sql: ',
@sql;
            EXEC sp_executesql @sql, N'@fld_ty VARCHAR(15) OUT', @fld_ty OUT;
            IF @fld_ty IS NOT NULL BREAK;
            EXEC sp_log 1, @fn, '070: trying REAL';
            SET @sql = dbo.fnCrtFldNotNullSql(@q_table_nm, @fld_nm, 'REAL');
            EXEC sp_log 1, @fn, '075: @sql: ',
@sql;
            EXEC sp_executesql @sql, N'@fld_ty VARCHAR(15) OUT', @fld_ty OUT;
            IF @fld_ty IS NOT NULL BREAK;
         -- Floating point?	Set field type = double
            EXEC sp_log 1, @fn, '080: trying FLOAT';
            SET @sql = dbo.fnCrtFldNotNullSql(@q_table_nm, @fld_nm, 'FLOAT');
            EXEC sp_log 1, @fn, '085: @sql: ',
@sql;
            EXEC sp_executesql @sql, N'@fld_ty VARCHAR(15) OUT', @fld_ty OUT;
            IF @fld_ty IS NOT NULL BREAK;
            -- GUID ?	Set field type = GUID
            EXEC sp_log 1, @fn, '090: trying GUID';
            SET @sql = dbo.fnCrtFldNotNullSql(@q_table_nm, @fld_nm, 'UNIQUEIDENTIFIER');
            EXEC sp_log 1, @fn, '095: @sql: ',
@sql;
            EXEC sp_executesql @sql, N'@fld_ty VARCHAR(15) OUT', @fld_ty OUT;
            IF @fld_ty IS NOT NULL BREAK;
            -- Assume text field
            EXEC sp_log 1, @fn, '100: Assume text field';
            -- Set len = max len of the field
            SET @sql =
            CONCAT
            (
               'SELECT @len = MAX(dbo.fnLen(',@fld_nm,')) FROM 
            ', @q_table_nm, ';'
            )
            EXEC sp_log 1, @fn, '110:sql:
',@sql;
            EXEC sp_executesql @sql, N'@len INT OUT', @len OUT;
            EXEC sp_log 1, @fn, '120:@len:
',@len;
            SET @fld_ty = CONCAT('VARCHAR(', @len, ')')
            BREAK;
         END -- for each wanted field ty
         EXEC sp_log 1, @fn, '110: field ty is ',@fld_ty;
         -- Add the field info to the FieldInfo table
         UPDATE FieldInfo SET ty = @fld_ty WHERE id = @fld_id;
         FETCH NEXT FROM _cursor INTO @fld_id, @fld_nm;
      END -- outer while - for each row in FieldInfo
      CLOSE _cursor;
      DEALLOCATE _cursor;
      EXEC sp_log 1, @fn, '200: checking postconditions';
      -- Postconditions: POST01: pops the FieldInfo table
      EXEC sp_log 1, @fn, '210: checking POST01: pops the FieldInfo table';
      EXEC sp_assert_tbl_pop 'FieldInfo';
      EXEC sp_log 1, @fn, '299: completed processing loop';
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      IF CURSOR_STATUS('global','_cursor')>=-1 
      BEGIN
         CLOSE _cursor;
         DEALLOCATE _cursor;
      END
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, '999: leaving ok';
END
/*
EXEC test.test_074_sp_infer_field_types;
SELECT * FROM FileActivityStaging
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==============================================================
-- Author:      Terry Watts
-- Create date: 16-JUN-2025
-- Description: Drops a table if it exists
-- Design:      
-- Tests:       
--
-- PRECONDITIONS:
-- PRE 01 @tbl_nm must be specified NOT NULL or EMPTY Checked
--
-- POSTCONDITIONS:
-- POST01: table does not exist
-- ==============================================================
CREATE PROCEDURE [dbo].[sp_drop_table]
    @q_table_nm        VARCHAR(80)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
     @fn          VARCHAR(35) = 'sp_drop_table'
    ,@sql         NVARCHAR(MAX)
    ,@ret         INT
   ;
   BEGIN TRY
      EXEC sp_log 1, @fn, '000 dropping table [', @q_table_nm, ']';
      -----------------------------------------------------------------
      -- Validation
      -----------------------------------------------------------------
      -- PRE 01 @fk_nm NOT NULL or EMPTY  Checked
      EXEC sp_log 1, @fn, '010 validating checked preconditions';
      SET @q_table_nm = dbo.fnDeLimitIdentifier(@q_table_nm);
      EXEC sp_assert_not_null_or_empty @q_table_nm, '@q_table_nm must be specified', @fn=@fn;
      -- delimit [ brkt name if necessary
      SET @q_table_nm = dbo.fnDeLimitIdentifier(@q_table_nm);
      -- chk if the table existed initially
      SET @ret = dbo.fnTableExists(@q_table_nm);
      SET @sql = CONCAT('DROP table if exists ', @q_table_nm);
      EXEC sp_log 1, @fn, '030 executing the drop Table SQL:
',@sql;
      EXEC (@sql);
      EXEC sp_log 1, @fn, '040 checking postconditions'
      ---------------------------------------------------------
      --- ASSERTION: POST01: table does not exist
      ---------------------------------------------------------
      EXEC sp_assert_tbl_exists @q_table_nm, 0;
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, '999: successfully dropped table ', @q_table_nm;
   return @ret; -- table did exist
END
/*
EXEC test.sp__crt_tst_rtns '[dbo].[sp_drop_table]';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===========================================================
-- Author:      Terry watts
-- Create date: 20-SEP-2024
-- Description: Deletes the file on disk
--
-- Postconditions:
-- POST 01 raise exception if failed to delete the file
-- ===========================================================
CREATE PROCEDURE [dbo].[sp_delete_file]
    @file_path    VARCHAR(500)   = NULL
   ,@chk_exists   BIT = 0 -- chk exists in the first place
   ,@fn           VARCHAR(35)    = N'*'
AS
BEGIN
   DECLARE
    @fnThis       VARCHAR(35)   = N'SP DELETE_FILE'
   ,@cmd          VARCHAR(MAX)
   ,@msg          VARCHAR(1000)
   ;
   EXEC sp_log 1, @fnThis,'000: starting, deleting file:[',@file_path,']';
   DROP TABLE IF EXISTS #tmp;
   CREATE table #tmp (id INT identity(1,1), [output] NVARCHAR(4000))
   IF (dbo.fnFileExists(@file_path) <> 0)
   BEGIN
      --SET @cmd = CONCAT('INSERT INTO #tmp  EXEC xp_cmdshell ''del "', @file_path, '"'' ,NO_OUTPUT');
      SET @cmd = CONCAT('INSERT INTO #tmp  EXEC xp_cmdshell '' del "', @file_path, '"''');
      --PRINT @cmd;
      EXEC sp_log 1, @fnThis,'010: sql:[',@cmd,']';
      EXEC (@cmd);
      --IF EXISTS (SELECT TOP 2 1 FROM #tmp) SELECT * FROM #tmp;
   END
   ELSE -- file does not exist
      IF (@chk_exists = 1) -- POST 01 raise exception if failed to delete the file
         EXEC sp_raise_exception 58147, ' 020: file [',@file_path,'] does not exist but chk_exists specified', @fn=@fnThis;
   IF dbo.fnFileExists(@file_path) <> 0
   BEGIN
      IF EXISTS (SELECT TOP 2 1 FROM #tmp)
         SELECT @msg = [output] FROM #tmp where id = 1;
      EXEC sp_raise_exception 63500, '030: failed to delete file [', @file_path, '], reason: ',@msg, @fn=@fnThis;
   END
   EXEC sp_log 0, @fnThis,'999: leaving';
END
/*
EXEC sp_delete_file 'D:\Logs\a.txt';
EXEC sp_delete_file 'non exist file';
EXEC sp_delete_file 'D:\Logs\Farming.log';
EXEC xp_cmdshell 'del "D:\Logs\Farming.log"'
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================================================================
-- Author:      Terry Watts
-- Create date: 20-OCT-2024
-- Description: Imports a txt file into @table
-- Returns the count of rows imported
-- Design: EA?
-- Responsibilities:
-- R00: delete the log files beefore importing if they exist
-- R01: Import the table from the tsv file
-- R02: Remove double quotes
-- R03: Trim leading/trailing whitespace
-- R04: Remove in-field line feeds
-- R05: check the list of @non_null_flds fields do not have any nulls - if @non_null_flds supplied
--
-- Tests: test_037_sp_import_txt_file
--
-- Preconditions:
-- PRE01: File must be specified: chkd
-- PRE02: Filpath must exist : chkd
--
-- Postconditions:
-- POST01 ret: the count of rows imported
--
-- Changes:
-- 20-OCT-2024: increased @spreadsheet_file parameter len from 60 to 500 as the file path was being truncated
-- 31-OCT-2024: cleans each imported text field for double quotes and leading/trailing white space
-- 05-NOV-2024: optionally display imported table: sometimes we need to do more fixup before data is ready
--              so when this is the case then dont display the table here, but do post import fixup in the 
--              calling sp first and then display the table
-- 11-NOV-2024: added an optional view to control field mapping
-- 06-APR-2025  @table may be qualified with the schema - sort out bracketing
-- =============================================================================================================
CREATE PROCEDURE [dbo].[sp_import_txt_file]
    @table            VARCHAR(60)
   ,@file             VARCHAR(500)
   ,@folder           VARCHAR(600)  = NULL
   ,@field_terminator VARCHAR(4)    = NULL -- tab 0x09
   ,@row_terminator   VARCHAR(10)   = NULL -- '0x0d0a'
   ,@codepage         INT           = 65001 -- Claude: Note that if your text file has a BOM (Byte Order Mark), SQL Server should automatically detect it when using codepage 65001.
   ,@first_row        INT           = 2
   ,@last_row         INT           = NULL
   ,@clr_first        BIT           = 1
   ,@view             VARCHAR(120)  = NULL
   ,@format_file      VARCHAR(500)  = NULL
   ,@expect_rows      BIT           = 1
   ,@exp_row_cnt      INT           = NULL
   ,@non_null_flds    VARCHAR(1000) = NULL
   ,@display_table    BIT           = 0
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)       = N'sp_import_txt_file'
   ,@cmd                NVARCHAR(MAX)
   ,@sql                VARCHAR(MAX)
   ,@CR                 CHAR(1)           = CHAR(13)
   ,@LF                 CHAR(2)           = CHAR(10)
   ,@NL                 CHAR(2)           = CHAR(13)+CHAR(10)
   ,@line_feed          CHAR(1)           = CHAR(10)
   ,@bkslsh             CHAR(1)           = CHAR(92)
   ,@tab                CHAR(1)           = CHAR(9)
   ,@max_len_fld        INT
   ,@del_file           VARCHAR(1000)
   ,@error_file         VARCHAR(1000)
   ,@ndx                INT = 1
   ,@end                INT
   ,@line               VARCHAR(128) = REPLICATE('-', 100)
   ,@file_path          VARCHAR(600)
   ,@row_cnt            INT
   ,@schema_nm          VARCHAR(28)
   ,@table_nm           VARCHAR(40)
   ,@table_nm_no_brkts  VARCHAR(40)
   ,@ex_num             INT
   ,@ex_msg             INT
   ;
   --SET @row_terminator_str = iif(@row_terminator='0x0d0a', '0x0d0a',@row_terminator);
   EXEC sp_log 1, @fn, '000: starting:
table           :[',@table             ,']
file            :[',@file              ,']
folder          :[',@folder            ,']
row_terminator  :[',@row_terminator    ,']
field_terminator:[',@field_terminator  ,']
first_row       :[',@first_row         ,']
last_row        :[',@last_row          ,']
clr_first       :[',@clr_first         ,']
view            :[',@view              ,']
format_file     :[',@format_file       ,']
expect_rows     :[',@expect_rows       ,']
exp_row_cnt     :[',@exp_row_cnt       ,']
non_null_flds   :[',@non_null_flds     ,']
display_table   :[',@display_table     ,']'
;
   BEGIN TRY
      ---------------------------------------------------
      -- Set defaults
      ---------------------------------------------------
      IF @field_terminator IS NULL SET @field_terminator = @tab;
      IF @field_terminator IN (0x09, '0x09', '\t') SET @field_terminator = @tab;
      IF @field_terminator NOT IN ( @tab,',',@CR, @LF, @NL)
         EXEC sp_raise_exception 53051, @fn, '005: error: field terminator must be one of comma, tab, NL';
      IF @row_terminator   IS NULL OR @row_terminator='' SET @row_terminator = @nl;
      ---------------------------------------------------
      -- Validate parameters
      ---------------------------------------------------
      EXEC sp_log 1, @fn, '010: Validate parameters';
      -- PRE01: File must be specified
      EXEC sp_assert_not_null_or_empty @file, 50001, 'File must be specified';
      ---------------------------------------------------
      -- Set defaults
      ---------------------------------------------------
      EXEC sp_log 1, @fn, '020: Set defaults';
      IF @codepage IS NULL SET @codepage = 1252;
      SET @file_path = iif( @folder IS NOT NULL,  CONCAT(@folder, @bkslsh, @file), @file);
      -- sort out double \\
      SET @file_path = REPLACE(@file_path, @bkslsh+@bkslsh, @bkslsh);
      -- ASSERTION 
      -- 06-APR-2025  @table may be qualified with the schema - sort out bracketing
      SET @ndx = CHARINDEX('.', @table);
      IF @ndx>0
      BEGIN
         SELECT
             @schema_nm = schema_nm
            ,@table_nm  = rtn_nm
         FROM dbo.fnSplitQualifiedName(@table);
         SET @table = CONCAT('[',@schema_nm,'].[',@table_nm, ']');
      END
      ELSE
      BEGIN
         SET @table = CONCAT('[',@table, ']');
      END
      SET @table_nm_no_brkts = REPLACE(REPLACE(@table, '[', ''),']', '');
      EXEC sp_log 1, @fn, '030: table:',@table, ' @table_nm_no_brkts: ', @table_nm_no_brkts;
      ---------------------------------------------------
      -- Validate inputs
      ---------------------------------------------------
      EXEC sp_log 1, @fn, '040: validating inputs, @file_path: [',@file_path,']';
      -- PRE02: Filpath must exist : chkd
      EXEC sp_assert_file_exists @file_path
      -------------------------------------------------------------
      -- ASSERTION: @table is now like [table] or [schema].[table]
      -------------------------------------------------------------
      IF @table IS NULL OR @table =''
         EXEC sp_raise_exception 53050, @fn, '050: error: table must be specified';
      IF @first_row IS NULL OR @first_row < 1
         SET @first_row = 2;
      IF @last_row IS NULL OR @last_row < 1
         SET @last_row = 1000000;
      -- View is optional - defaults to the table stru
      IF @view IS NULL
         SET @view = @table;
      IF @clr_first = 1
      BEGIN
         SET @cmd = CONCAT('TRUNCATE TABLE ', @table,';');
         EXEC sp_log 1, @fn, '060: clearing table first: EXEC SQL:',@NL, @cmd;
         EXEC (@cmd);
      END
      ----------------------------------------------------------------------------------
      -- R00: delete the log files before importing if they exist
      ----------------------------------------------------------------------------------
      SET @error_file = CONCAT('D:',NCHAR(92),'logs',NCHAR(92),@table_nm_no_brkts,'import.log');
      SET @del_file = @error_file;
      EXEC sp_log 1, @fn, '070: deleting log file ', @del_file;
      EXEC sp_delete_file @del_file;
      SET @del_file = CONCAT(@del_file, '.Error.Txt');
      EXEC sp_log 1, @fn, '080: deleting log file ',@del_file;
      EXEC sp_delete_file @del_file;
      ----------------------------------------------------------------------------------
      -- R01: Import the table from the tsv file
      ----------------------------------------------------------------------------------
      SET @cmd = 
         CONCAT('BULK INSERT ',@view,' FROM ''',@file_path,''' 
WITH
(
    DATAFILETYPE    = ''Char''
   ,FIRSTROW        = ',@first_row, @nl
);
      IF @last_row         IS NOT NULL 
      BEGIN
         EXEC sp_log 1, @fn, '090: @last_row is not null, =[',@last_row, ']';
         SET @cmd = CONCAT( @cmd, '   ,LASTROW        =   ', @last_row        , @nl);
      END
      IF @format_file      IS NOT NULL
      BEGIN
         EXEC sp_log 1, @fn, '100: @last_row is not null, =[',@last_row, ']';
         SET @cmd = CONCAT( @cmd, '   ,FORMATFILE     = ''', @format_file, '''', @nl);
      END
      IF @field_terminator IS NOT NULL
      BEGIN
         EXEC sp_log 1, @fn, '110: @field_terminator is not null, =[',@field_terminator, ']';
         If @field_terminator = 't' SET @field_terminator = '\t';
         SET @cmd = CONCAT( @cmd, '   ,FIELDTERMINATOR= ''', @field_terminator, '''', @nl);
      END
      if @row_terminator IS NOT NULL
      BEGIN
         EXEC sp_log 1, @fn, '120: @row_terminator is not null, =[',@row_terminator, ']';
         SET @cmd = CONCAT( @cmd, '   ,ROWTERMINATOR= ''', @row_terminator, '''', @nl);
      END
      SET @cmd = CONCAT( @cmd, '  ,ERRORFILE      = ''',@error_file,'''', @nl
         ,'  ,MAXERRORS      = 20', @nl
         ,'  ,CODEPAGE       = ',@codepage, @nl
         ,');'
      );
      PRINT CONCAT( @nl, @line);
      EXEC sp_log 1, @fn, '130: importing file: SQL: 
', @cmd;
      PRINT CONCAT( @line, @nl);
      EXEC (@cmd);
      SET @row_cnt = @@ROWCOUNT;
      EXEC sp_log 1, @fn, '140: imported ', @row_cnt, ' rows';
      ----------------------------------------------------------------------------------------------------
      -- 05-NOV-2024: optionally display imported table
      ----------------------------------------------------------------------------------------------------
      IF @display_table = 1
      BEGIN
         EXEC sp_log 1, @fn, '150: displaying table: ', @table;
         SET @cmd = CONCAT('SELECT * FROM ', @table,';');
         EXEC (@cmd);
      END
      IF @expect_rows = 1
      BEGIN
         EXEC sp_log 1, @fn, '160: checking resulting row count';
         EXEC sp_assert_tbl_pop @table;
      END
      IF  @exp_row_cnt IS NOT NULL
      BEGIN
         EXEC sp_log 1, @fn, '170: checking resulting row count';
         EXEC sp_assert_tbl_pop @table, @exp_cnt = @exp_row_cnt;
      END
      ----------------------------------------------------------------------------------------------------
      -- 31-OCT-2024: cleans each imported text field for double quotes and leading/trailing white space
      ----------------------------------------------------------------------------------------------------
      SET @cmd = CONCAT('SELECT @max_len_fld = MAX(dbo.fnLen(column_name)) FROM list_table_columns_vw WHERE table_name = ''', @table, ''' AND is_txt = 1;');
      EXEC sp_log 1, @fn, '180: getting max field len: @cmd:', @cmd;
      EXEC sp_executesql @cmd, N'@max_len_fld INT OUT', @max_len_fld OUT;
      EXEC sp_log 1, @fn, '190: @max_len_fld: '       , @max_len_fld;
      EXEC sp_log 1, @fn, '200: @table_nm_no_brkts: ' , @table_nm_no_brkts;
      EXEC sp_log 1, @fn, '210: @table            : ' , @table ;
      ----------------------------------------------------------------------------------
      -- R02: Remove double quotes
      -- R03: Trim leading/trailing whitespace
      -- R04: Remove line feeds
      ----------------------------------------------------------------------------------
      SET @sql = dbo.fnCrtRemoveDoubleQuotesSql( @table_nm_no_brkts, @max_len_fld);
      PRINT @sql;
      EXEC sp_log 1, @fn, '220: trim replacing double quotes, @sql:', @NL, @sql;
      EXEC (@sql);
     ----------------------------------------------------------------------------------------------------
      -- R05: check the list of @non_null_flds fields do not have any nulls - if @non_null_flds supplied
      ----------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '230: check mandatory fields for null values';
      EXEC sp_chk_flds_not_null @table_nm_no_brkts, @non_null_flds ;
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      EXEC sp_log_exception @fn;--, ' launching notepad++ to display the error files';
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, '999: leaving, imported ',@row_cnt,' rows from: ', @file_path;
   -- POST01 ret: the count of rows imported
   RETURN @row_cnt;
END
/*
EXEC test.test_037_sp_import_txt_file;
EXEC tSQLt.Run 'test.test_037_sp_import_txt_file';
EXEC sp_AppLog_display
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[GenericStaging](
	[staging] [varchar](8000) NULL
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 12-JUN-2025
-- Description: Create and populate a table from a data file
-- 
-- Design:      EA: Model.Use Case Model.Create and populate a table from a data file
-- Define the import data file path
-- Table name = file name
-- Reads the header for the column names
-- Create a table with table name, columns = field names, type = text
-- Create a staging table 
-- Create a format file using BCP and the table
-- Generate the import routine using the table and the format file
--
-- Parameters:
--    @file_path     VARCHAR(500) -- the import data file path
-- Tests:       test_068_sp_crt_pop_table
--
-- Preconditions:
-- PRE01: @file_path populated, and must have folder
-- Postconditions:
-- ==================================================================================
CREATE PROCEDURE [dbo].[sp_crt_pop_table]
    @file_path       VARCHAR(500) -- the import data file path
   ,@table_nm        VARCHAR(50) = NULL
   ,@sep             VARCHAR(6)  = NULL
   ,@format_file     VARCHAR(500)= NULL
   ,@codepage        INT         = NULL
   ,@display_tables  BIT         = 0
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
    @fn           VARCHAR(35)   = N'sp_crt_pop_table'
   ,@fields       VARCHAR(8000)
   ,@file         VARCHAR(500)
   ,@folder       VARCHAR(500)= NULL
   ,@NL           CHAR = CHAR(13)
   ,@tab          CHAR = CHAR(9)
   ,@ndx          INT
   ,@len          INT
   ,@stg_table_nm VARCHAR(50)
   ,@row_cnt      INT
   ,@cmd          VARCHAR(8000)
   ,@sql          VARCHAR(8000)
   BEGIN TRY
      IF @codepage IS NULL
         SET @codepage = 65001;
      EXEC sp_log 1, @fn, '000: starting:
@file_path:       [',@file_path,']
@table_nm:        [',@table_nm,']
@sep:             [',@sep,']
@codepage:        [',@codepage,']
@display_tables:  [',@display_tables,']
';
      ---------------------------------------------------------------
      -- Validate
      ---------------------------------------------------------------
      IF @sep IS NULL OR @sep IN('',0x09,'0x09', '\t') SET @sep = @tab; -- default
      SET @len = dbo.fnLen(@file_path);
      SET @ndx = dbo.fnFindLastIndexOf('\', @file_path);
      -- PRE01: @file_path populated, and must have folder
      EXEC sp_assert_gtr_than @ndx, 0, @fn, ' PRE01: @file_path populated, and must have folder';
      ---------------------------------------------------------------
      -- Setup
      ---------------------------------------------------------------
      -- Table name = file name less the extension
      SET @file   = SUBSTRING(@file_path, @ndx+2, @len-@ndx);
      SET @folder = iif(@ndx = 0, NULL, SUBSTRING(@file_path, 1, @ndx));
      -- Set table nm if not supplied
      IF @table_nm IS NULL
         SELECT @table_nm = a FROM dbo.fnSplitPair2(@file, '.');
      EXEC sp_log 1, @fn, '010:
@len:     [', @len     , ']
@ndx:     [', @ndx     , ']
@file:    [', @file    , ']
@table_nm:[', @table_nm, ']
@folder:  [', @folder  , ']
';
      -- Table name = file name  less the extension
      -- Import the header into a single column generic text table
      -- Reads the header for the column names
      -- Read the header for the column names
         EXEC sp_log 1, @fn, '020: importing the file header for the column names';
         DELETE FROM GenericStaging;
         EXEC @row_cnt = sp_import_txt_file
             @table           = 'GenericStaging'
            ,@file            = @file
            ,@folder          = @folder
            ,@first_row       = 1
            ,@last_row        = 1
            ,@field_terminator= @NL
--          ,@view            = 'ImportGenericStaging_vw'
          --,@format_file     = @format_file
            ,@codepage        = @codepage
            ,@display_table   = 1
         ;
         EXEC sp_log 1, @fn, '025: imported hdr row into GenericStaging';
         SELECT * FROM GenericStaging;
      -- Create the staging table,  columns = field names, type = text
      -- Create a staging table
      SET @stg_table_nm = CONCAT(@table_nm, 'Staging');
      EXEC sp_drop_table @stg_table_nm;
      -- Create a table with table name, columns = field names, type = text
      EXEC sp_log 1, @fn, '030: creating the staging table, cmd: ', @NL, @cmd;
      SELECT @fields = staging FROM GenericStaging;
      EXEC sp_log 1, @fn, '040: @fields: ', @fields;
      EXEC sp_log 1, @fn, '045: @stg_table_nm: ',@stg_table_nm;
      SET @cmd = dbo.fnCrtTblSql(@stg_table_nm, @fields); -- delimits the qualified @stg_table_nm if necessary
      EXEC sp_log 1, @fn, '050: executing Create table sql:',@NL, @cmd;
      EXEC (@cmd);
      -- Bracket table name as necessary
      -- Bracket field names as necessary
      -- Create a format file using BCP and the table
      --SET @cmd = dbo.fnCrtTblSql(@table_nm, @fields);
      --EXEC sp_log 1, @fn, '060: creating the main table, sql: ', @NL, @cmd;
      --EXEC (@cmd);
   -- Create and populate the table from data file : Create and populate a table from a data file_ActivityGraph
   -- Infer the field types from the staged data
   -- Merge the staging table to the main table
      -- Create a format file using BCP and the table
      IF @format_file IS NULL SET @format_file = CONCAT(@folder, '\',@table_nm,'_fmt.xml');-- fmt xml
      --SET @cmd = CONCAT('bcp ',DB_NAME(),'.dbo.',@table_nm,' format nul -c -x -f ',@format_file, ' -t, -T');
      SET @cmd = 
         CONCAT
         (
            'bcp '
           ,DB_NAME()
           ,'.dbo.',@table_nm
           ,' format nul -c -x -f ',@format_file
           ,iif(@sep=@tab, '', ' -t, '),' -T'
         );
      EXEC sp_log 1, @fn, '060: creating format file: ', @NL, @cmd;
      EXEC xp_cmdshell @cmd;
      -- Import the staging table
      -- Import staging table using the table and the format file
      EXEC sp_log 1, @fn, '070: importing ', @file_path, ' to staging: ', @stg_table_nm;
      EXEC sp_import_txt_file
          @table            = @stg_table_nm
         ,@file             = @file_path
         ,@folder           = NULL
         ,@field_terminator = @sep
         ,@codepage         = @codepage
         ,@first_row        = 2
         ,@format_file      = @format_file
         ,@display_table    = @display_tables
      ;
      -- Infer the field types from the staged data
      EXEC sp_log 1, @fn, '080: Infer the field types from the staged data';
      -- Infer field types: pops the FieldInfo table
      EXEC sp_infer_field_types @stg_table_nm;
      EXEC sp_log 1, @fn, '090: Drop the main  if it exists';
      -- Drop table if it exists
      EXEC sp_drop_table @table_nm;
      -- Create the main table with table name, columns = field names, type = inferred type
      EXEC sp_log 1, @fn, '100: Create the main table with table name, columns = field names, type = inferred type';
      SELECT @sql = 
      CONCAT
      (
      'CREATE TABLE ', @table_nm, '
(
'
,STRING_AGG(CONCAT('   ', lower(nm), ' ', ty), ',
'
),'
);'
      )
      FROM FieldInfo
      ;
      EXEC sp_log 1, @fn, '110: Creating the main table, sql:
', @sql;
      EXEC(@sql);
      -- Migrating the staging data to the main table
      SET @sql = CONCAT('INSERT INTO ', @table_nm,' SELECT * FROM ',@stg_table_nm,';')
      EXEC sp_log 1, @fn, '120: Migrating the staging data to the main table, @sql:
', @sql;
      EXEC(@sql);
      SELECT @table_nm as [main table];
      SET @sql = CONCAT('SELECT * FROM ',@table_nm,';')
      EXEC sp_log 1, @fn, '130: displaying the main table';
      EXEC(@sql);
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: Caught exception';
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, '999: completed processing';
END
/*
EXEC sp_crt_pop_table
    @file_path       = 'D:\Dev\Property\Property_Sales.Resort_Sale.tsv'
   ,@sep             = NULL
   ,@format_file     = 'D:\Dev\Property\Property_Sales.Resort_Sale.xml'
   ;
EXEC test.test_068_sp_crt_pop_table;
EXEC sp_crt_pop_table 'D:\Dev\Property\Data\PropertySales.txt';
      EXEC test.hlpr_068_sp_crt_pop_table
          @tst_num            = '001'
         ,@display_tables     = 1
         ,@inp_file_path      = 'D:\Dev\Property\Data\Property_Sales.Resort_Sale.tsv'
         ,@inp_format_file    = 'D:\Dev\Property\Data\Property_Sales.Resort_Sale.xml'
         ,@inp_sep            = '0x09'
         ,@inp_codepage       = NULL
         ,@inp_display_tables = 1
         ,@exp_row_cnt        = NULL
         ,@exp_ex_num         = NULL
         ,@exp_ex_msg         = NULL
      ;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 03-APR-2020
-- Description: This stored procedure dynamically imports data from a specified Excel
-- file, creates a new table, and adds an auto-incrementing ID column as the first field.
--
--Example Execution:
/*
EXEC sp_import_new_table_from_xl
'D:\Dev\Property\Data\PropertySales.xlsx'
,'Resort'
,'A1:C10'
,'ResortSales';
SELECT * FROM ResortSales;
*/
-- ======================================================================================
CREATE PROCEDURE [dbo].[sp_import_new_table_from_xl]
    @file            VARCHAR(1000)
   ,@worksheet       VARCHAR(31)
   ,@range           VARCHAR(255)
   ,@table           VARCHAR(128)
   ,@display_tables  BIT = 0
AS
BEGIN
   DECLARE
      @fn            VARCHAR(35)    = N'sp_import_new_table_from_xl'
     ,@sql           NVARCHAR(4000)
     ,@columnList    NVARCHAR(MAX) = ''
     ,@field         VARCHAR(30)
   ;
   EXEC sp_log 1, @fn, '000: starting:
@file:     [',@file,']
@worksheet:[',@worksheet,']
@range:    [',@range,']
@table:    [',@table,']
';
BEGIN TRY
   -- 0. Drop the target table if it already exists
   EXEC sp_log 1, @fn, '010: dropping table ', @table, ' If it exists';
   IF OBJECT_ID(@table, 'U') IS NOT NULL
   BEGIN
      SET @sql = CONCAT('DROP TABLE [', @table, '];');
      EXEC sp_log 1, @fn, '020:',@sql;
      EXEC (@sql);
   END
   -- 0. Drop the staging table if it exists
   EXEC sp_log 1, @fn, '030: dropping the temporary table TempExcelData If it exists';
   IF OBJECT_ID('TempExcelData', 'U') IS NOT NULL
      DROP TABLE TempExcelData;
   -- 1. Create a regular table to hold the raw data from the Excel file
   -- This uses the OPENROWSET method.
   SET @sql = CONCAT('
      SELECT *
      INTO TempExcelData
      FROM OPENROWSET(''Microsoft.ACE.OLEDB.12.0'',
         ''Excel 12.0;Database=', @file, ';HDR=YES'',
         ''SELECT * FROM [', @worksheet, '$', @range, ']'')
   ');
   EXEC sp_log 1, @fn, '040:',@sql;
   EXEC sp_executesql @sql;
   -- 2. Get the column names from the staging table
   -- We'll use these to build the schema for the final table.
   SELECT @columnList = @columnList + QUOTENAME(c.name) + ' ' + t.name +
                   CASE WHEN t.name IN ('varchar', 'nvarchar', 'char', 'nchar') THEN '(' + CASE WHEN c.max_length = -1 THEN 'MAX' ELSE CAST(c.max_length AS VARCHAR) END + ')' ELSE '' END + ','
   FROM sys.columns AS c
   JOIN sys.types AS t ON c.user_type_id = t.user_type_id
   WHERE c.object_id = OBJECT_ID('TempExcelData')
   ORDER BY c.column_id;
   -- Check for and handle empty column list
   IF LEN(@columnList) > 0
   BEGIN
      SET @columnList = LEFT(@columnList, LEN(@columnList) - 1);
   END
   ELSE
   BEGIN
      RAISERROR('No columns found in Excel data. Cannot proceed.', 16, 1);
      EXEC sp_log_exception @fn, '50: No columns found in Excel data. Cannot proceed.';
      RETURN;
   END
   -- 3. Dynamically create the final table with the new ID column first
   SET @sql = CONCAT('
      CREATE TABLE [', @table, '] (
         ID INT IDENTITY(1,1) PRIMARY KEY,
         ', @columnList, '
      );'
   );
   
   EXEC sp_log 1, @fn, '060: create the main table with id',@sql;
   EXEC sp_executesql @sql;
   -- 4. Insert the data from the temporary table into the new table
   -- The ID column will be auto-populated.
   -- We need to generate the column list for the INSERT statement, excluding the ID.
   DECLARE @insertColumns NVARCHAR(MAX) = '';
   SELECT @insertColumns = @insertColumns + QUOTENAME(c.name) + ','
   FROM sys.columns AS c
   WHERE c.object_id = OBJECT_ID('TempExcelData')
   ORDER BY c.column_id;
   SET @insertColumns = LEFT(@insertColumns, LEN(@insertColumns) - 1);
   SET @sql = CONCAT('
      INSERT INTO [', @table, '] (', @insertColumns, ')
      SELECT ', @insertColumns, '
      FROM TempExcelData;
   ');
   EXEC sp_log 1, @fn, '070: poplate the main table',@sql;
   EXEC sp_executesql @sql;
   EXEC sp_log 1, @fn, '080: table [', @table, '] was successfully created from the Excel file.';
   EXEC sp_log 1, @fn, '090: the new ID column has been added as the first field.';
   -- 6 Delete any rows where the first column is null
   SELECT @field = name FROM sys.columns
   WHERE [object_id] = OBJECT_ID('TempExcelData')
   AND column_id = 1;
   SET @sql = CONCAT('DELETE FROM [',@table,'] WHERE [',@field,'] IS NULL;');
   EXEC sp_log 1, @fn, '100: cleaning null trailing rows from ',@table,' @sql:
   ', @sql;
   EXEC(@sql);
   EXEC sp_log 1, @fn, '110: cleaning null trailing rows from ',@table,' where '
      ,@field, ' IS NULL, deleted ', @@ROWCOUNT, ' rows.';
   IF @display_tables = 1
   BEGIN
      SET @sql = CONCAT('SELECT ''',@table, ''' as [table];');
      EXEC sp_log 1, @fn, '120: ',@sql;
      EXEC(@sql);
      SET @sql = CONCAT('SELECT * FROM [',@table,']');
      EXEC(@sql);
   END
   -- 5. Clean up the staging table
   DROP TABLE IF EXISTS TempExcelData;
END TRY
BEGIN CATCH
   -- Log the exception
   EXEC sp_log_exception @fn, 'Exception caught. Cleaning up tables.';
   -- Clean up both tables if an error occurs
   IF OBJECT_ID('TempExcelData', 'U') IS NOT NULL
      DROP TABLE IF EXISTS TempExcelData;
   IF OBJECT_ID(@table, 'U') IS NOT NULL
   BEGIN
      SET @sql = CONCAT('DROP TABLE [', @table, ']');
      EXEC(@sql);
   END
   ;THROW; -- Re-throw the error
END CATCH;
   EXEC sp_log 1, @fn, '999: completed processing';
END
/*
EXEC sp_import_new_table_from_xl 
'D:\Dev\Property\Data\PropertySales.xlsx'
,'Resort'
,'A1:C10'
,'ResortSales'
;
SELECT * FROM ResortSales;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 9-SEP-2025
-- Description: 
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:      
-- Tests:       
-- =============================================
CREATE PROCEDURE [dbo].[sp_Pop_ResortSalesRefData]
   @display_tables  BIT         = 1
AS
BEGIN
   SET NOCOUNT ON;
   EXEC sp_import_new_table_from_xl 'D:\Dev\Property\Data\PropertySales.xlsx', 'Lists', 'A2:A27', 'Country',  @display_tables;
   EXEC sp_import_new_table_from_xl 'D:\Dev\Property\Data\PropertySales.xlsx', 'Lists', 'B2:C10', 'Delegate', @display_tables;
   EXEC sp_import_new_table_from_xl 'D:\Dev\Property\Data\PropertySales.xlsx', 'Lists', 'D2:D50', 'Status',   @display_tables;
   EXEC sp_import_new_table_from_xl 'D:\Dev\Property\Data\PropertySales.xlsx', 'Lists', 'E2:E10', 'Area',     @display_tables;
   EXEC sp_import_new_table_from_xl 'D:\Dev\Property\Data\PropertySales.xlsx', 'Lists', 'F2:F15', 'Type',     @display_tables;
   EXEC sp_import_new_table_from_xl 'D:\Dev\Property\Data\PropertySales.xlsx', 'Lists', 'G2:G32', 'Action',   @display_tables;
END
/*
EXEC sp_Pop_ResortSalesRefData;
EXEC tSQLt.Run 'test.test_<proc_nm>';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===========================================================
-- Author:      Terry watts
-- Create date: 9-Sep-2025
-- Description: Clean populates the Property sales tables
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:      
-- Tests:       
-- ===========================================================
CREATE PROCEDURE [dbo].[sp_crt_pop_property_sales]
    @file_path       VARCHAR(500) -- the import data file tsv
   ,@display_tables  BIT         = 0
AS
BEGIN
 SET NOCOUNT ON;
   DECLARE
    @fn              VARCHAR(35) = N'sp_crt_pop_property_sales'
   ,@rc              INT         = 1
   ,@sep             VARCHAR(6)  = NULL
   ,@format_file     VARCHAR(500)= 'D:\Dev\Property\Data\Property_Sales.Resort_Sale.xml'
   ;
   EXEC sp_log 1, @fn ,'000: starting
    @file_path       :[',@file_path     ,']
   ,@display_tables  :[',@display_tables,']
';
   BEGIN TRY
      EXEC sp_log 1, @fn ,'010: importing the main marketing info table';
      EXEC @rc = dbo.sp_crt_pop_table
                @file_path       = @file_path
               ,@sep             = NULL
               ,@format_file     = @format_file
               ,@display_tables  = @display_tables
               ;
      EXEC sp_log 1, @fn ,'020: importing the reference data';
      EXEC sp_Pop_ResortSalesRefData @display_tables;
      EXEC sp_log 1, @fn ,'490: completed processing';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn ,'999: leaving';
END
/*
EXEC sp_crt_pop_property_sales 'D:\Dev\Property\Data\Property Sales - Resort Sale.tsv'
EXEC tSQLt.Run 'test.test_<proc_nm>';
*/
GO

GO
CREATE TYPE [test].[CompareStringsTbl] AS TABLE(
	[A] [varchar](max) NULL,
	[B] [varchar](max) NULL,
	[SA] [varchar](max) NULL,
	[SB] [varchar](max) NULL,
	[CA] [varchar](max) NULL,
	[CB] [varchar](max) NULL,
	[msg] [varchar](max) NULL,
	[match] [bit] NULL,
	[status_msg] [varchar](120) NULL,
	[code] [int] NULL,
	[ndx] [int] NULL,
	[log] [varchar](max) NULL
)
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================================================
-- Author:      Terry Watts
-- Create date: 19-NOV-2024
-- Description: function to compare 2 strings
-- Returns TABLE with 3 rows,[A as chars, B as chars, A as ascii codes, B as ASCII codes]
-- Stops at first mismatch
--
-- Tests: test_037_fnCompareStrings
-- ======================================================================================
CREATE PROC [dbo].[sp_fnCompareStrings]( @a VARCHAR(MAX), @b VARCHAR(MAX))
/*
RETURNS @t TABLE
(
    SA            VARCHAR(MAX) -- STRING characters             for A
   ,SB            VARCHAR(MAX) -- STRING characters             for B
   ,CA            VARCHAR(MAX) -- SEQ ASCII codes formattd 00N  for A
   ,CB            VARCHAR(MAX) -- SEQ ASCII codes formattd 00N  for B
   ,msg           VARCHAR(MAX) -- match results
   ,[match]       BIT
   ,status_msg    VARCHAR(120)
   ,code          INT
   ,ndx           INT
   ,[log]         VARCHAR(MAX)
)
*/
AS
BEGIN
   DECLARE
       @fn           VARCHAR(35) = N'sp_fnCompareStrings'
      ,@charA        CHAR
      ,@charB        CHAR
      ,@asciA        CHAR(3)
      ,@asciB        CHAR(3)
      ,@CA           VARCHAR(MAX) -- Ascii codes in hex/spx
      ,@CB           VARCHAR(MAX) -- Ascii codes in hex/spc
      ,@SA           VARCHAR(MAX) -- Characters matching Ascii codes/spx
      ,@SB           VARCHAR(MAX) -- Characters matching Ascii codes/spx
      ,@first_time   BIT = 1
      ,@i            INT
      ,@lenMax       INT
      ,@lenA         INT
      ,@lenB         INT
      ,@match        BIT = 1
      ,@msg          VARCHAR(MAX)
      ,@nl           VARCHAR(2) = CHAR(13) + CHAR(10)
      ,@status_msg   VARCHAR(50)
      ,@code         INT
      ,@log          VARCHAR(MAX)
      ,@t            test.CompareStringsTbl
      ,@params       VARCHAR(MAX)
   ;
   WHILE(1=1)
   BEGIN
      SET @params = CONCAT
      (
'a:[', iif(@a IS NULL, '<NULL>', iif( LEN(@a)=0,'<empty string>',@a)), ']', @nl,
'b:[', iif(@a IS NULL, '<NULL>', iif( LEN(@b)=0,'<empty string>',@b)), ']', @nl
      );
      EXEC sp_log 1, @fn, '000: starting, params:',@nl, @params;
      IF (@a IS NULL OR @b IS NULL) -- But not both
      BEGIN
         -----------------------------------------------------------------
         -- ASSERTION: @a IS NULL OR @b IS NULL may be both
         -----------------------------------------------------------------
         EXEC sp_log 0, @fn, '010: ASSERTION: @a IS NULL OR @b IS NULL maybe both';
         IF(@a IS NULL AND @b IS NULL)
         BEGIN
            SELECT
                @msg   = 'both a or b are NULL'
               ,@match = 1
               ,@status_msg= 'OK'
               ,@code  = 1
            ;
            EXEC sp_log 1, @fn, '020: match: both inputs are NULL'
            BREAK;
         END
      ------------------------------------------------------
      -- ASSERTION: one or other input is null but not both
      ------------------------------------------------------
       EXEC sp_log 1, @fn, '030: ASSERTION: one or other input is null but not both'
         SELECT
             @msg       = 'one of a or b is NULL but not both '
            ,@match     = 0
            ,@status_msg= 'OK'
            ,@code      = 2 -- 'one of a or b is NULL but not both '
         EXEC sp_log 1, @fn, '040: mismatch, one of a or b is NULL but not both';
         BREAK;
      END
      -----------------------------------------------------------------
      -- ASSERTION: both are not null
      -----------------------------------------------------------------
      SET @lenA = dbo.fnLen(@a);
      SET @lenB = dbo.fnLen(@b);
      EXEC sp_log 1, @fn, '050: len(a): ', @lenA, ' len(b): ', @lenB;
      -- Check length of both strings <=1000 (need 4 chars per char compared
      EXEC sp_log 1, @fn, '060: check string length <=1333';
      SET @lenMax = dbo.fnMax(@lenA, @lenb);
      IF @lenA <> @lenb
      BEGIN
         SELECT
             @msg       = CONCAT('strings differ in length a: ', @lenA, ' b: ', @lenb)
            ,@match     = 0
            ,@status_msg= 'OK'
            ,@code      = 5 -- length mismatch
         EXEC sp_log 1, @fn, '070: mismatch, string lengths differ, @lenA: ', @lenA, ' @lenB: ', @lenB;
         --BREAK;
      END
      -- Need 3 chars like [ xx] for each char checked so limit is 8000/3 = 2666
      IF @lenA > 1000 OR @lenB > 2666
      BEGIN
         SELECT
             @msg       = 'a or b is too long to store the results of a detailed comparison, it has more than 2666 characters whih means the formatted output is more than MAX size of string'
            ,@match     = 0
            ,@status_msg= 'TOO LONG TO STORE DETAILED RESULTS'
            ,@code      = -1 -- one of a or b is too long to compare
         EXEC sp_log 3, @fn, '050:', @msg;
         --BREAK;
      END
      -----------------------------------------------------------------
      -- ASSERTION: No previous check failed, strings are same length
      -----------------------------------------------------------------
      EXEC sp_log 1, @fn, '080: detailed check, @lenMax: ', @lenMax;
      SET @i = 0;
      WHILE(@i<=@lenMax)
      BEGIN
         SET @charA = iif(@i<=@lenA, SUBSTRING(@a, @i,1), '_');
         SET @charB = iif(@i<=@lenB, SUBSTRING(@b, @i,1), '_');
         SET @asciA = iif(@i<=@lenA, FORMAT(ASCII(@charA), 'x2'), '  ')
         SET @asciB = iif(@i<=@lenB, FORMAT(ASCII(@charB), 'x2'), 'xx')
      -----------------------------------------------------------------
      -- Only do the HEX thing if have room to store result
      -----------------------------------------------------------------
         if(@i < 2667)
         BEGIN
            SET @CA = CONCAT(@CA, ' ', @asciA);
            SET @CB = CONCAT(@CB, ' ', @asciB);
            
            SET @SA = CONCAT(@SA,
            CASE
               WHEN @charA = CHAR(09) THEN '\t'
               WHEN @charA = CHAR(13) THEN '\r'
               WHEN @charA = CHAR(10) THEN '\n'
               ELSE @charA
            END
            )
            ;
            SET @SB = CONCAT(@SB,
            CASE
               WHEN @charB = CHAR(09) THEN '\t'
               WHEN @charB = CHAR(13) THEN '\r'
               WHEN @charB = CHAR(10) THEN '\n'
               ELSE @charB
            END
            );
         END
         SET @i = @i + 1;
         IF @asciA <> @asciB
         BEGIN
            SELECT 
                @msg       = CONCAT('mismatch at pos: ', @i, ' @lenMax: ',@lenMax,' char: [',@charA,']/[',@charB,'], ASCII: [',@asciA,']/[',@asciB,']')
               ,@code      = 4
               ,@status_msg= 'OK'
               ,@code      = 5 -- length mismatch
            IF @first_time = 1
            BEGIN
               EXEC sp_log 1, @fn, '090: ASCII code mismatch at pos ', @i, ', ASCII codes differ  ASCII: [',@asciA,']/[',@asciB,']';
               SET @first_time = 0;
               SET @match      = 0;
            END
            --BREAK;
         END
      END
      -----------------------------------------------------------------
      -- ASSERTION: if here match already set
      -----------------------------------------------------------------
      SELECT
          @msg       = 'strings match'
         ,@status_msg= 'OK'
         ,@code      = 0 -- match
      --SET @log = CONCAT(@log, '|', '100: strings match');
      BREAK;
   END -- while 1=1 main do loop
   -----------------------------------------------------------------
   -- ASSERTION: @a, @b, @CA, @CB, @msg ARE SET
   -----------------------------------------------------------------
   EXEC sp_log 1, @fn, '100: match:',@match,' status_msg:[', @status_msg, '] code:[', @code, '} @i:', @i,' max len: ', @lenMax;
   INSERT INTO @t( A,  B,  SA,  SB,  CA,  CB,  msg, [match], status_msg,  code, ndx, [log])
   VALUES        (@a, @b, @SA, @SB, @CA, @CB, @msg, @match, @status_msg, @code, @i,  @log);
   --RETURN;
   SELECT * FROM @t;
   if(@match = 0)
   BEGIN
      EXEC sp_log 1, @fn, '025: mismatch:', @nl
,'a:',@SA, @nl
,'b:',@SB, @nl
,'a:',@CA, @nl
,'b:',@CB;
   END
END
/*
EXEC tSQLt.Run 'test.test_037_sp_fnCompareStrings';
EXEC tSQLt.Run 'test.test_018_fnCrtUpdateSql';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Area](
	[area_id] [int] IDENTITY(1,1) NOT NULL,
	[area_nm] [nvarchar](20) NOT NULL,
 CONSTRAINT [PK_Area] PRIMARY KEY CLUSTERED 
(
	[area_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Area_nm] UNIQUE NONCLUSTERED 
(
	[area_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 11-SEP-2025
-- Description: -- 
-- returns all the area static data 
-- Design:      
-- Tests:       
-- =============================================
CREATE PROCEDURE [dbo].[sp_get_all_areas]
AS
BEGIN
   DECLARE @fn VARCHAR(35)='sp_get_all_areas'
   ;
   SET NOCOUNT ON;
   EXEC sp_log 1, @fn, '000: starting';
   SELECT * FROM [Area];
   EXEC sp_log 1, @fn, '999: leaving';
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_<proc_nm>';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Country](
	[country_id] [int] IDENTITY(1,1) NOT NULL,
	[country_nm] [nvarchar](50) NOT NULL,
 CONSTRAINT [PK_Country] PRIMARY KEY CLUSTERED 
(
	[country_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Country_nm] UNIQUE NONCLUSTERED 
(
	[country_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 10-SEP-2025
-- Description: Returns a list of the countries 
--              from the country table.
-- Design:      
-- Tests:       
-- =============================================
CREATE PROCEDURE [dbo].[sp_get_all_countries]
AS
BEGIN
 SET NOCOUNT ON;
 SELECT TOP (1000) [ID]
      ,[name]
  FROM [Property_Dev].[dbo].[Country];
END
/*
EXEC dbo.sp_get_all_countries;
EXEC tSQLt.Run 'test.test_<proc_nm>';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =====================================================
-- Description: Gets a text file line count
-- Author:      Terry Watts
-- Create date: 11-JUL-2025
-- Design:      
-- Tests:       
-- ====================================================
CREATE PROCEDURE [dbo].[sp_GetTxtFileLineCount]
    @file_path          NVARCHAR(4000)
AS
BEGIN
   DECLARE
       @fn              VARCHAR(35) = 'sp_GetTxtFileLineCount'
      ,@cnt             INT
      ,@sql             NVARCHAR(4000)
      ,@sep             CHAR = '\0'
      ,@row_terminator  CHAR(2) = '\r\n'
   ;
   SET NOCOUNT ON;
   EXEC sp_log 1, @fn, '000: starting:
    @file_path:[', @file_path, ']';
   -- Step 1: Create a temporary table to hold the file content
   CREATE TABLE #TempFileLines (LineText NVARCHAR(MAX));
   -- Step 2: Use BULK INSERT to read the text file
   SET @sql = CONCAT('
   BULK INSERT #TempFileLines
   FROM ''', @file_path, '''
   WITH (
       ROWTERMINATOR   = ''',@row_terminator,''', 
       FIELDTERMINATOR = ''',@sep,''',
       CODEPAGE = ''65001''
   );'
   );
   EXEC (@sql);
         EXEC @cnt = sp_import_txt_file
          @table            = '#TempFileLines'
         ,@file             = @file_path
         ,@folder           = NULL
         ,@field_terminator = @sep
         ,@codepage         = 65001
         ,@first_row        = 2
 --        ,@format_file      = @format_file
 --        ,@display_table    = @display_tables
      ;
      EXEC sp_log 1, '050: raw cnt: ', @cnt;
   -- Step 3: Count the number of lines
SELECT COUNT(*) AS LineCount
FROM #TempFileLines
WHERE PATINDEX('%[A-Za-z0-9]%', REPLACE(REPLACE(LineText, CHAR(9), ''), CHAR(10), '')) > 0;
-- Debug: Inspect all rows
SELECT 
    LineText,
    LEN(LineText) AS LineLength,
    ASCII(LEFT(LineText, 1)) AS FirstCharASCII,
    ASCII(RIGHT(LineText, 1)) AS LastCharASCII
FROM #TempFileLines
WHERE PATINDEX('%[A-Za-z0-9]%', REPLACE(REPLACE(LineText, CHAR(9), ''), CHAR(10), '')) > 0
;
   -- Step 4: Clean up the temporary table
   DROP TABLE #TempFileLines;
   EXEC sp_log 1, @fn, '999: leaving @cnt: ',@cnt , ' rows';
   RETURN @cnt;
END
/*
EXEC sp_GetTxtFileLineCount 'D:\Dev\Property\Data\PropertySales.Resort.txt';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Type](
	[type_id] [int] IDENTITY(1,1) NOT NULL,
	[type_nm] [nvarchar](20) NOT NULL,
 CONSTRAINT [PK__Type] PRIMARY KEY CLUSTERED 
(
	[type_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Type_nm] UNIQUE NONCLUSTERED 
(
	[type_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Status](
	[status_id] [int] IDENTITY(1,1) NOT NULL,
	[status_nm] [nvarchar](50) NULL,
 CONSTRAINT [PK__Status] PRIMARY KEY CLUSTERED 
(
	[status_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Status_nm] UNIQUE NONCLUSTERED 
(
	[status_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Delegate](
	[delegate_id] [int] IDENTITY(1,1) NOT NULL,
	[delegate_nm] [nvarchar](15) NULL,
	[alias] [nvarchar](2) NULL,
 CONSTRAINT [PK__Delegate] PRIMARY KEY CLUSTERED 
(
	[delegate_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Delegate_nm] UNIQUE NONCLUSTERED 
(
	[delegate_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[PropertySales](
	[agency] [varchar](57) NULL,
	[type_nm] [varchar](10) NULL,
	[type_id] [int] NULL,
	[area] [varchar](6) NULL,
	[area_id] [int] NULL,
	[delegate_id] [int] NULL,
	[status_id] [int] NULL,
	[status] [varchar](40) NULL,
	[sept_2] [varchar](38) NULL,
	[notes] [varchar](509) NULL,
	[quality] [varchar](4) NULL,
	[contact_nm] [varchar](318) NULL,
	[phone] [varchar](255) NULL,
	[preferred_contact_method] [varchar](8) NULL,
	[email] [varchar](216) NULL,
	[whatsapp] [varchar](45) NULL,
	[viber] [varchar](14) NULL,
	[facebook] [varchar](92) NULL,
	[messenger] [varchar](85) NULL,
	[website] [varchar](319) NULL,
	[address] [varchar](62) NULL,
	[notes_2] [varchar](82) NULL,
	[old_notes] [varchar](156) NULL,
	[date_1] [varchar](11) NULL,
	[actions_08_oct] [varchar](51) NULL,
	[jan_16_2025] [varchar](43) NULL,
	[action_by_dt] [varchar](7) NULL,
	[replied] [varchar](1) NULL,
	[history] [varchar](66) NULL
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [dbo].[PropertySales_vw]
AS
SELECT
       ps.[agency]
      ,t.[type_nm]
      ,ps.[type_id]
      ,a.area_nm
      ,d.[delegate_nm]
      ,s.[status_nm]
      ,ps.[sept_2]
      ,ps.[notes]
      ,ps.[quality]
      ,ps.[contact_nm]
--      ,ps.[agnt_comm_split]
      ,ps.[phone]
 --     ,ps.[alt_phone]
      ,ps.[preferred_contact_method]
      ,ps.[email]
      ,ps.[whatsapp]
      ,ps.[viber]
      ,ps.[facebook]
      ,ps.[messenger]
      ,ps.[website]
      ,ps.[address]
      ,ps.[notes_2]
      ,ps.[old_notes]
      ,ps.[date_1]
      ,ps.[actions_08_oct]
      ,ps.[jan_16_2025]
      ,ps.[action_by_dt]
      ,ps.[replied]
      ,ps.[history]
FROM PropertySales ps 
LEFT JOIN [Type]   t ON ps.[type_id] = t.[type_id]
LEFT JOIN Area     a ON ps.area_id   = a.area_id
LEFT JOIN Delegate d ON ps.delegate_id = d.delegate_id
LEFT JOIN [Status] s ON ps.status_id = s.status_id
;
/*
SELECT * FROM PropertySales_vw;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Agency](
	[agency_id] [int] IDENTITY(1,1) NOT NULL,
	[agency_nm] [varchar](250) NOT NULL,
	[phone] [varchar](250) NULL,
	[viber] [varchar](50) NULL,
	[whatsApp] [varchar](50) NULL,
	[facebook] [varchar](50) NULL,
	[messenger] [varchar](50) NULL,
	[website] [varchar](50) NULL,
	[primary_contact_id] [int] NULL,
 CONSTRAINT [PK_Agency] PRIMARY KEY CLUSTERED 
(
	[agency_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Agency_nm] UNIQUE NONCLUSTERED 
(
	[agency_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Contact](
	[contact_id] [int] IDENTITY(1,1) NOT NULL,
	[contact_nm] [varchar](50) NULL,
	[role] [varchar](50) NULL,
	[phone] [varchar](50) NULL,
	[viber] [varchar](50) NULL,
	[whatsApp] [varchar](50) NULL,
	[faccebook] [varchar](50) NULL,
	[messenger] [varchar](50) NULL,
	[primary_contact_method] [varchar](50) NULL,
	[primary_contact_detail] [varchar](50) NULL,
 CONSTRAINT [PK_Contact] PRIMARY KEY CLUSTERED 
(
	[contact_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Contact_nm] UNIQUE NONCLUSTERED 
(
	[contact_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[ContactAgency](
	[contact_id] [int] NOT NULL,
	[agency_id] [int] NOT NULL,
	[role_nm] [nvarchar](50) NULL,
 CONSTRAINT [PK_ContactAgency] PRIMARY KEY CLUSTERED 
(
	[contact_id] ASC,
	[agency_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_ContactAgency] UNIQUE NONCLUSTERED 
(
	[contact_id] ASC,
	[agency_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[PropertySalesStaging](
	[agency] [varchar](8000) NULL,
	[type] [varchar](8000) NULL,
	[area] [varchar](8000) NULL,
	[delegate] [varchar](8000) NULL,
	[status] [varchar](8000) NULL,
	[sept_2] [varchar](8000) NULL,
	[notes] [varchar](8000) NULL,
	[quality] [varchar](8000) NULL,
	[contact_nm] [varchar](8000) NULL,
	[role] [varchar](8000) NULL,
	[phone] [varchar](8000) NULL,
	[preferred_contact_method] [varchar](8000) NULL,
	[email] [varchar](8000) NULL,
	[whatsApp] [varchar](8000) NULL,
	[viber] [varchar](8000) NULL,
	[facebook] [varchar](8000) NULL,
	[messenger] [varchar](8000) NULL,
	[website] [varchar](8000) NULL,
	[address] [varchar](8000) NULL,
	[notes_2] [varchar](8000) NULL,
	[old_Notes] [varchar](8000) NULL,
	[date_1] [varchar](8000) NULL,
	[actions_08_OCT] [varchar](8000) NULL,
	[jan_16_2025] [varchar](8000) NULL,
	[action_By_dt] [varchar](8000) NULL,
	[replied] [varchar](8000) NULL,
	[history] [varchar](8000) NULL
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===================================================================
-- Author:      Terry Watts
-- Create date: 7-SEP-2025
-- Description: Migrates the Resort Sales staging data to ResortSales
--
-- Preconditions:
-- PRE01: ResortSalesStaging table is populated
-- Postconditions:
-- POST01: ResortSales is populated
-- POST 01 
-- ===================================================================
CREATE PROCEDURE [dbo].[sp_migrate_property_sales_data] @display_tables BIT = 1
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = N'SP_MIGRATE_PROPERTY_SALES_DATA'
   ,@cmd          VARCHAR(MAX)
   ,@msg          VARCHAR(1000)
   ;
   EXEC sp_log 1, @fn,'000: starting';
   BEGIN TRY
      -- Validating Preconditions:
      -- PRE01: PropertySalesStaging table is populated
      EXEC sp_log 1, @fn,'010: Validating preconditions';
      EXEC sp_log 1, @fn,'020: Validating  PRE01:  PropertySalesStaging table is populated';
      EXEC sp_assert_tbl_pop 'PropertySalesStaging';
      EXEC sp_log 1, @fn,'030: Processing';
      EXEC sp_log 1, @fn,'040: clearing ContactAgency, Agency, Contact,PropertySales';
      DELETE FROM ContactAgency;
      DELETE FROM Agency;
      DELETE FROM Contact;
      DELETE FROM PropertySales;
      EXEC sp_log 1, @fn,'050: Pop PropertySales';
      INSERT INTO PropertySales
      (
 agency,[type_id],[area_id],[delegate_id],status_id
,[sept_2],[notes],[quality],[phone],[preferred_contact_method]
,[email],[whatsapp],[viber],[facebook],[messenger],[website]
,[address],[notes_2],[old_notes]
,[date_1]
,[actions_08_oct],[jan_16_2025]
,[action_by_dt]
,[replied],[history]
      )
      SELECT
 agency,t.[type_id],a.area_id,d.delegate_id,s.status_id
,[sept_2],[notes],[quality],[phone],[preferred_contact_method]
,[email],[whatsapp],[viber],[facebook],[messenger],[website]
,[address],[notes_2],[old_notes]
,TRY_CAST([date_1] AS DATE)
,[Actions_08_OCT],[Jan_16_2025]
,TRY_CAST(action_by_dt AS DATE)
,[replied],[history]
FROM PropertySalesStaging pss
LEFT JOIN [Type]   t ON pss.[Type]   = t.type_nm
LEFT JOIN Area     a ON pss.Area     = a.area_nm
LEFT JOIN Delegate d ON pss.delegate = d.alias
LEFT JOIN [Status] s ON pss.[status] = s.status_nm
;
      EXEC sp_log 1, @fn,'060: Pop Contact table';
      INSERT INTO Contact(contact_nm)
      SELECT distinct s1.value as contact
      FROM PropertySalesStaging ps
      CROSS APPLY string_split(Contact_nm, ',') as s1
      ORDER BY s1.value;
      IF @display_tables = 1
         SELECT * FROM PropertySales_vw;
      EXEC sp_log 1, @fn,'070: Merge Agency table';
      -- Populate Agency Table
      MERGE INTO Agency AS target
      USING (
         SELECT DISTINCT agency 
         FROM PropertySales 
         WHERE agency IS NOT NULL
      ) AS source
      ON target.agency_nm = source.agency
      WHEN NOT MATCHED BY TARGET THEN
         INSERT (agency_nm)
         VALUES (source.agency)
      WHEN NOT MATCHED BY SOURCE THEN
         DELETE;
      -- Update Agency set the default phone number to be the phone number from 
      -- PropertySalesStaging where no contacts specified
      EXEC sp_log 1, @fn,'080: update Agency default phone number where no contacts specified';
      UPDATE Agency
      SET phone = ps.phone
      FROM PropertySalesStaging ps JOIN Agency a ON ps.Agency = a.agency_nm
      WHERE ps.Contact_nm IS  NULL
      ;
      EXEC sp_log 1, @fn,'090: update Agency default phone number with the first contact phone';
      UPDATE Agency
      SET phone = X.default_phone
      FROM Agency
      INNER JOIN
      (
         SELECT agency, MIN(dbo.fnTrim(s1.value)) AS default_phone
         FROM PropertySalesStaging ps
         CROSS APPLY string_split(phone, ',') AS s1
         WHERE s1.value <> ''
         GROUP BY agency
      ) X
      ON Agency.agency_nm = X.agency;
      IF @display_tables = 1
         SELECT * FROM Agency;
      -- Validating Postconditions:
      -- POST01: PropertySales table is populated
      EXEC sp_log 1, @fn,'200: Validating postconditions';
      EXEC sp_log 1, @fn,'210: Validating  POST01: PropertySales table is populated'
      EXEC sp_assert_tbl_pop 'PropertySales';
      EXEC sp_assert_tbl_pop 'Agency';
      EXEC sp_assert_tbl_pop 'Contact';
      EXEC sp_log 1, @fn,'300: postconditions validated';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn,'999: leaving';
END
/*
EXEC sp_migrate_property_sales_data;
SELECT * FROM PropertySalesStaging;
SELECT * FROM Agency;
SELECT * FROM PropertySales_vw;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 12-SEP-2025
-- Description: 
-- Design:      EA:
-- Tests:       
--
-- Preconditions:
-- Postconditions: POST01: following tables are populated:
--    PropertySalesStaging
--    PropertySales
--    Agency         merge
--    Contacts       merge
--    Delegate       merge
--    Status         merge ??
-- =============================================
CREATE PROCEDURE [dbo].[sp_import_property_sales]
    @file            VARCHAR(100)
   ,@worksheet       VARCHAR(64)  --= 'Resort Sale'
   ,@range           VARCHAR(255) --= 'A1:Z93'
   ,@display_tables  BIT         = 1
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn           VARCHAR(35)   = N'sp_import_property_sales'
      ,@sql          NVARCHAR(4000)
      ,@schema       VARCHAR(40)
      ,@table_nm     VARCHAR(60)
      ,@fld_ty       VARCHAR(25)
      ,@fld_id       INT
      ,@fld_nm       VARCHAR(50)
      ,@len          INT
  ;
   BEGIN TRY
      EXEC sp_log 1, @fn, '000: starting:
   @file:[',@file,']
   ';
      -- Preconditions: PRE01: table must exist or exception 60001 'Table '<@q_table_nm> does not exist
   DELETE FROM PropertySalesStaging;
   SET @sql = CONCAT('
INSERT INTO PropertySalesStaging
(
[agency],[Type],[Area],[Delegate],[Status]
,[Sept_2],[Notes],[Quality],[Contact_nm],[role],[phone]
,[preferred_contact_method],[email],[WhatsApp]
,[viber],[facebook],[messenger],[website],[Address]
,[Notes_2],[Old_Notes],[date_1],[Actions_08_OCT],[Jan_16_2025]
,[Action_By_dt],[Replied],[History])
      SELECT 
[agency],[Type],[Area],[Delegate],[Status]
,[Sept 2],[Notes],[Quality],[Contact nm],[role],[phone]
,[preferred contact method],[email],[WhatsApp]
,[viber],[facebook],[messenger],[website],[Address]
,[Notes_2],[Old Notes],[date 1],[Actions 08-OCT],[Jan 16 2025]
,[Action By dt],[Replied],[History]
FROM OPENROWSET(''Microsoft.ACE.OLEDB.12.0'',
         ''Excel 12.0;Database=', @file, ';HDR=YES'',
         ''SELECT * FROM [', @worksheet, '$', @range, ']'')
   ');
      EXEC sp_log 1, @fn, '010: import sql:
', @sql;
      EXEC(@sql);
      IF @display_tables = 1
         SELECT * FROM PropertySalesStaging;
      EXEC sp_migrate_property_sales_data @display_tables;
      EXEC sp_log 1, @fn, '900: completed processing loop';
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 1, @fn, '999: leaving ok';
END
/*
EXEC test.test_078_sp_import_property_sales;
EXEC tSQLt.Run 'test.test_078_sp_import_property_sales';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Procedure:   <proc_nm>
-- Description: 
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:      
-- Tests:       
-- Author:      
-- Create date: 
-- =============================================
CREATE PROCEDURE [dbo].[usp_LoadData_FromStagingToFinal]
AS
BEGIN
    SET NOCOUNT ON;
    CREATE Table MainTable(id int, name VARCHAR(100), [Status] VARCHAR(20), Date_Added_Clean DATE);
    -- 1. Cleanse and insert the good data in a single, set-based operation
    INSERT INTO dbo.MainTable (
        [Name],
        [Phone_Clean], -- Cleaned version of the phone column
        [Status],
        [Date_Added_Clean] -- Properly typed date
    )
    SELECT
        -- Use TRIM and REPLACE to clean text
        TRIM([Name]) AS [Name],
        
        -- Cleanse phone numbers: remove non-numeric characters
        -- Use NULLIF to turn empty strings into NULLs
        NULLIF(REPLACE(REPLACE(REPLACE([phone], ' ', ''), '-', ''), '.', ''), '') AS Phone_Clean,
        
        -- Standardize status values with a CASE statement
        CASE
            WHEN UPPER(TRIM([Status])) IN ('OK', 'ACTIVE', 'ACCEPTED') THEN 'Active'
            WHEN UPPER(TRIM([Status])) IN ('DEAD', 'CLOSED', 'OS') THEN 'Closed'
            ELSE 'Unknown'
        END AS [Status],
        
        -- Safely attempt to convert a date. If it fails, it will be NULL.
        TRY_CAST([date_1] AS DATE) AS Date_Added_Clean
    FROM
        dbo.MainTable
    WHERE
        -- Optional: Add a WHERE clause to filter out obviously bad data *before* the insert
        -- This is not the error logging step, just pre-filtering.
        1 = 1;
   CREATE TABLE ImportErrorLog
   (
     ErrorTime    VARCHAR(100)
   , SourceTable  VARCHAR(100)
   , ColumnName   VARCHAR(100)
   , ProblemValue VARCHAR(100)
   , RejectedRow  VARCHAR(100)
   )
    -- 2. Now, find and log the rows that failed our quality checks (set-based logging!)
    INSERT INTO dbo.ImportErrorLog (ErrorTime, SourceTable, ColumnName, ProblemValue, RejectedRow)
    SELECT
        GETDATE(),
        'MainTable',
        'date_1',
        Date_Added_Clean,
        -- This is a simple way to log the entire problematic row as JSON
        (SELECT [Name], [Status], Date_Added_Clean FOR JSON PATH, WITHOUT_ARRAY_WRAPPER)
    FROM
        dbo.MainTable
    WHERE
        -- This condition finds rows where our date conversion failed
        TRY_CAST(Date_Added_Clean AS DATE) IS NULL
        AND Date_Added_Clean IS NOT NULL -- This ensures we don't log legitimate NULLs as errors
        -- Add other conditions for other columns here with OR...
END;
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2024
-- Description: Sets the @tst_num2 ctx this is the numeirc part of the sub test name
--              Key: fnGetCrntTstNum2Key()->N'Test num2'
-- Tests:       test.test_049_SetGetCrntTstValue
-- Oppo         test.fnGetCrntTstNum()
-- ==================================================================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_num2] @tst_num VARCHAR(3)
AS
BEGIN
   DECLARE
    @fn     VARCHAR(35) = 'sp_tst_set_crnt_tst_num2'
   ,@key    NVARCHAR(60);
   SET @key = test.fnGetCrntTstNum2Key();
   EXEC sp_log 0, @fn,'000: starting, fn: ', @fn, ' key:[', @key,'] @tst_num:[',@tst_num,']';
   EXEC sp_set_session_context @key, @tst_num;
   EXEC sp_log 0, @fn,'999: leaving';
END
/*
EXEC tSQLt.Run 'test.test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =================================================================
-- Author:      Terry watts
-- Create date: 03-DEC-2024
-- Description: sets the current sub test id
-- Tests:       test_049_SetGetCrntTstValue
-- =================================================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_sub_tst] @sub_tst VARCHAR(100)
AS
BEGIN
   DECLARE
      @fn   VARCHAR(35) = 'sp_tst_set_crnt_sub_tst'
     ,@key  VARCHAR(40) = test.fnGetCrntSubTstKey();
   ;
   EXEC sp_log 0, @fn, 'starting, @sub_tst:[',@sub_tst,']';
   EXEC sp_set_session_context @key, @sub_tst;
END
/*
EXEC tSQLt.Run 'test.test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: Setter
-- Tests: test.test_049_fnGetCrntTstValue
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_failed_tst_num] @val VARCHAR(60)
AS
BEGIN
   DECLARE @key NVARCHAR(60);
   SET @key = test.fnGetCrntFailedTstNumKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ====================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: Setter
-- Tests: test_049_SetGetCrntTstValue
-- ====================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_failed_tst_sub_num] @val VARCHAR(60)
AS
BEGIN
   DECLARE @key NVARCHAR(40);
   SET @key = test.fnGetCrntFailedTstSubNumKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =================================================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: setter: error_state
-- Tests: [test].[test 030 chkTestConfig]
-- =================================================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_err_st] @val INT
AS
BEGIN
   DECLARE @key VARCHAR(80) = test.fnGetCrntTstErrStKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===================================================
-- Author:      Terry Watts
-- Create date: 05-APR-2020
-- Description:
--  Encapsulates the test helper startup:
--  Prints a line to separate test output
--  Prints the EXEC sp_log 2, @fn, '01: starting msg
--  Sets the current test num context
--
--  Clears previous test state context:
--    crnt_tst_err_st         = 0
--    crnt_failed_tst_num     = NULL
--    crnt_failed_tst_sub_num = NULL
-- ===================================================
CREATE PROCEDURE [test].[sp_tst_hlpr_st]
    @sub_tst   VARCHAR(50) -- Like '010: Chk Rule 1' OR 'T010: Chk Rule 1'
   ,@params    VARCHAR(MAX) = NULL
AS
BEGIN
   DECLARE
    @fn        VARCHAR(35)   = N'sp_tst_hlpr_st'
   ,@fnHlrSt   VARCHAR(35)
   ,@NL        VARCHAR(2)    = NCHAR(13) + NCHAR(10)
   ,@line      VARCHAR(100)  = REPLICATE(N'=', 100)
   ,@prms_msg  VARCHAR(MAX)
   ,@tstRtn    VARCHAR(60)
   ,@subTstNum VARCHAR(10) --  = test.fnGetCrntTstNum2()
   ,@msg       VARCHAR(500)
   ,@ndx       INT
   ;
   SET @tstRtn = test.fnGetCrntTstFn();
   SET @ndx = iif(IsNumeric(SUBSTRING(@sub_tst, 1,1))=1, 1,2);
   SET @subTstNum = SUBSTRING(@sub_tst, @ndx, 3);
   EXEC test.sp_tst_set_crnt_tst_num2 @subTstNum;    -- Just the 3 digit test number
   SET @fnHlrSt = test.fnGetCrntTstHlprFn();
   SET @msg = CONCAT(@tstRtn,'.',@subTstNum);
   DELETE FROM AppLog;
   --------------------------------------------------
   -- Validate preconditions:
   --------------------------------------------------
   EXEC sp_assert_not_null_or_empty @sub_tst;
   --------------------------------------------------
   -- Process
   --------------------------------------------------
   SET @prms_msg = IIF(@params IS NOT NULL, CONCAT('params: ', @params), '');
   PRINT test.fnGetTstHdrFooterLine(1, 1, @msg, 'starting');
   EXEC sp_log 1, @fn,@fnHlrSt, '.', @tstRtn,'.',@subTstNum,': 000: starting', @nl, @params;
   EXEC test.sp_tst_set_crnt_sub_tst            @sub_tst;
   EXEC test.sp_tst_set_crnt_tst_err_st         0;
   EXEC test.sp_tst_set_crnt_failed_tst_num     NULL;
   EXEC test.sp_tst_set_crnt_failed_tst_sub_num NULL;
   --------------------------------------------------
   -- Process complete
   --------------------------------------------------
   EXEC sp_log 1, @fn,'999: leaving';
END
/*
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================
-- Author:      Terry Watts
-- Create date: 13-FEB-2021
-- Description: handles test failure
--
-- TESTS:
-- ================================================
CREATE PROCEDURE [test].[sp_tst_hlpr_hndl_failure]
 @msg1 VARCHAR(2000) = NULL
,@msg2 VARCHAR(2000) = NULL
,@msg3 VARCHAR(2000) = NULL
,@msg4 VARCHAR(2000) = NULL
AS
BEGIN
   DECLARE
      @fn       VARCHAR(35) = 'sp_tst_hlpr_hndl_failure'
     ,@tst_num2 VARCHAR(6) = test.fnGetCrntTstNum2()
     ,@msg      VARCHAR(500)
   ;
   SET NOCOUNT ON;
   -- Display applog up and down
   EXEC sp_log 0, @fn, '000: starting';
   EXEC sp_appLog_display;-- 0;
   --EXEC sp_appLog_display 1;
   SET @msg = 
      CONCAT
      (
        test.fnGetCrntTstFn(), '.', test.fnGetCrntSubTst()
       , @msg1
       ,iif(@msg1 IS NULL, '', CONCAT(' ', @msg2))
       ,iif(@msg2 IS NULL, '', CONCAT(' ', @msg3))
       ,iif(@msg3 IS NULL, '', CONCAT(' ', @msg4))
       );
   PRINT test.fnGetTstHdrFooterLine(1, 0, @msg, 'failed');
   EXEC sp_log 1, @fn, '900: leaving';
END
/*
EXEC tSQLt.Run 'test.test_013_sp_pop_AttendanceDates';
EXEC [test].[sp_tst_hlpr_st] 'MyFn', 'T010: MyFn'
EXEC test.sp_tst_hlpr_hndl_failure
PRINT test.fnGetCrntTstFn()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 06-FEB-2021
-- Description: Setter, clears the test pass count
-- Tests: [test].[test 030 chkTestConfig]
-- Returns: the cremented test count
-- =============================================
CREATE PROCEDURE [test].[sp_tst_incr_pass_cnt]
AS
BEGIN
   DECLARE @key NVARCHAR(60)
         , @cnt INT;
   SET @key = test.fnGetTstPassCntKey();
   SET @cnt = test.fnGetTstPassCnt() + 1;
   EXEC sp_set_session_context @key, @cnt;
   RETURN @cnt;
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =========================================================================
-- Author:      Terry Watts
-- Create date: 13-FEB-2021
-- Description: handles test success 
--                increments the test passed counter, logs (force) msg
--
-- CALLED BY:   sp_tst_gen_chk
-- TESTS:       hlpr_015_fnGetErrorMsg
-- =========================================================================
CREATE PROCEDURE [test].[sp_tst_hlpr_hndl_success]
AS
BEGIN
   DECLARE
       @fn            VARCHAR(35)   = N'sp_tst_hlpr_hndl_success'
      ,@test_pass_cnt INT
      ,@msg           VARCHAR(500)
   ;
 -- Passed so increment the test count
   EXEC @test_pass_cnt = test.sp_tst_incr_pass_cnt;
   SET @msg = CONCAT(test.fnGetCrntTstFn(), '.', test.fnGetCrntTstNum2());
   PRINT test.fnGetTstHdrFooterLine(0, 0, @msg, 'passed');
END
/*
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=======================================================================================
-- Author:           Terry Watts
-- Create date:      12-Jun-2025
-- Rtn:              test.hlpr_068_sp_crt_pop_table
-- Description: test helper for the dbo.sp_crt_pop_table routine tests 
--
-- Tested rtn description:
-- Create and populate a table from a data file
--
-- Design:      EA: Model.Use Case Model.Create and populate a table from a data file
-- Define the import data file path
-- Table name = file name
-- Reads the header for the column names
-- Create a table with table name, columns = field names, type = text
-- Create a staging table
-- Create a format file using BCP and the table
-- Generate the import routine using the table and the format file
--
-- Parameters:
--    @file_path     VARCHAR(500) -- the import data file path
--
-- tests: test_068_sp_crt_pop_table
-- Test strategy:
-- Test 01. Check no error occurred
-- Test 02: Check the table exists
-- Test 03: Check the columns match the file columns
-- Test 04: Check the data matches
-- Test 04.01: check the row count of the table matches that of the file
-- Test 04.02: check the first row all columns
-- Test 04.03: check the last row all columns
--=======================================================================================
CREATE PROCEDURE [test].[hlpr_068_sp_crt_pop_table]
    @tst_num            VARCHAR(50)
   ,@display_tables     BIT
   ,@inp_file_path      VARCHAR(250)
   ,@inp_format_file    VARCHAR(500)= NULL
   ,@inp_sep            VARCHAR(6)
   ,@inp_codepage       INT
   ,@inp_display_tables BIT
   ,@exp_row_cnt        INT             = NULL
   ,@exp_ex_num         INT             = NULL
   ,@exp_ex_msg         VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)    = N'hlpr_068_sp_crt_pop_table'
   ,@error_msg          VARCHAR(1000)
   ,@NL                 CHAR = CHAR(13)
   ,@tab                CHAR = CHAR(9)
   ,@act_row_cnt        INT
   ,@act_RC             INT
   ,@act_ex_num         INT
   ,@act_ex_msg         VARCHAR(500)
   ,@act_tbl_cols       VARCHAR(8000)
   ,@exp_file_cols      VARCHAR(8000)
   ,@act_file_cols      VARCHAR(8000)
   ,@exp_table_nm       VARCHAR(60 )    = NULL
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      SET @exp_table_nm = dbo.fnGetFileNameFromPath(@inp_file_path, 0); -- 0:ignore extension
      EXEC sp_log 1, @fn ,' starting
tst_num           :[', @tst_num           ,']
display_tables    :[', @display_tables    ,']
inp_file_path     :[', @inp_file_path     ,']
@inp_format_file  :[', @inp_format_file   ,']
inp_sep           :[', @inp_sep           ,']
inp_codepage      :[', @inp_codepage      ,']
inp_display_tables:[', @inp_display_tables,']
@exp_table_nm     :[', @exp_table_nm      ,']
exp_row_cnt       :[', @exp_row_cnt       ,']
ex_num            :[', @exp_ex_num        ,']
ex_msg            :[', @exp_ex_msg        ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.sp_crt_pop_table';
            ------------------------------------------------------------
            EXEC @act_RC = dbo.sp_crt_pop_table
                @file_path       = @inp_file_path
               ,@sep             = @inp_sep
               ,@format_file     = @inp_format_file
               ,@codepage        = @inp_codepage
               ,@display_tables  = @inp_display_tables
               ;
  
            SELECT @act_row_cnt = @@ROWCOUNT;
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.sp_crt_pop_table';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '075: running tests   ';
         -- Test 01. Check no error occurred - implicit with the exception handler here
         -- Test 02: Check the table exists
         EXEC sp_assert_tbl_exists @exp_table_nm;
         -- Test 03: Check the columns match the file columns
         -- Get the table cols
         SELECT @act_tbl_cols = string_agg( column_name, ',') FROM dbo.fnGetTableColumns(@exp_table_nm, NULL);
         -- Get the file cols
         EXEC sp_log 2, @fn, '085: Get the file cols, @inp_file_path:[',@inp_file_path,']';
         TRUNCATE TABLE GenericStaging;
         --RETURN;
         EXEC @act_row_cnt = sp_import_txt_file
             @table           = 'GenericStaging'
            ,@file            = @inp_file_path
            ,@folder          = NULL
            ,@first_row       = 1
            ,@last_row        = 1
            ,@field_terminator= @NL
            ,@view            = 'ImportGenericStaging_vw'
            ,@codepage        = @inp_codepage
            ,@display_table   = 0
         ;
         EXEC tSQLt.AssertEquals 1, @act_row_cnt, '090 exp 1 hdr row';
         SELECT @act_file_cols = staging FROM GenericStaging;
         EXEC sp_log 2, @fn, '095: checking header cols in GenericStaging',@NL
               , '@act_file_cols:',@act_file_cols,@NL
               , '@act_file_cols:',@act_file_cols;
         SELECT @act_file_cols = REPLACE(@act_file_cols, @tab, ',');
         EXEC sp_log 2, @fn, '100: checking header cols in GenericStaging',@NL
               , '@act_file_cols:',@act_file_cols,@NL
               , '@act_tbl_cols :',@act_tbl_cols;
         EXEC tSQLt.AssertEquals @act_file_cols, @act_tbl_cols, '105: file/tbl col names match?', @detailed_tst=1;
         EXEC sp_log 2, @fn, '102: TRUNCATE TABLE GenericStaging';
         TRUNCATE TABLE GenericStaging;
         -- Test 04: Check the data matches
         -- Read the file data rows into GenericStaging (ex hdr row)
         EXEC sp_log 2, @fn, '105: Read the file data rows into GenericStaging file: ',sp_import_txt_file;
         EXEC @exp_row_cnt = sp_import_txt_file
             @table           = 'GenericStaging'
            ,@file            = @inp_file_path
            ,@folder          = NULL
            ,@first_row       = 2
--            ,@last_row        = 100
            ,@field_terminator= @NL
            ,@view            = 'ImportGenericStaging_vw'
            ,@format_file     = @inp_format_file
            ,@codepage        = @inp_codepage
            ,@display_table   = 0
         ;
         -- Test 04.01: check the row count of the table matches that of the file
         EXEC @act_row_cnt = sp_GetTxtFileLineCount @inp_file_path;
         EXEC tSQLt.AssertEquals @exp_row_cnt, @act_row_cnt,'110 row_cnt';
         -- Test 04.02: check the first row all columns
         SELECT @exp_file_cols = staging FROM (SELECT TOP 1 staging FROM GenericStaging) A;
         EXEC sp_aggregate_row_to_string @exp_table_nm,'ID = 1',',', @act_file_cols OUTPUT;
         EXEC sp_log 2, @fn, '111: ', @NL, '@exp_file_cols:[', @exp_file_cols,']', @NL
         ,'@act_file_cols:[',@act_file_cols,']'
        ;
         EXEC tSQLt.AssertEquals @exp_file_cols, @act_file_cols, '115 first row exp/act';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, 'Caught exception';
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_068_sp_crt_pop_table';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=================================================================
-- Author:           Terry Watts
-- Create date:      13-Jun-2025
-- Rtn:              test.hlpr_069_fnCrtTblSql
-- Description: test helper for the dbo.fnCrtTblSql routine tests 
--
-- Tested rtn description:
-- creates the SQL to create a table
--              based on the input string
--              All fields are VARCHAR(MAX)
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    returns creat table SQL
--
-- Tests:
--=================================================================
CREATE PROCEDURE [test].[hlpr_069_fnCrtTblSql]
    @tst_num      VARCHAR(50)
   ,@inp_tbl_nm   VARCHAR(60)
   ,@inp_fields   VARCHAR(8000)
   ,@exp_sql      VARCHAR(8000)   = NULL
   ,@exp_ex_num   INT             = NULL
   ,@exp_ex_msg   VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)    = N'hlpr_069_fnCrtTblSql'
   ,@error_msg    VARCHAR(1000)
   ,@act_ex_num   INT            
   ,@act_ex_msg   VARCHAR(500)   
   ,@act_sql      VARCHAR(8000)   = @exp_sql
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num    :[', @tst_num    ,']
inp_tbl_nm :[', @inp_tbl_nm ,']
inp_fields :[', @inp_fields ,']
exp_sql    :[', @exp_sql,']
ex_num     :[', @exp_ex_num ,']
ex_msg     :[', @exp_ex_msg ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.fnCrtTblSql';
            SET @act_sql = dbo.fnCrtTblSql(@inp_tbl_nm, @inp_fields);
            --EXEC spCrtTblSql @inp_tbl_nm, @inp_fields, @act_sql OUT;
            EXEC sp_log 1, @fn, '020: returned from dbo.fnCrtTblSql,
@act_sql:',@act_sql;
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_sql IS NOT NULL EXEC tSQLt.AssertEquals @exp_sql, @act_sql,'083 sql', @detailed_tst=1,@cs_sens_cmp=1;
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.Run 'test.test_069_fnCrtTblSql';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--==============================================================================
-- Author:           Terry Watts
-- Create date:      05-Sep-2025
-- Rtn:              test.hlpr_070_fnIsValidTableColumnName
-- Description: test helper for the dbo.fnIsValidTableColumnName routine tests 
--
-- Tested rtn description:
--
-- Design:
-- Tests:
-- Author:
-- Create date:
--==============================================================================
CREATE PROCEDURE [test].[hlpr_070_fnIsValidTableColumnName]
    @tst_num           VARCHAR(50)
   ,@inp_field_nm      VARCHAR(64)
   ,@exp_out_val       BIT             = NULL
   ,@exp_ex_num        INT             = NULL
   ,@exp_ex_msg        VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                      VARCHAR(35)    = N'hlpr_070_fnIsValidTableColumnName'
   ,@error_msg               VARCHAR(1000)
   ,@act_ex_num              INT            
   ,@act_ex_msg              VARCHAR(500)   
   ,@act_out_val             BIT             = @exp_out_val
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num     :[', @tst_num     ,']
inp_field_nm:[', @inp_field_nm,']
exp_out_val :[', @exp_out_val ,']
ex_num      :[', @exp_ex_num  ,']
ex_msg      :[', @exp_ex_msg  ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.fnIsValidTableColumnName';
            ------------------------------------------------------------
            SET @act_out_val = dbo.fnIsValidTableColumnName
            (
               @inp_field_nm
            );
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.fnIsValidTableColumnName';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_out_val IS NOT NULL EXEC tSQLt.AssertEquals @exp_out_val, @act_out_val,'083 out_val';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_070_fnIsValidTableColumnName';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--===================================================================
-- Author:           Terry Watts
-- Create date:      05-Sep-2025
-- Rtn:              test.hlpr_071_sp_drop_table
-- Description: test helper for the dbo.sp_drop_table routine tests 
--
-- Tested rtn description:
-- Drops a table if it exists
-- Design:
-- Tests:
--
-- PRECONDITIONS:
-- PRE 01 @tbl_nm must be specified NOT NULL or EMPTY Checked
--
-- POSTCONDITIONS:
-- POST01: table does not exist
--===================================================================
CREATE PROCEDURE [test].[hlpr_071_sp_drop_table]
    @tst_num                 VARCHAR(50)
   ,@display_tables          BIT
   ,@inp_q_table_nm          VARCHAR(40)
   ,@exp_row_cnt             INT             = NULL
   ,@exp_rc                  INT             = NULL
   ,@exp_ex_num              INT             = NULL
   ,@exp_ex_msg              VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                      VARCHAR(35)    = N'hlpr_071_sp_drop_table'
   ,@error_msg               VARCHAR(1000)
   ,@act_row_cnt             INT            
   ,@act_RC                  INT            
   ,@act_ex_num              INT            
   ,@act_ex_msg              VARCHAR(500)   
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num           :[', @tst_num           ,']
display_tables    :[', @display_tables    ,']
inp_q_table_nm    :[', @inp_q_table_nm    ,']
exp_row_cnt       :[', @exp_row_cnt       ,']
exp_rc            :[', @exp_rc            ,']
exp_RC            :[', @exp_RC            ,']
ex_num            :[', @exp_ex_num        ,']
ex_msg            :[', @exp_ex_msg        ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.sp_drop_table';
            ------------------------------------------------------------
            EXEC @act_RC = dbo.sp_drop_table
                @q_table_nm      = @inp_q_table_nm
               ;
  
            SELECT @act_row_cnt = @@ROWCOUNT;
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.sp_drop_table';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_row_cnt IS NOT NULL EXEC tSQLt.AssertEquals @exp_row_cnt, @act_row_cnt,'087 row_cnt';
         IF @exp_RC      IS NOT NULL EXEC tSQLt.AssertEquals @exp_RC     , @act_RC     ,'088 RC';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_071_sp_drop_table';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=====================================================================
-- Author:           Terry Watts
-- Create date:      05-Sep-2025
-- Rtn:              test.hlpr_072_fnWrapFieldName
-- Description: test helper for the dbo.fnWrapFieldName routine tests 
--
-- Tested rtn description:
--
-- Design:
-- Tests:
--=====================================================================
CREATE PROCEDURE [test].[hlpr_072_fnWrapFieldName]
    @tst_num          VARCHAR(50)
   ,@inp_fld_nm       VARCHAR(64)
   ,@exp_out_val      VARCHAR(64)     = NULL
   ,@exp_ex_num       INT             = NULL
   ,@exp_ex_msg       VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                      VARCHAR(35)    = N'hlpr_072_fnWrapFieldName'
   ,@error_msg               VARCHAR(1000)
   ,@act_ex_num              INT            
   ,@act_ex_msg              VARCHAR(500)   
   ,@act_out_val             VARCHAR(64)     = @exp_out_val
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num    :[', @tst_num    ,']
inp_fld_nm :[', @inp_fld_nm ,']
exp_out_val:[', @exp_out_val,']
ex_num     :[', @exp_ex_num ,']
ex_msg     :[', @exp_ex_msg ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.fnWrapFieldName';
            ------------------------------------------------------------
            SET @act_out_val = dbo.fnWrapFieldName
            (
               @inp_fld_nm
            );
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.fnWrapFieldName';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_out_val IS NOT NULL EXEC tSQLt.AssertEquals @exp_out_val, @act_out_val,'083 out_val';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_072_fnWrapFieldName';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=========================================================================
-- Author:           Terry Watts
-- Create date:      16-Jun-2025
-- Rtn:              test.hlpr_073_fnDeLimitIdentifier
-- Description: test helper for the dbo.fnDeLimitIdentifier routine tests 
--
-- Tested rtn description:
-- delimits identifier  if necessary
-- Design:
-- Tests:
--=========================================================================
CREATE PROCEDURE [test].[hlpr_073_fnDeLimitIdentifier]
    @tst_num          VARCHAR(50)
   ,@inp_q_id         VARCHAR(60)
   ,@exp_out_val      VARCHAR(60)     = NULL
   ,@exp_ex_num       INT             = NULL
   ,@exp_ex_msg       VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                      VARCHAR(35)    = N'hlpr_073_fnDeLimitIdentifier'
   ,@error_msg               VARCHAR(1000)
   ,@act_ex_num              INT            
   ,@act_ex_msg              VARCHAR(500)   
   ,@act_out_val             VARCHAR(60)     = @exp_out_val
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num    :[', @tst_num    ,']
inp_q_id   :[', @inp_q_id   ,']
exp_out_val:[', @exp_out_val,']
ex_num     :[', @exp_ex_num ,']
ex_msg     :[', @exp_ex_msg ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.fnDeLimitIdentifier';
            ------------------------------------------------------------
            SET @act_out_val = dbo.fnDeLimitIdentifier
            (
               @inp_q_id
            );
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.fnDeLimitIdentifier';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         --IF @exp_out_val IS NOT NULL 
         EXEC tSQLt.AssertEquals @exp_out_val, @act_out_val,'083 out_val';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_073_fnDeLimitIdentifier';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--===============================================================================
-- Author:           Terry Watts
-- Create date:      09-Sep-2025
-- Rtn:              test.hlpr_074_sp_crt_pop_property_sales
-- Description: test helper for the dbo.sp_crt_pop_property_sales routine tests
--
-- Tested rtn description:
-- Clean populates the Property sales tables
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:
-- Tests:
--===============================================================================
CREATE PROCEDURE [test].[hlpr_074_sp_crt_pop_property_sales]
    @tst_num            VARCHAR(50)
   ,@inp_file_path      VARCHAR(250)
   ,@inp_table_nm       VARCHAR(50)     = NULL
   ,@display_tables     BIT             = NULL
   ,@exp_row_cnt        INT             = NULL
   ,@exp_rc             INT             = NULL
   ,@exp_ex_num         INT             = NULL
   ,@exp_ex_msg         VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                 VARCHAR(35)    = N'hlpr_074_sp_crt_pop_property_sales'
   ,@error_msg          VARCHAR(1000)
   ,@act_row_cnt        INT
   ,@act_RC             INT
   ,@act_ex_num         INT
   ,@act_ex_msg         VARCHAR(500)
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num           :[', @tst_num           ,']
inp_file_path     :[', @inp_file_path     ,']
display_tables    :[', @display_tables    ,']
exp_row_cnt       :[', @exp_row_cnt       ,']
exp_rc            :[', @exp_rc            ,']
exp_RC            :[', @exp_RC            ,']
ex_num            :[', @exp_ex_num        ,']
ex_msg            :[', @exp_ex_msg        ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.sp_crt_pop_property_sales';
            ------------------------------------------------------------
            EXEC @act_RC = dbo.sp_crt_pop_property_sales
                @file_path       = @inp_file_path
               ,@display_tables  = @display_tables
               ;
            SELECT @act_row_cnt = @@ROWCOUNT;
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.sp_crt_pop_property_sales';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_row_cnt IS NOT NULL EXEC tSQLt.AssertEquals @exp_row_cnt, @act_row_cnt,'089 row_cnt';
         IF @exp_RC      IS NOT NULL EXEC tSQLt.AssertEquals @exp_RC     , @act_RC     ,'090 RC';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.Run 'test.test_074_sp_crt_pop_property_sales';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--==========================================================================
-- Author:           Terry Watts
-- Create date:      17-Jun-2025
-- Rtn:              test.hlpr_074_sp_infer_field_types
-- Description: test helper for the dbo.sp_infer_field_types routine tests 
--
-- Tested rtn description:
-- infers the field types froma staging table
--    based on its data
--
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:
-- Tests:
--==========================================================================
CREATE PROCEDURE [test].[hlpr_075_sp_infer_field_types]
    @tst_num                 VARCHAR(50)
   ,@display_tables          BIT
   ,@inp_q_table_nm          VARCHAR(100)
   ,@exp_row_cnt             INT             = NULL
   ,@exp_rc                  INT             = NULL
   ,@exp_ex_num              INT             = NULL
   ,@exp_ex_msg              VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                      VARCHAR(35)    = N'hlpr_075_sp_infer_field_types'
   ,@error_msg               VARCHAR(1000)
   ,@act_row_cnt             INT            
   ,@act_RC                  INT            
   ,@act_ex_num              INT            
   ,@act_ex_msg              VARCHAR(500)   
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num           :[', @tst_num           ,']
display_tables    :[', @display_tables    ,']
inp_q_table_nm    :[', @inp_q_table_nm    ,']
exp_row_cnt       :[', @exp_row_cnt       ,']
exp_rc            :[', @exp_rc            ,']
exp_RC            :[', @exp_RC            ,']
ex_num            :[', @exp_ex_num        ,']
ex_msg            :[', @exp_ex_msg        ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.sp_infer_field_types';
            ------------------------------------------------------------
            EXEC @act_RC = dbo.sp_infer_field_types
                @q_table_nm      = @inp_q_table_nm
               ;
            IF @display_tables = 1
               SELECT * FROM FieldInfo;
            SELECT @act_row_cnt = @@ROWCOUNT;
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.sp_infer_field_types';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_row_cnt IS NOT NULL EXEC tSQLt.AssertEquals @exp_row_cnt, @act_row_cnt,'087 row_cnt';
         IF @exp_RC      IS NOT NULL EXEC tSQLt.AssertEquals @exp_RC     , @act_RC     ,'088 RC';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.Run 'test.test_075_sp_infer_field_types';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =======================================================================
-- Author:           Terry Watts
-- Create date:      17-Jun-2025
-- Rtn:              test.hlpr_075_fnCrtFldNotNullSql
-- Description: test helper for the dbo.fnCrtFldNotNullSql routine tests
--
-- Tested rtn description:
--
-- =======================================================================
CREATE PROCEDURE [test].[hlpr_076_fnCrtFldNotNullSql]
    @tst_num        VARCHAR(50)
   ,@inp_q_table_nm VARCHAR(60)
   ,@inp_fld_nm     VARCHAR(40)
   ,@inp_ty         VARCHAR(15)
   ,@exp_sql        VARCHAR(4000)   = NULL
   ,@exp_ex_num     INT             = NULL
   ,@exp_ex_msg     VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn             VARCHAR(35)    = N'hlpr_076_fnCrtFldNotNullSql'
   ,@error_msg      VARCHAR(1000)
   ,@act_ex_num     INT
   ,@act_ex_msg     VARCHAR(500)
   ,@act_sql        VARCHAR(4000)   = @exp_sql
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num       :[', @tst_num       ,']
inp_q_table_nm:[', @inp_q_table_nm,']
inp_fld_nm    :[', @inp_fld_nm    ,']
inp_ty        :[', @inp_ty        ,']
exp_sql       :[', @exp_sql       ,']
ex_num        :[', @exp_ex_num    ,']
ex_msg        :[', @exp_ex_msg    ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.fnCrtFldNotNullSql';
            ------------------------------------------------------------
            SET @act_sql = dbo.fnCrtFldNotNullSql
            (
               @inp_q_table_nm, @inp_fld_nm, @inp_ty
            );
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.fnCrtFldNotNullSql
@act_sql:
',@act_sql
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_sql IS NOT NULL EXEC tSQLt.AssertEquals @exp_sql, @act_sql,'083 sql';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_076_fnCrtFldNotNullSql';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=========================================================================
-- Author:           Terry Watts
-- Create date:      09-Sep-2025
-- Rtn:              test.hlpr_077_fnNameNeedsBrackets
-- Description: test helper for the dbo.fnNameNeedsBrackets routine tests 
--
-- Tested rtn description:
-- returns 1 if name needs brackets.
--    i.e. is a reserver word or has some wierd characters
-- Design:
-- Tests:
--=========================================================================
CREATE PROCEDURE [test].[hlpr_077_fnNameNeedsBrackets]
    @tst_num          VARCHAR(50)
   ,@inp_name         VARCHAR(30)
   ,@exp_out_val      BIT             = NULL
   ,@exp_ex_num       INT             = NULL
   ,@exp_ex_msg       VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                      VARCHAR(35)    = N'hlpr_077_fnNameNeedsBrackets'
   ,@error_msg               VARCHAR(1000)
   ,@act_ex_num              INT            
   ,@act_ex_msg              VARCHAR(500)   
   ,@act_out_val             BIT             = @exp_out_val
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num    :[', @tst_num    ,']
inp_name   :[', @inp_name   ,']
exp_out_val:[', @exp_out_val,']
ex_num     :[', @exp_ex_num ,']
ex_msg     :[', @exp_ex_msg ,']
';
      -- SETUP: ??
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.fnNameNeedsBrackets';
            ------------------------------------------------------------
            SET @act_out_val = dbo.fnNameNeedsBrackets
            (
               @inp_name
            );
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.fnNameNeedsBrackets';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_out_val IS NOT NULL EXEC tSQLt.AssertEquals @exp_out_val, @act_out_val,'083 out_val';
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_077_fnNameNeedsBrackets';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--==============================================================================
-- Author:           Terry Watts
-- Create date:      12-Sep-2025
-- Rtn:              test.hlpr_078_sp_import_property_sales
-- Description: test helper for the dbo.sp_import_property_sales routine tests 
--
-- Tested rtn description:
--
-- Design:      EA:
-- Tests:
--
-- Preconditions:
-- Postconditions: POST01: following tabnle are populated:
--    PropertySalesStaging
--    PropertySales
--    Agency         merge
--    Contacts       merge
--    Delegate       merge
--    Status         merge ??
--==============================================================================
CREATE PROCEDURE [test].[hlpr_078_sp_import_property_sales]
    @tst_num               VARCHAR(50)
   ,@display_tables        BIT
   ,@inp_file              VARCHAR(500)
   ,@inp_worksheet         VARCHAR(64)
   ,@inp_range             VARCHAR(255)
   ,@inp_agency_nm         VARCHAR(255)    = NULL
   ,@exp_agency_phone      VARCHAR(255)    = NULL
   ,@exp_row_cnt           INT             = NULL
   ,@exp_agency_cnt        INT             = NULL
   ,@exp_contact_cnt       INT             = NULL
   ,@exp_contactAgency_cnt INT             = NULL
   ,@exp_rc                INT             = NULL
   ,@exp_ex_num            INT             = NULL
   ,@exp_ex_msg            VARCHAR(500)    = NULL
AS
BEGIN
   DECLARE
    @fn                    VARCHAR(35)    = N'hlpr_078_sp_import_property_sales'
   ,@error_msg             VARCHAR(1000)
   ,@act_row_cnt           INT            
   ,@act_contactAgency_cnt INT             = NULL
   ,@act_agency_cnt        INT             = NULL
   ,@act_contact_cnt       INT             = NULL
   ,@act_RC                INT            
   ,@act_ex_num            INT            
   ,@act_ex_msg            VARCHAR(500)
   ,@act_agency_phone      VARCHAR(250)
   BEGIN TRY
      EXEC test.sp_tst_hlpr_st @tst_num;
      EXEC sp_log 1, @fn ,' starting
tst_num           :[', @tst_num           ,']
display_tables    :[', @display_tables    ,']
inp_file          :[', @inp_file          ,']
@inp_worksheet    :[', @inp_worksheet     ,']
@inp_range        :[', @inp_range         ,']
exp_row_cnt       :[', @exp_row_cnt       ,']
exp_rc            :[', @exp_rc            ,']
exp_RC            :[', @exp_RC            ,']
ex_num            :[', @exp_ex_num        ,']
ex_msg            :[', @exp_ex_msg        ,']
';
      -- SETUP: ??
      DELETE FROM PropertySalesStaging;
      DELETE FROM PropertySales;
      DELETE FROM ContactAgency
      DELETE FROM Agency;
      DELETE FROM Contact;
      WHILE 1 = 1
      BEGIN
         BEGIN TRY
            EXEC sp_log 1, @fn, '010: Calling the tested routine: dbo.sp_import_property_sales';
            ------------------------------------------------------------
            EXEC @act_RC = dbo.sp_import_property_sales
                @file      = @inp_file
               ,@worksheet = @inp_worksheet
               ,@range     = @inp_range    
               ;
  
            SELECT @act_row_cnt           = COUNT(*) FROM PropertySalesStaging;
            SELECT @act_agency_cnt        = COUNT(*) FROM Agency;
            SELECT @act_contact_cnt       = COUNT(*) FROM Contact;
            SELECT @act_contactAgency_cnt = COUNT(*) FROM ContactAgency;
            ------------------------------------------------------------
            EXEC sp_log 1, @fn, '020: returned from dbo.sp_import_property_sales:
@act_row_cnt:           [', @act_row_cnt           ,']
@act_agency_cnt:        [', @act_agency_cnt        ,']
@act_contact_cnt:       [', @act_contact_cnt       ,']
@act_contactAgency_cnt: [', @act_contactAgency_cnt ,']
';
            IF @exp_ex_num IS NOT NULL OR @exp_ex_msg IS NOT NULL
            BEGIN
               EXEC sp_log 4, @fn, '030: oops! Expected exception was not thrown';
               THROW 51000, ' Expected exception was not thrown', 1;
            END
         END TRY
         BEGIN CATCH
            SET @act_ex_num = ERROR_NUMBER();
            SET @act_ex_msg = ERROR_MESSAGE();
            EXEC sp_log 1, @fn, '040: caught  exception: ', @act_ex_num, ' ',      @act_ex_msg;
            EXEC sp_log 1, @fn, '050: check ex num: exp: ', @exp_ex_num, ' act: ', @act_ex_num;
            IF @exp_ex_num IS NULL AND @exp_ex_msg IS NULL
            BEGIN
               EXEC sp_log 4, @fn, '060: an unexpected exception was raised';
               THROW;
            END
            ------------------------------------------------------------
            -- ASSERTION: if here then expected exception
            ------------------------------------------------------------
            IF @exp_ex_num IS NOT NULL EXEC tSQLt.AssertEquals      @exp_ex_num, @act_ex_num, 'ex_num mismatch';
            IF @exp_ex_msg IS NOT NULL EXEC tSQLt.AssertIsSubString @exp_ex_msg, @act_ex_msg, 'ex_msg mismatch';
            
            EXEC sp_log 2, @fn, '070 test# ',@tst_num, ': exception test PASSED;'
            BREAK
         END CATCH
         -- TEST:
         EXEC sp_log 2, @fn, '080: running tests   ';
         IF @exp_row_cnt            IS NOT NULL EXEC tSQLt.AssertEquals @exp_row_cnt          , @act_row_cnt          ,'081 row_cnt';
         IF @exp_agency_cnt         IS NOT NULL EXEC tSQLt.AssertEquals @exp_agency_cnt       , @act_agency_cnt       ,'082 agency_cnt';
         IF @exp_contact_cnt        IS NOT NULL EXEC tSQLt.AssertEquals @exp_contact_cnt      , @act_contact_cnt      ,'083 contact_cnt';
         IF @exp_contactAgency_cnt  IS NOT NULL EXEC tSQLt.AssertEquals @exp_contactAgency_cnt, @act_contactAgency_cnt,'084 contactAgency_cnt';
         IF @exp_RC                 IS NOT NULL EXEC tSQLt.AssertEquals @exp_RC               , @act_RC               ,'085 RC';
         -- Agency phone;
         IF @inp_agency_nm IS NOT NULL
         BEGIN
            SELECT @act_agency_phone = phone from Agency where agency_nm = @inp_agency_nm;
            EXEC tSQLt.AssertEquals @exp_agency_phone      , @act_agency_phone      ,'086 agency_phone';
         END
         -- ContactAgency
         -- Contact;
         ------------------------------------------------------------
         -- Passed tests
         ------------------------------------------------------------
         BREAK
      END --WHILE
      -- CLEANUP: ??
      EXEC sp_log 1, @fn, '990: all subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC test.sp_tst_hlpr_hndl_failure;
      THROW;
   END CATCH
   EXEC test.sp_tst_hlpr_hndl_success;
END
/*
EXEC tSQLt.Run 'test.test_078_sp_import_property_sales';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================
-- Author:      Terry Watts
-- Create date: 12-NOV-2023
-- Description: returns the parameters
-- e.g. sysobjects xtype code 
-- ======================================================
CREATE VIEW [dbo].[SysRtnPrms_vw]
AS 
SELECT
    SCHEMA_NAME( schema_id)            AS schema_nm
   ,OBJECT_NAME(sap.object_id)         AS rtn_nm
   ,sap.name                           AS prm_nm
   ,parameter_id                       AS ordinal
   ,UPPER(TYPE_NAME(system_type_id))   AS ty_nm
   ,IIF( TYPE_NAME(system_type_id) IN ('VARCHAR', 'NVARCHAR', 'NTEXT')
      ,CONCAT( UPPER(TYPE_NAME(system_type_id)), '('
              ,iif
               ( system_type_id in (167, 231)
                ,iif(max_length= -1, 4000,max_length/2)
                , max_length
               )
              ,')'
             ) -- end concat
      ,dbo.fnGetFullTypeName(TYPE_NAME(system_type_id), max_length/2)--TYPE_NAME(system_type_id)
      )          AS ty_nm_full
   ,system_type_id                     AS ty_id
   ,iif
    (
       system_type_id in (231)
      ,max_length/2, max_length
    ) AS ty_len
    , IIF(TYPE_NAME(system_type_id) IN ('VARCHAR', 'NVARCHAR', 'NCHAR','CHAR','NTEXT'), 1, 0) AS is_chr_ty
   ,is_output
   ,is_nullable
   ,has_default_value
   ,default_value
   ,dbo.fnGetTyNmFrmTyCode([type])     AS rtn_ty_nm
   ,[type]                             AS rtn_ty_code
FROM sys.all_parameters sap
     JOIN sys.all_objects so ON sap.object_id=so.object_id
 ;
/*
SELECT * FROM SysRtnPrms_vw WHERE rtn_nm = 'sp_ImportAttendanceGMeet2Staging';
SELECT  * FROM paramsVw where param_nm ='' -- Scalar function, CLR scalar function return value
SELECT TOP 100 * FROM sys.all_parameters sap JOIN sys.all_objects so ON sap.object_id=so.object_id;
SELECT top 10 * FROM sys.sysobjects
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [test].[sp_first_result_col_info](
	[name] [varchar](50) NULL,
	[column_ordinal] [int] NULL,
	[is_nullable] [bit] NULL,
	[system_type_name] [varchar](50) NULL,
	[error_message] [varchar](300) NULL
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================================================================================================
-- Author:      Terry Watts
-- Create date: 17-DEC-2021
-- Description: populates Test.ParamDetails table with the tested rtn paramer details
--
-- Responsibilities;
-- R01: fully populate the ParamDetails table
-- R02: update the RtnDetails table max_prm_len field with the max parameter name length
-- R03: update the RtnDetails table sc_fn_ret_ty field with the the scalar fn return type - if tstd rtn is a scalar function
--
--ALGORITHM:
-- Clear the test.Param TabIe
-- Add the tst_num parameter setting type = SYS
-- Get the rtn parameters
-- Add the rtn parameters as inp if a Scalar FN ignore the is_result parameter
-- Add an exp row cnt INT setting type = TST
--
-- If Table fn:
--    Add a search key to identify the row to be checked etting type = TST
--    Get the tn ouput table cols
--    Add an exp row cnt INT setting type = TST
--    Add a search key to identify the row to be checked setting type = TST
--    For each Col: add the param as exp_x setting type = EXP
--
-- If Scalar fn:
--    Add the is result parameter as exp_result ty: EXP
--
-- PRECONDITIONS:
--    Test.RtnDetails pop'd 
--
-- POST CONDITIONS:
-- POST 01: the following ParamDetails fields not null: ordinal, param_nm, type_nm, parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception
-- POST 02: if routine not found then exception 70003, 'Routine <@schema_nm.@rtn_nm> was not found'
-- POST 03: fully populates the ParamDetails table or exception <TBA> <TBA>
-- POST 04: updates the RtnDetails table max_prm_len field or exception <TBA> <TBA>
-- POST 05: updates the RtnDetails table scalar fn return type field or exception <TBA> <TBA>
--
-- NOTES:
-- 1. The MS routines and views to get default parameter values DONT WORK - no suprise there then
--
-- CALLED BY: test.sp_get_rtn_details
--
-- Tests: test_042_sp_pop_param_details
--
-- Changes:
-- 240403: Changed to use INFORMATION_SCHEMA.PARAMETERS and dbo.SysRtnPrms_vw
--          not bother with comments
--          Table is now fixed as test.ParamTable
-- 240415: redesign, added several fields to make it eassier to use latter in the test rtn creation
-- 240503: added sc_fn_ret_ty to test.RtnParameters to hold the scalar fn return type - if tstd rtn is a scalar function
-- 241205: removed @tst_key param
-- =============================================================================================================================
CREATE PROCEDURE [test].[sp_pop_param_details]
    @throw_if_err    BIT      = 1
   ,@display_tables  BIT      = 0
AS
BEGIN
   DECLARE
     @fn             VARCHAR(35)   = 'sp_pop_param_details'
    ,@qrn            VARCHAR(120)
    ,@schema_nm      VARCHAR(25)
    ,@rtn_nm         VARCHAR(50)
    ,@rtn_ty_code    VARCHAR(2)
    ,@ndx            INT            = 1
    ,@row_cnt        INT
    ,@max_prm_len    INT
    ,@msg            VARCHAR(500)
    ,@sc_fn_ret_ty   VARCHAR(20)
BEGIN TRY
   SELECT
       @schema_nm    = schema_nm
      ,@rtn_nm       = rtn_nm
      ,@rtn_ty_code  = rtn_ty_code
   FROM test.RtnDetails;
   EXEC sp_log 1, @fn, '000: starting
@schema_nm  :[',@schema_nm,']
@rtn_nm     :[',@rtn_nm,']
@rtn_ty_code:[',@rtn_ty_code,']';
   SET @qrn = CONCAT(@schema_nm, '.', @rtn_nm);
   -- Clear the test.Param TabIe
   EXEC sp_log 1, @fn, '005: clearing param details'
   TRUNCATE TABLE test.ParamDetails;
   -------------------------------------------------------------------------------
   -- Validate parameters
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '010: Validating parameters   ';
-- POST 01: if routine not found then exception 70003, 'Routine <@schema_nm.@rtn_nm> was not found'
   IF @rtn_nm IS NULL
   BEGIN
      SET @msg = CONCAT('Routine <', @schema_nm, '.',@rtn_nm,'> was not found');
      EXEC sp_log 4, @fn, '020: raising exception 70003, ', @msg;
      IF @throw_if_err = 1
         THROW 70003, @msg, 1;
      ELSE
         RETURN
   END
   IF NOT EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES
   WHERE SPECIFIC_SCHEMA = @schema_nm AND SPECIFIC_NAME = @rtn_nm)
   BEGIN
      SET @msg = CONCAT('routine <',@schema_nm,'>.<',@rtn_nm,'> was not found');
      IF @throw_if_err = 1
         THROW 70003, @msg, 1;
      ELSE
      BEGIN
         EXEC sp_log 4, @fn, '030: routine ',@schema_nm,'.',@rtn_nm,' not found';
      END
   END
   -------------------------------------------------------------------------------
   -- Validation complete
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '040: Validation complete';
   -------------------------------------------------------------------------------
   -- Process
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '050: starting process
@qrn:[',@qrn,']
@rtn_ty_code:[',@rtn_ty_code,']'
;
-- Add the tst_num parameter setting type = SYS
   EXEC sp_log 1, @fn, '060: Populating ParamDetails, adding tst_num ';
   INSERT INTO test.ParamDetails(param_nm ,  type_nm      , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
   VALUES                       ('tst_num', 'VARCHAR(50)', 'IN'           , 1        , 0        , 0        , 0          ,'TST' , 0)
   ;
   EXEC sp_log 1, @fn, '070:';
   IF @rtn_ty_code IN ('P','TF')
   BEGIN
      EXEC sp_log 1, @fn, '018:';
      SET @ndx = @ndx + 1;
      INSERT INTO test.ParamDetails(param_nm ,type_nm       , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
      VALUES
          ('display_tables' ,'BIT' , 'IN'           , 0        , 0        , 0        , 0          ,'TST' , 0)
      ;
   END
   SET @ndx = @ndx + 1;
   -- Get the rtn parameters-- Add the rtn parameters as INP if a Scalar FN ignore the is_result parameter
   EXEC sp_log 1, @fn, '020: adding rtn parameters as INP';
   INSERT INTO test.ParamDetails( param_nm, parameter_mode, type_nm, is_output, is_chr_ty, is_result, is_nullable, tst_ty,is_exception)
   SELECT
       iif( is_result = 'YES', 'out_val', dbo.fnTrim2(pv.prm_nm, '@'))
      ,parameter_mode
      ,upper(ty_nm_full)
      ,is_output
      ,is_chr_ty
      ,iif(is_result='Yes', 1,0)
      ,is_nullable
      ,iif( is_result = 'YES','EXP','INP')
      ,0
   FROM INFORMATION_SCHEMA.PARAMETERS isp
   JOIN dbo.SysRtnPrms_vw pv ON 
       isp.SPECIFIC_SCHEMA  = pv.schema_nm
   AND isp.SPECIFIC_NAME    = pv.rtn_nm
   AND isp.PARAMETER_NAME   = pv.prm_nm
   WHERE schema_nm = @schema_nm
   AND   rtn_nm    = @rtn_nm
   ;
   SET @row_cnt = @@ROWCOUNT;
   SET @ndx = @ndx + @row_cnt;
   EXEC sp_log 1, @fn, '080: @ndx after geting rtn params: ', @ndx,'  @row_cnt: ',@row_cnt;
   ----------------------------------------------------------------------------------------------------------------------------------
   -- IF SP or TF: get the output cols and add EXP row_cnt param
   ----------------------------------------------------------------------------------------------------------------------------------
   IF @rtn_ty_code IN ('P','TF')
   BEGIN
      EXEC sp_log 1, @fn, '090: @rtn_ty_code:', @rtn_ty_code, ', adding exp_row_cnt';
      -- Add an exp_row_cnt INT setting type = TST
      INSERT INTO test.ParamDetails( param_nm    , type_nm, parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
      VALUES                       ('row_cnt'    , 'INT'  , 'IN'          , 0        , 0        , 0        , 1          ,'EXP',   0);
      SET @ndx = @ndx + 1;
      IF(@rtn_ty_code = 'P')
      BEGIN
         INSERT INTO test.ParamDetails(param_nm ,  type_nm      , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
         VALUES                       ('RC',       'INT',            'IN'       , 0        , 0        , 0        , 0          ,'EXP' , 0);
         SET @ndx = @ndx + 1;
      END
      IF  @rtn_ty_code = 'TF'
      BEGIN
         -- Get the TF ouput table cols
         EXEC sp_log 1, @fn, '100: , adding the TF ouput table cols';
         INSERT INTO test.ParamDetails
               (param_nm, type_nm, parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
         SELECT
             dbo.fnTrim2(name, '@')
            ,ty_nm
            ,'IN'
            ,dbo.fnIsTextType(ty_nm)
            ,0
            ,0
            ,1
            ,'EXP'
            ,0
         FROM dbo.fnGetFnOutputCols(@qrn)
      END
      IF @rtn_ty_code = 'P'
      BEGIN
         EXEC sp_log 1, @fn, '120: , getting the SP ouput table cols';
         BEGIN TRY
            DELETE FROM test.sp_first_result_col_info;
            DECLARE @obj_id INT
            SET @obj_id = OBJECT_ID(@qrn);
            EXEC sp_log 1, @fn, '130: , checking OBJECT_ID(',@qrn, ') = ', @obj_id, ' is > 0   ';
            -------------------------------------------------------------------------------------------
            -- Make sure rtn was found
            -------------------------------------------------------------------------------------------
            EXEC sp_assert_gtr_than @obj_id, 0, '140: failed to get the object id for ', @qrn;
            INSERT INTO test.sp_first_result_col_info(name, column_ordinal, is_nullable, system_type_name, [error_message])
            SELECT name, column_ordinal, is_nullable, system_type_name, [error_message]
            FROM sys.dm_exec_describe_first_result_set_for_object(@obj_id, 0);
            INSERT INTO test.ParamDetails
                  (param_nm, type_nm, parameter_mode
                  ,is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
            SELECT
                dbo.fnTrim2(name, '@')                   -- raw_param_nm
               ,UPPER(system_type_name)                  -- type_nm
               ,'IN'                                     -- parameter_mode
               ,dbo.fnIsTextType(system_type_name)       -- is_chr_ty
               ,1                                        -- is_result
               ,0                                        -- is_output
               ,1                                        -- is_nullable
               ,'EXP'                                    -- tst_ty
               ,0                                        -- is_exception
            FROM test.sp_first_result_col_info
            WHERE name <> 'SP RTN COLS:';
            EXEC sp_log 1, @fn, '150: , getting the SP ouput table cols succeeded';
         END TRY
         BEGIN CATCH
            EXEC sp_log_exception @fn, 'sys.dm_exec_describe_first_result_set cannnot get output cols from SP - continuing without the output col exp/act params';
         END CATCH
      END -- IF @rtn_ty_code = 'P'
   END -- IF @rtn_ty_code IN ('P','TF')
   -------------------------------------------------------------------------------------------------------------------------------
   -- R02: add exception params
   -------------------------------------------------------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '160: adding  exception params';
   SET @ndx = @ndx + 1;
   INSERT INTO test.ParamDetails
    (param_nm ,type_nm        , parameter_mode, is_chr_ty, is_result, is_output, is_nullable, tst_ty, is_exception)
   VALUES
    ('ex_num', 'INT'          , 'IN'          , 1        , 0        , 0        , 1           ,'EXP'   , 1)
   ,('ex_msg', 'VARCHAR(500) ', 'IN'          , 1        , 0        , 0        , 1           ,'EXP'   , 1)
   ;
   -------------------------------------------------------------------------------------------------------------------------------
   -- R02: update the RtnDetails table max_prm_len field with the length of the longest parameter name including the @xxx_ prefix
   -------------------------------------------------------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '170: calculating max param len   '
   -- Set max param nm len make sure atleast size of our standard parameters like @act_ex_msg
   SELECT
       @max_prm_len = dbo.fnMax(14, MAX(dbo.fnLen(param_nm)))
      ,@ndx         = COUNT(*)
   FROM ParamDetails;
   -- Updaet the RtnDetails with aff data for params: count of and max len
   UPDATE test.RtnDetails
   SET
       max_prm_len = @max_prm_len
      ,prm_cnt     = @ndx
      ;
   -------------------------------------------------------------------------------------------------------------------------------
   -- R03: if tstd rtn is a scalar function then update the RtnDetails table sc_fn_ret_ty field with the scalar fn return type
   -------------------------------------------------------------------------------------------------------------------------------
   IF @rtn_ty_code = 'FN'
   BEGIN
      EXEC sp_log 1, @fn, '180: tstd rtn is a scalar function so set the fn''s return type'
      SELECT @sc_fn_ret_ty = type_nm
      FROM test.ParamDetails
      WHERE is_output=1;
      EXEC sp_log 1, @fn, '190: getting sc fn ret type from parameters    @sc_fn_ret_ty:[', @sc_fn_ret_ty,']';
      EXEC sp_assert_not_null_or_empty @sc_fn_ret_ty, 'scalar fn return type was not found';
      EXEC sp_log 1, @fn, '200: ASSERTION @sc_fn_ret_ty found'
      UPDATE test.RtnDetails
      SET sc_fn_ret_ty = @sc_fn_ret_ty;
      EXEC sp_log 1, @fn, '210: ASSERTION @sc_fn_ret_ty found'
   END
   -------------------------------------------------------------------------------
   -- Checking post conditionms
   -------------------------------------------------------------------------------
   EXEC sp_log 1, @fn, '400: checking post conditionms';
   EXEC sp_log 1, @fn, '900: completed processing, @max_prm_len: ',@max_prm_len;
   -------------------------------------------------------------------------------
   -- Process complete
   -------------------------------------------------------------------------------
   if @display_tables = 1
      SELECT * FROM test.ParamDetails;
END TRY
BEGIN CATCH
   EXEC sp_log 4, @fn, '500 caught exception';
   EXEC sp_log_exception @fn;
   THROW;
END CATCH
   EXEC sp_log 1, @fn, '999: leaving'
END
/*
EXEC test.test_042_sp_pop_param_details;
EXEC tSQLt.Run 'test_042_sp_pop_param_details';
EXEC tSQLt.RunAll;
------------------------------------------------------------
EXEC test.sp_set_rtn_details @qrn='test.fnCrtHlprCodeDeclActParams',@display_tables = 1
EXEC test.sp_pop_rtn_details @qrn='test.fnCrtHlprCodeDeclActParams',@display_tables = 1
EXEC test.sp_pop_param_details @display_tables = 1;
EXEC test.sp__crt_tst_rtns ''
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ======================================================================================================================================
-- Author:      Terry Watts
-- Create date: 20-APR-2024
-- Description: Gets the routine details for the routine @q_rtn_nm
--    Populates
--       PopulatesTest.RtnDetails   with the rtn level details only, not the param specific data like max param length
--       ** Does not populate Test.ParamDetails table
--
-- Responsibilities:
-- Sole populator of the 2 rtn metadata tables: {Test.RtnDetails, Test.RtnParamDetails}
-- Parameters:
-- @q_tstd_rtn the qualified tested routine name <schema>.<routine> optionally wrapped in []
--
-- Preconditions: none
-- PRE 01: @qrn must be specified - not null, empty or just dot or whitespace
--
-- Postconditions:
-- Populates
--       Test.RtnDetails   with the rtn level details
--
------------------------------------------------------------------------------------------------------
-- RULES     Rule                       Ex num  ex msg
------------------------------------------------------------------------------------------------------
-- POST 01: if routine not found and @throw_if_err is true then throw exception 70003, 'Routine [[<@schema_nm>].[<@rtn_nm>]] not found'
-- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn>
-- POST 03: Test.RtnParamDetails pop OR 70102,  Could not find the parameter details for <@q_tstd_rtn>
-- POST 04: qrn returned fully qualified with schema
-- POST 05: if routine not found and @throw_if_err is false then pop rtnDetails with the rtn name details only
-- POST 06: test.rtnDetails has 1 row or exception 70004, 'failed to populate Test.RtnDetails properly'
--
-- Algorithm:
-- 1. Removes square brackets
-- 2. Validate parameters
-- 2. Pop Test.RtnDetails   with the rtn level details
--
-- Called by: sp_set_rtn_details
--
-- Tests: test.hlpr_034_get_rtn_parameters
--
-- Changes:
-- 240415: redesign, added several fields to make the test rtn creation easier
-- 241111: if @trn not supplied look for the first unused trn
-- 241121: bugfix: qrn with leading space causes rtn not found error. FIX:  trim the qrn after de square bracket
-- 241227: @qrn must be specified - not null, empty or just dot or whitespace
-- ======================================================================================================================================
CREATE PROCEDURE [test].[sp_pop_rtn_details]
    @qrn             VARCHAR(150) OUT
   ,@trn             INT      = NULL
   ,@cora            NCHAR(1) = NULL
   ,@ad_stp          BIT      = NULL -- used in testing to identify a step with a unique name (not an incremental int id)
-- ,@tst_mode        BIT      = 1    -- for testing - copy tmp tables to permananent tables for teting
-- ,@stop_stage      INT      = 12   -- stage 12 for testing - display script
   ,@throw_if_err    BIT      = 1
   ,@display_tables  BIT      = 0
AS
BEGIN
   DECLARE
    @fn           VARCHAR(35)   = 'sp_pop_rtn_details'
   ,@schema_nm    VARCHAR(50)
   ,@rtn_nm       VARCHAR(100)
   ,@rtn_ty       VARCHAR(2)
   ,@ty_code      VARCHAR(2)
   ,@cnt          INT
   ,@tst_rtn_nm   VARCHAR(50)
   ,@hlpr_rtn_nm  VARCHAR(50)
   ,@is_clr       BIT
   ,@max_prm_len  INT
   ,@msg          VARCHAR(500)
   EXEC sp_log 2, @fn, '000: starting
@qrn           :[', @qrn           ,']
@trn           :[', @trn           ,']
@cora          :[', @cora          ,']
@ad_stp        :[', @ad_stp        ,']
@throw_if_err  :[', @throw_if_err  ,']
@display_tables:[', @display_tables,']
';
--@tst_mode      :[', @tst_mode      ,']
--@stop_stage    :[', @stop_stage    ,']
   BEGIN TRY
      DELETE FROM Test.RtnDetails;
      DELETE FROM Test.ParamDetails;
      --------------------------------------------------------------------------------------
      -- Validate parameters
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '005: Validating parameters: removing [] brackets';
      SET @qrn = TRIM(dbo.fnDeSquareBracket(@qrn)); -- 241121 bugfix: qrn with leading space causes rtn not found error. FIX:  trim the qrn after de square bracket
      -- PRE 01: @qrn must be specified - not null, empty or just dot or whitespace
      EXEC sp_assert_not_null_or_empty @qrn, ' @qrn not specified', @fn=@fn;
      IF @qrn LIKE '.%' OR @qrn LIKE '%.'
         EXEC sp_raise_exception @msg1='@qrn must be specified - not null, empty or just dot or whitespace';
      --------------------------------------------------------------------------------------
      -- ASSERTION: Validated parameters
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010: ASSERTION: Validated parameters';
      --------------------------------------------------------------------------------------
      -- Process
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: Process';
      EXEC sp_log 1, @fn, '030: Calling fnGetRtnDetails(', @qrn, ')';
      -- 241227: When qrn is not qualified with a schemqa - we can get it if the routine name is unique accross schemas
      SELECT
          @qrn       = qrn
         ,@schema_nm = schema_nm
         ,@rtn_nm    = rtn_nm
         ,@rtn_ty    = rtn_ty
         ,@ty_code   = ty_code
         ,@is_clr    = is_clr
      FROM dbo.fnGetRtnDetails(@qrn);
      EXEC sp_log 1, @fn, '040: fnGetRtnDetails(',@qrn,') returned
             @qrn       = [@schema_nm = [', @schema_nm, ']
             @rtn_nm    = [', @rtn_nm   , ']
             @rtn_ty    = [', @rtn_ty   , ']
             @ty_code   = [', @ty_code  , ']
             @is_clr    = [', @is_clr   , ']'
      ;
      IF @schema_nm IS NULL
      BEGIN
         -- POST 01: if routine not found and @throw_if_err is true then throw exception 70003, 'Routine [[<@schema_nm>].[<@rtn_nm>]] not found'
         EXEC sp_log 4, @fn, '050: routine ',@qrn, ' does not exist';
         IF @throw_if_err = 1
         BEGIN
            SET @msg = CONCAT('routine [',@schema_nm,'.',@rtn_nm,'] was not found');
            EXEC sp_raise_exception 70003, @msg, @fn=@fn;
         END
         ELSE
            -- POST 05: if routine not found and @throw_if_err is false then pop rtnDetails with the rtn name details only
            EXEC sp_log 4, @fn, '060: routine ',@qrn, ' does not exist. @throw_if_err = 0 so pop table with rtn name details only';
            INSERT INTO test.RtnDetails(qrn, schema_nm, rtn_nm)
            VALUES (@qrn, @schema_nm, @rtn_nm);
      END
      EXEC sp_log 1, @fn, '070:';
      IF @cora IS NULL
         SET @cora = 'C';
      IF @cora NOT IN ('A','C')
      BEGIN
         EXEC sp_log 4, @fn, '080: @cora  NOT IN (''A'',''C''):[',cora, ']';
         IF @throw_if_err = 1
         BEGIN
            EXEC sp_log 4, @fn, '090 : unknown create mode [',@cora, ']';
            EXEC sp_raise_exception 70100, 'Create or alter param must be 1 of {NULL, ''A'' ''C''}', @cora;
         END
         ELSE
         BEGIN
            EXEC sp_log 4, @fn, '100 : unknown create mode [',@cora, ']';
            SET @cora = 'unknown create mode';
         END
      END
      -- Return this to client code
      IF @ad_stp     IS NULL SET @ad_stp     = 1;
      IF @trn        IS NULL SET @trn        = test.fnGetNxtTstRtnNum(); -- this is very slow
--      IF @tst_mode   IS NULL SET @tst_mode   = 1;
--      IF @stop_stage IS NULL SET @stop_stage = 12;
      EXEC sp_log 1, @fn, '110: modified params:
@qrn         :[', @qrn         ,']
@trn         :[', @trn         ,']
@cora        :[', @cora        ,']
@ad_stp      :[', @ad_stp      ,']
';
-- @tst_mode    :[', @tst_mode    ,']
-- @stop_stage  :[', @stop_stage  ,']
      --------------------------------------------------------------------------------------
      -- Validate parameters Complete
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '120: ASSERTION Validated set any defaults as needed';
      --------------------------------------------------------------------------------------
      -- Process
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '130: Process'
      EXEC sp_log 1, @fn, '140: populating the RtnDetails table   '
      SET @tst_rtn_nm   = test.fnCreateTestRtnName(@rtn_nm, @trn, 'M');
      SET @hlpr_rtn_nm  = test.fnCreateTestRtnName(@rtn_nm, @trn, 'H');
      -- 2. Pop Test.RtnDetails with the rtn level details
      INSERT INTO Test.RtnDetails
           ( schema_nm, rtn_nm, rtn_ty, rtn_ty_code, trn, qrn, cora, ad_stp, /*tst_mode,stop_stage, */ tst_rtn_nm, hlpr_rtn_nm, is_clr, display_tables)
      SELECT schema_nm, rtn_nm, rtn_ty, ty_code    ,@trn,@qrn,@cora,@ad_stp,/*@tst_mode,@stop_stage,*/ @tst_rtn_nm,@hlpr_rtn_nm, is_clr,@display_tables
      FROM SysRtns_vw
      WHERE schema_nm = @schema_nm
      AND   rtn_nm    = @rtn_nm;
      SET @cnt = @@ROWCOUNT;
      EXEC sp_log 1, @fn, '145: imported ', @cnt, ' rows';
      IF @display_tables = 1
      BEGIN
         EXEC sp_log 1, @fn, '147: displaying Test.RtnDetails rows';
         SELECT * FROM Test.RtnDetails;
      END
      --------------------------------------------------------------------------------------
      -- Check postconditions
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '150: Checking postconditions   ';
      -- POST 01: find the routine         OR 70100,  Could not find the routine <@q_tstd_rtn>               chd already
      -- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn> chd already
      -- POST 03: Test.RtnParamDetails pop OR 70102,  Could not find the parameter details for <@q_tstd_rtn> chd already
      -- POST 04: qrn returned fully qualified with schema
      EXEC sp_log 1, @fn, '160: checking results in the RtnDetails table, @cnt:',@cnt, ''
      -- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn>
      IF @cnt = 0
      BEGIN
         EXEC sp_log 4, @fn, '170: Could not find the routine details for [',@qrn,']';
         IF @throw_if_err = 1
         BEGIN
            EXEC sp_raise_exception 70100, '180: Could not find the routine details for ',@qrn;
         END
         ELSE
         BEGIN
            EXEC sp_log 4, @fn, '190 : continuing process since @throw_if_err = 0';
         END
      END
      EXEC sp_log 1, @fn, '200: checking  RtnDetails table row count = 1'
      EXEC sp_assert_equal 1, @cnt, '[',@cnt,']) rows were returned in the RtnDetails table, should be 1 row', @ex_num=70110;
      SET @cnt = CHARINDEX('.', @qrn);
      EXEC sp_log 1, @fn, '210 dot pos: ', @cnt, ' @qrn: [',@qrn,']';
      EXEC sp_assert_not_equal 0, @cnt ,'Failed: tested routine not qualified';
      EXEC sp_log 1, @fn, '220';
      -- POST 06: test.rtnDetails has 1 row or exception 70004, 'failed to populate Test.RtnDetails properly'
      EXEC sp_assert_tbl_pop 'test.rtnDetails', @exp_cnt =1, @ex_num=70004, @ex_msg='failed to populate Test.RtnDetails properly';
      EXEC sp_log 1, @fn, '230';
      --------------------------------------------------------------------------------------
      -- Process complete
      --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '900: Process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999: leaving';
END
/*
EXEC test.sp_pop_rtn_details 'test.sp_compile_rtn', @display_tables=1;
SELECT * frOM test.rtnDetails;
EXEC sp_set_log_level 0
PRINT DB_NAME()
EXEC tSQLt.Run 'test.test_090_sp_get_rtn_details';
EXEC tSQLt.Run 'test.test_034_sp_pop_param_details';
EXEC tSQLt.RunAll;
SELECT * FROM dbo.fnGetRtnDetails('test.sp_tst_hlpr_st');
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===================================================================================================
-- Author:      Terry Watts
-- Create date: 03-APR-2024
-- Rtn:         test.sp_set_rtn_details
-- Description: Gets the routine details for the routine @q_rtn_nm
--    Populates
--       Test.RtnDetails   with the rtn level details
--       Test.ParamDetails with the parameter level details
--
-- Responsibilities:
-- Main entry point for the population of the 2 rtn metadata tables: {Test.RtnDetails, Test.RtnParamDetails}
-- Parameters:
-- @q_tstd_rtn the qualified tested routine name <schema>.<routine> optionally wrapped in []
--
-- Preconditions: none
--
-- Postconditions:
-- Populates
--       Test.RtnDetails   with the rtn level details
--       Test.ParamDetails with the parameter level details
------------------------------------------------------------------------------------------------------
-- RULES     Rule                       Ex num  ex msg
------------------------------------------------------------------------------------------------------
-- POST 01: find the routine         OR 70100,  Could not find the routine <@q_tstd_rtn>
-- POST 02: Test.RtnDetails      pop OR 70101,  Could not find the routine   details for <@q_tstd_rtn>
-- POST 03: Test.RtnParamDetails pop OR 70102,  Could not find the parameter details for <@q_tstd_rtn>
-- POST 04: qrn returned fully qualified with schema
--
-- Algorithm:
-- 1. populate test.RtnDetailsn   using sp_pop_rtn_details
-- 2. populate test.ParamDetails using sp_pop_param_details
-- All checks are delegated to the 2 pop rtns
--
-- Tests: test.hlpr_034_get_rtn_parameters
--
-- Changes:
-- 240415: redesign, added several fields to make it eassier to use latter in the test rtn creation
-- 241031: removed @tst_mode param
-- 241111: if @trn not supplied look for the first unused trn
-- ===================================================================================================
CREATE PROCEDURE [test].[sp_set_rtn_details]
    @qrn             VARCHAR(150)
   ,@trn             INT      = NULL
   ,@cora            NCHAR(1) = NULL
   ,@ad_stp          BIT      = NULL -- for teting
   ,@throw_if_err    BIT      = 1
   ,@display_tables  BIT      = 0
AS
BEGIN
   DECLARE
     @fn             VARCHAR(35)   = 'sp_set_rtn_details'
    ,@schema_nm      VARCHAR(50)
    ,@rtn_nm         VARCHAR(100)
    ,@cnt            INT
    ,@tst_rtn_nm     VARCHAR(50)
    ,@hlpr_rtn_nm    VARCHAR(50)
    ,@line           VARCHAR(100)= REPLICATE('-', 100)
   BEGIN TRY
      --------------------------------------------------------------------------------------------------------
      -- Pop the RtnDetails table
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '000: starting
qrn           :[', @qrn           ,']
trn           :[', @trn           ,']
cora          :[', @cora          ,']
ad_stp        :[', @ad_stp        ,']
throw_if_err  :[', @throw_if_err  ,']
display_tables:[', @display_tables,']'
;
      EXEC sp_log 1, @fn, '005: populating the RtnDetails table   ';
      EXEC test.sp_pop_rtn_details
          @qrn          = @qrn         OUT
         ,@trn          = @trn
         ,@cora         = @cora
         ,@ad_stp       = @ad_stp
         ,@throw_if_err = @throw_if_err
            ;
      --------------------------------------------------------------------------------------------------------
      -- Pop the param details
      --------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '010:  populating the ParamDetails table   '
      EXEC test.sp_pop_param_details @throw_if_err = @throw_if_err;
      --------------------------------------------------------------------------------------
      -- Process complete
      --------------------------------------------------------------------------------------
      IF @display_tables = 1
      BEGIN
         SELECT @line;
         PRINT 'test.RtnDetails:'
         SELECT @line;
         SELECT * FROM test.RtnDetails;
PRINT '';
         SELECT @line;
         PRINT 'test.ParamDetails:'
         SELECT @line;
         SELECT * FROM test.ParamDetails;
         SELECT @line;
      END
      EXEC sp_log 1, @fn, '900: Process complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999: leaving';
END
/*
EXEC test.sp__crt_tst_rtns 'test].[sp_set_rtn_details'
EXEC test.sp_get_rtn_details 'dbo.sp_class_creator', @display_tables=1;
EXEC tSQLt.Run 'test.test_034_sp_get_param_details';
EXEC tSQLt.Run 'test.test_090_sp_get_rtn_details';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================
-- Author:      Terry Watts
-- Create date: 07-APR-2024
-- Description: Initialises state for both the main and the helper test rtns
--    i.e. populates 2 test tables: RtnDetails, ParamDetails
--
-- Preconditions: none
--
-- Postconditions:
-- POST 01: Test.RtnDetails, Test.ParamDetails tables populated or exception
--          fro exception details see sp_get_rtn_details
--
-- Algorithm
--    Populate Test.RtnDetails, Test.ParamDetails tables
--
-- Changes:
-- 231124: added remove [] brackets to make it easier to set up tests
-- 240415: redesign, rewrite
-- 241031: removed @tst_mode param
-- 241111: if @trn not supplied look for the first unused trn
-- ==================================================================
CREATE PROCEDURE [test].[sp_crt_tst_rtns_init]
    @qrn        VARCHAR(100) -- tested rtn name including the schema - returns it tidied up if necessary
   ,@trn        INT           = NULL
   ,@cora       NCHAR(1)      = 'C'
   ,@ad_stp     BIT           = 0    -- used in testing to identify a step with a unique name (not an incremental int id)
--   ,@stop_stage INT           = 12   -- stage 12 for testing - display script
AS
BEGIN
   DECLARE 
      @fn        VARCHAR(35)   = 'CRT_TST_RTNS_INIT'
     ,@n         INT
   SET NOCOUNT ON;
   EXEC sp_log 2, @fn, '000: starting
@qrn   :[', @qrn,']
@trn   :[', @trn,']
@ad_stp:[', @ad_stp,']'
;
   --  populate the 2 routine details tables
   EXEC test.sp_set_rtn_details @qrn, @trn, @cora, @ad_stp, 1 -- 1: throw if error
   SELECT * FROM [test].[RtnDetails];
   SELECT * FROM [test].[ParamDetails];
   EXEC sp_log 2, @fn, '999: leaving OK';
END
/*
EXEC tSQLt.Run 'test.test_068_sp_crt_tst_rtns';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [test].[TstDef](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[line] [varchar](4000) NULL,
 CONSTRAINT [PK_test.rtnDefTable] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =======================================================================================
-- Author:     Terry Watts
-- Create date: 24-APR-2024
-- Description: saves the test.TstDef table to file specified by @file_path param
-- Preconditions:
-- PRE 01: test.TestDef table populated 
-- Postconditions:                     EX
-- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
-- POST 02: write to file OK or  OR EX 63202, ''
-- =======================================================================================
CREATE PROCEDURE [test].[sp_save_mn_script_file]
   @file_path VARCHAR(MAX)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn           VARCHAR(35)   = N'sp_save_mn_script_file'
      ,@ret_code     INT
      ,@file_system  INT
      ,@file_exists_ VARCHAR(35)
      ,@file_handle  INT
      ,@file_exists  BIT
      ,@line_cnt     INT = 0
      ,@line         VARCHAR(MAX)
      ,@NL           NCHAR(2)=NCHAR(13)+NCHAR(10)
   BEGIN TRY
      EXEC sp_log 2, @fn,'000: starting, params:
file  :[',@file_path,']'
;
      ----------------------------------------------------------------------------------------------------------------------------
      -- Create Scripting.FileSystemObject
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'005: creating Scripting.FileSystemObject';
      EXECUTE @ret_code = sp_OACreate 'Scripting.FileSystemObject' , @file_system OUTPUT;
      IF (@@ERROR|@ret_code > 0 Or @file_system < 0)
      BEGIN
         EXEC sp_log 4, @fn,'010: could not create FileSystemObject';
         RAISERROR ('could not create FileSystemObject',16,1)
      END
      ----------------------------------------------------------------------------------------------------------------------------
      -- Open a new file for (over)writing
      ----------------------------------------------------------------------------------------------------------------------------
      --1 = for reading, 2 = for writing (will overwrite contents), 8 = for appending
      EXEC sp_log 1, @fn,'020: creating sql file to write rtn to';
      EXEC @ret_code = sp_OAMethod @file_system , 'OpenTextFile' , @file_handle OUTPUT , @file_path, 2, 1;
      IF (@@ERROR|@ret_code > 0 Or @file_handle < 0)
      BEGIN
         EXEC sp_log 4, @fn,'025: could not create sql file';
         RAISERROR ('could not create sql file',16,1);
      END
      ----------------------------------------------------------------------------------------------------------------------------
      -- Write the HlprDef table to the file line by line
      ----------------------------------------------------------------------------------------------------------------------------
      DECLARE row_cursor CURSOR READ_ONLY FOR
         SELECT line FROM test.TstDef;
      EXEC sp_log 1, @fn,'030: opening cursor';
      OPEN row_cursor;
      FETCH NEXT FROM row_cursor INTO @line;
      ----------------------------------------------------------------------------------------------------------------------------
      -- Main loop: reads each line from the table and writes to file
      ----------------------------------------------------------------------------------------------------------------------------
      WHILE (@@fetch_status = 0)
      BEGIN
         SET @line = CONCAT(@line, @NL);
         EXECUTE @ret_code = sp_OAMethod @file_handle , 'Write' , NULL , @line;
         IF (@@ERROR|@ret_code > 0)
         BEGIN
           -- POST 02: write to file OK or  OR EX 63202, ''
            EXEC sp_log 4, @fn,'040: could not write to file: @@ERROR ',@@ERROR,' @ret_code: ', RetCode;
            THROW 63202, 'could not write to file',1;
         END
         SET @line_cnt = @line_cnt + 1;
         FETCH NEXT FROM row_cursor INTO @line
      END
      CLOSE row_cursor
      DEALLOCATE row_cursor
      EXEC sp_log 1, @fn,'050: exported ', @line_cnt, ' procedure lines';
      EXEC @ret_code = sp_OAMethod @file_handle , 'Close' , NULL;
      IF (@@ERROR|@ret_code > 0) RAISERROR ('Could not close file',16,1);
      EXEC sp_OADestroy @file_system;
      --------------------------------------------------------------------------------------
      -- Check post conditions
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'900: checking post conditions   ';
      -- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
      EXEC sp_assert_file_exists @file_path, @ex_num=63201;
      ----------------------------------------------------------------------------------------
      --    Completed processing
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Completed processing'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_012_sp_crt_tst_mn_compile';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ============================================================
-- Author:      Terry Watts
-- Create date: 16-APR-2024
-- Description: creates the script for the main test routine
--    populates test.TstDef table
--
-- Design: see EA ut/Use Case Model/Test Automation/Create Helper rotine Use case/Create the Helper routine_ActivityGraph
--
-- Algorithm:
-- Create the ALTER PROCEDURE signature
-- Create the As begin declare bloc
-- Create a run test line with dummy parameters
-- Create the close bloc
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
-- Algorithm:
--
-- Changes:
-- 231115: helper should have same defaults as the tstd rtn
-- 231121: @qrn must exist or exception 56472, '<@qrn> does not exist'
-- 231121: added a try catch handler to log errors
-- 231201: better tested exception handling
-- 231213: handle wonky []
-- 231216: add check for expected line for the given step id
-- 240402: refactor - split into subroutines
--
-- ============================================================
CREATE PROCEDURE [test].[sp_crt_tst_mn_script]
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_mn_script'
   ,@qrn                VARCHAR(100) -- including schema
   ,@trn                INT
   ,@ad_stp             BIT            = 0    -- used in testing to identify a step with a unique name (not an incremental int id)
   ,@act_qrn            VARCHAR(100)
   ,@row_cnt            INT
   ,@act_tst_rtn_num    INT
   ,@error_num          INT
   ,@error_msg          VARCHAR(500)
   ,@cora               NCHAR(1)
   ,@crse_rtn_ty_code   VARCHAR(1)          -- coarse grained type one of {'F','P'}
   ,@detld_rtn_ty_code  NCHAR(2)       = '?' -- detailed type code: can be 1 of {'P', 'FN', 'IF','TF'}like TF for a table function
   ,@hlpr_params        VARCHAR(MAX)
   ,@hlpr_rtn_nm        VARCHAR(120)        -- hlpr_<@trn 000>_
   ,@line               VARCHAR(500)  ='-- ========================================================================================'
   ,@line2              VARCHAR(500)  ='-- ----------------------------------------------------------------------------------------'
   ,@max_param_len      INT = -1
   ,@msg                VARCHAR(500)
   ,@n                  INT
   ,@params             VARCHAR(MAX)
   ,@stage              INT = 1
   ,@rtn_nm             VARCHAR(100)
   ,@rtn_ty             NCHAR(1)
   ,@rtn_ty_code        VARCHAR(2)
   ,@schema_nm          VARCHAR(50)
   ,@stop_stage         INT            = 12   -- stage 12 for testing - display script
   ,@tab1               VARCHAR(3) = '   '
   ,@tst_mode           BIT            = 1    -- for testing - copy tmp tables to permananent tables for teting
   ,@tst_proc_mn_nm     VARCHAR(120)
   ,@tstd_rtn_call      VARCHAR(250)
   ,@ty_code            VARCHAR(2)
   ,@txt                VARCHAR(500)
   ;
   BEGIN TRY
      EXEC sp_log 2, @fn, '';
      EXEC sp_log 2, @fn, @line2;
      ----------------------------------------------------------------------------------------------------------------------------
      -- Log paramaters
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '000: starting, getting cached rtn details';
      SELECT
          @qrn             = qrn
         ,@schema_nm       = schema_nm
         ,@rtn_nm          = rtn_nm
         ,@trn             = trn
         ,@cora            = cora
         ,@ad_stp          = ad_stp
--         ,@tst_mode        = tst_mode
--         ,@stop_stage      = stop_stage
         ,@hlpr_rtn_nm     = hlpr_rtn_nm
         ,@rtn_ty          = rtn_ty
         ,@rtn_ty_code     = rtn_ty
         ,@tst_proc_mn_nm  = tst_rtn_nm
      FROM test.RtnDetails;
      EXEC sp_log 2, @fn, '005: rtn details:
qrn        :[',@qrn  ,']
trn        :[',@trn ,']
cora       :[',@cora,']
ad_stp     :[',@ad_stp,']
tst_mode   :[',@tst_mode,']
stop_stage :[',@stop_stage,']
hlpr_rtn_nm:[', @hlpr_rtn_nm, ']
ty_code    :[', @ty_code, ']
rtn_ty     :[', @rtn_ty, ']'
;
      SET @stage = 1;
      EXEC sp_log 1, @fn, '010: clearing HlprDeftable;';
      TRUNCATE TABLE Test.TstDef;
      if @ad_stp = 1 INSERT INTO test.TstDef (line) VALUES ('-- sp_crt_tst_mn_script');
      -------------------------------------------------------------------------------
      -- Create the text header
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '015: creating the text header';
      INSERT INTO test.TstDef (line)
      SELECT line
      FROM test.fnCrtCodeTstHdr(0); -- 0 = main tst rtn, 1 = hlpr rtn
      -------------------------------------------------------------------------------
      -- Create the mn tst sig
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: creating the mn tst sig';
      INSERT INTO test.TstDef (line)
      SELECT line
      FROM fnCrtCodeMnTstSig();
      -------------------------------------------------------------------------------
      -- Create the AS BEGIN DECLARE bloc
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '025: creating the As begin declare bloc';
      INSERT INTO TstDef (line) VALUES
         ('AS')
        ,('BEGIN')
        ,('DECLARE')
        --,(CONCAT(@tab1, '@fn VARCHAR(35) = ''T', @trn, '_',UPPER(@rtn_nm), '''')) -- @tst_proc_mn_nm
        ,(CONCAT(@tab1, '@fn VARCHAR(35) = ''',@tst_proc_mn_nm, '''')) -- 
        ,('')
        ,(CONCAT (@tab1, 'EXEC test.sp_tst_mn_st @fn;'))
        ,('')
        ,(CONCAT (@tab1, '-- 1 off setup  ??'))
      ;
      -------------------------------------------------------------------------------
      -- Create 1 helper call with dummy parameters
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: creating 1 helper with dummy parameters';
      INSERT INTO test.TstDef (line)
      SELECT line FROM test.fnCrtMnCodeCallHlpr();
      -------------------------------------------------------------------------------
      -- Create the close bloc
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '035: creating the close bloc';
      INSERT INTO test.TstDef (line)
      SELECT line FROM test.fnCrtMnCodeClose();
      -------------------------------------------------------------------------------
      -- Script completed
      -------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '900 script completed';
      EXEC sp_log 2, @fn, '910 displaying mn test script   ';
      SELECT * FROM test.TstDef;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, '500 Stage: ', @stage;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
SELECT * FROM test.Rtndetails;
EXEC tSQLt.Run 'test].[test_012_sp_crt_tst_mn_compile';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =====================================================================================================================
-- Author:      Terry Watts
-- Create date: 20-NOV-2023
-- Description: Creates the main test rtn in the database
--    first it creates the SQL script in the TestDef table
--    then uses that script to compile the stored procedure in the db
--
-- Preconditions
--    test.RtnDetails and Test.ParamDetails pop'd
--
-- Postconditions:                     EX 58100 'Failed to compile '
-- POST 01: script exists in databse - check delegated to sp_crt_tst_mn_compile
--
-- Algorithm:
-- Get the rtn details if necessary
-- Create  the script
-- Compile the script
--
-- Tests:
--    test_066_sp_crt_tst_mn
--    test_067_sp_crt_tst_mn
--
-- Changes:
-- 231121: @qrn must exist or exception 56472, '<@qrn> does not exist'
-- 231121: added a try catch handler to log errors
-- 240406: redesign see EA: ut/Model/Use Case Model/Test Automation
-- 240724: removed the compile ferature as have difficulty in getting this to work programmatically
--         now manually copy paste from the test.TstDef table
-- =====================================================================================================================
CREATE PROCEDURE [test].[sp_crt_tst_mn]
   @folder    VARCHAR(500)
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_mn'
   ,@tst_rtn_nm         VARCHAR(60)
   ,@script_file_path   VARCHAR(500) 
   ,@bckslsh            VARCHAR(1) = NCHAR(92)
   SET NOCOUNT ON;
   BEGIN TRY
      ----------------------------------------------------------------------------------------------------------------------------
      -- Init
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting';
      SELECT
         @tst_rtn_nm = tst_rtn_nm
      FROM test.RtnDetails;
      SET @script_file_path = CONCAT(@folder, @bckslsh, @tst_rtn_nm, '.sql');
      ---------------------------------------------------------------------------------
      -- Create the main script in the TstDef table-
      ----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'010: Creating the script in the TstDef table: calling sp_crt_tst_mn_script';
      EXEC test.sp_crt_tst_mn_script;
      ----------------------------------------------------------------------------------
      -- Save the script to file
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'020: Save the script to file';
      EXEC test.sp_save_mn_script_file @script_file_path;
      ----------------------------------------------------------------------------------
      -- Processing complete 
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: Processing complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
TRUNCATE TABLE APPLog
EXEC tSQLt.Run 'test.test_066_sp_crt_tst_mn';
EXEC tSQLt.Run 'test.test_067_sp_crt_tst_mn';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [test].[HlprDef](
	[id] [int] IDENTITY(1,1) NOT NULL,
	[line] [varchar](4000) NULL,
 CONSTRAINT [PK_test.HlprDef] PRIMARY KEY CLUSTERED 
(
	[id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =======================================================================================
-- Author:     Terry Watts
-- Create date: 19-MAY-2024
-- Description:exports the test.HlprDef table to file specified by @file_path param
-- Preconditions:
-- PRE 01: test.HlprDef table populated 
-- Postconditions:                     EX
-- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
-- POST 02: write to file OK or  OR EX 63202, ''
-- =======================================================================================
CREATE PROCEDURE [test].[sp_crt_hlpr_script_file]
   @file_path VARCHAR(MAX)
AS
BEGIN
   SET NOCOUNT ON;
   DECLARE
       @fn           VARCHAR(35)   = N'sp_crt_hlpr_script_file'
      ,@ret_code     INT
      ,@file_system  INT
      ,@file_exists_ VARCHAR(35)
      ,@file_handle  INT
      ,@file_exists  BIT
      ,@line_cnt     INT = 0
      ,@line         VARCHAR(MAX)
      ,@NL           NCHAR(2)=NCHAR(13)+NCHAR(10)
   BEGIN TRY
      EXEC sp_log 2, @fn,'000: starting, params:
file  :[',@file_path,']'
;
      ----------------------------------------------------------------------------------------------------------------------------
      -- Create Scripting.FileSystemObject
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'005: creating Scripting.FileSystemObject';
      EXECUTE @ret_code = sp_OACreate 'Scripting.FileSystemObject' , @file_system OUTPUT;
      IF (@@ERROR|@ret_code > 0 Or @file_system < 0)
      BEGIN
         EXEC sp_log 4, @fn,'010: could not create FileSystemObject';
         RAISERROR ('could not create FileSystemObject',16,1)
      END
      ----------------------------------------------------------------------------------------------------------------------------
      -- Open a new file for (over)writing
      ----------------------------------------------------------------------------------------------------------------------------
      --1 = for reading, 2 = for writing (will overwrite contents), 8 = for appending
      EXEC sp_log 1, @fn,'020: creating sql file to write rtn to';
      EXEC @ret_code = sp_OAMethod @file_system , 'OpenTextFile' , @file_handle OUTPUT , @file_path, 2, 1;
      IF (@@ERROR|@ret_code > 0 Or @file_handle < 0)
      BEGIN
         EXEC sp_log 4, @fn,'025: could not create sql file';
         RAISERROR ('could not create sql file',16,1);
      END
      ----------------------------------------------------------------------------------------------------------------------------
      -- Write the HlprDef table to the file line by line
      ----------------------------------------------------------------------------------------------------------------------------
      DECLARE row_cursor CURSOR READ_ONLY FOR
         SELECT line FROM test.HlprDef;
      EXEC sp_log 1, @fn,'030: opening cursor';
      OPEN row_cursor;
      FETCH NEXT FROM row_cursor INTO @line;
      ----------------------------------------------------------------------------------------------------------------------------
      -- Main loop: reads each line from the table and writes to file
      ----------------------------------------------------------------------------------------------------------------------------
      WHILE (@@fetch_status = 0)
      BEGIN
         SET @line = CONCAT(@line, @NL);
         EXECUTE @ret_code = sp_OAMethod @file_handle , 'Write' , NULL , @line;
         IF (@@ERROR|@ret_code > 0)
         BEGIN
           -- POST 02: write to file OK or  OR EX 63202, ''
            EXEC sp_log 4, @fn,'040: could not write to file: @@ERROR ',@@ERROR,' @ret_code: ', RetCode;
            THROW 63202, 'could not write to file',1;
         END
         SET @line_cnt = @line_cnt + 1;
         FETCH NEXT FROM row_cursor INTO @line
      END
      CLOSE row_cursor
      DEALLOCATE row_cursor
      EXEC sp_log 1, @fn,'050: exported ', @line_cnt, ' procedure lines';
      EXEC @ret_code = sp_OAMethod @file_handle , 'Close' , NULL;
      IF (@@ERROR|@ret_code > 0) RAISERROR ('Could not close file',16,1);
      EXEC sp_OADestroy @file_system;
      --------------------------------------------------------------------------------------
      -- Check post conditions
         --------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'900: checking post conditions   ';
      -- POST 01: the file exists OR EX 63201, 'The output file: [@file_path] does not exist
      EXEC sp_assert_file_exists @file_path, @ex_num=63201;
      ----------------------------------------------------------------------------------------
      --    Completed processing
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Completed processing'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_012_sp_crt_tst_mn_compile';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ============================================================
-- Author:      Terry Watts
-- Create date: 06-APR-2024
-- Description: creates the script for a test helper routine
--    populates test.HlprDef table
--
-- Design: see EA ut/Use Case Model/Test Automation/Create Helper rotine Use case/Create the Helper routine_ActivityGraph
--
-- Algorithm:
-- Create the text header
-- Create the Helper routine
-- Create the test helper signature
-- Create As-begin-decl-log-st bloc for the helper
-- Add the test setup and call tested routine comments
-- Create the if @exp_ex_num IS null bloc
-- Create the if @exp_ex_nm is NOT null bloc
-- Create the test bloc
-- Create the close bloc
--
-- OUTPUTS:
-- 1: populates table: test.tstActDefHlpr with the hlper creation sql script
--
-- Preconditions:
--    test.rtnDetails and test.ParamDetails populated
-- Algorithm:
--
-- Changes:
-- 231115: helper should have same defaults as the tstd rtn
-- 231121: @qrn must exist or exception 56472, '<@@qrn> does not exist'
-- 231121: added a try catch handler to log errors
-- 231201: better tested exception handling
-- 231213: handle wonky []
-- 231216: add check for expected line for the given step id
-- 240402: refactor - split into subroutines
-- ============================================================
CREATE PROCEDURE [test].[sp_crt_tst_hlpr_script]
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_hlpr_script'
   ,@qrn                VARCHAR(100) -- including schema
   ,@trn                INT
   ,@ad_stp             BIT            = 0    -- used in testing to identify a step with a unique name (not an incremental int id)
   ,@cora               NCHAR(1)       = 'C'
   ,@crse_rtn_ty_code   VARCHAR(1)          -- coarse grained type one of {'F','P'}
   ,@detld_rtn_ty_code  NCHAR(2)       = '?' -- detailed type code: can be 1 of {'P', 'FN', 'IF','TF'}like TF for a table function
   ,@hlpr_rtn_nm        VARCHAR(120)        -- hlpr_<@trn 000>_
   ,@schema_nm          VARCHAR(50)
   ,@stop_stage         INT            = 12   -- stage 12 for testing - display script
   ,@tst_mode           BIT            = 1    -- for testing - copy tmp tables to permananent tables for teting
   ,@tst_proc_mn_nm     VARCHAR(120)
   ,@rtn_ty_code        VARCHAR(25)
   ,@rtn_ty_nm          VARCHAR(25)
   ,@rtn_nm             VARCHAR(100)
   ,@tstd_rtn_call      VARCHAR(250)
   ,@params             VARCHAR(MAX)  = '/*params: <TBD>*/'
   ,@hlpr_params        VARCHAR(MAX)  = '/*hlpr params: <TBD>*/'
   ,@max_param_len      INT            = -1
   ,@n                  INT
   ,@act_@qrn           VARCHAR(100)
   ,@row_cnt            INT
   ,@act_tst_rtn_num    INT
   ,@error_num          INT
   ,@error_msg          VARCHAR(500)
   ,@stage              INT = 1
   ,@msg                VARCHAR(500)
   ,@txt                VARCHAR(500)
   ,@tab                VARCHAR(4)    = '   '
   ;
   BEGIN TRY
--      EXEC sp_log 2, @fn, '';
--      EXEC sp_log 2, @fn, @line2;
      ----------------------------------------------------------------------------------------------------------------------------
      -- Log paramaters
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '000: starting';
      SELECT
          @qrn          = qrn
         ,@schema_nm    = schema_nm
         ,@rtn_nm       = rtn_nm
         ,@trn          = trn
         ,@cora         = cora
         ,@ad_stp       = ad_stp
--         ,@tst_mode     = tst_mode
--         ,@stop_stage   = stop_stage
         ,@hlpr_rtn_nm  = hlpr_rtn_nm
         ,@rtn_ty_nm    = rtn_ty
         ,@rtn_ty_code  = rtn_ty_code
      FROM test.RtnDetails;
      EXEC sp_log 1, @fn, '005: params
qrn        :[',@qrn         ,']
trn        :[',@trn         ,']
cora       :[',@cora        ,']
ad_stp     :[',@ad_stp      ,']
tst_mode   :[',@tst_mode    ,']
stop_stage :[',@stop_stage  ,']
hlpr_rtn_nm:[', @hlpr_rtn_nm,']
ty_code    :[', @rtn_ty_code,']
rtn_ty_nm  :[', @rtn_ty_nm     ,']'
;
      SET @stage = 1;
      EXEC sp_log 1, @fn, '010: truncate HlprDef';
      TRUNCATE TABLE test.HlprDef;
      if(@ad_stp=1) INSERT INTO HlprDef(line) VALUES(CONCAT('-- ', @fn));
      --------------------------------------------------------------------
      -- Create the text header
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn, '015: creating the text header';
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtCodeTstHdr(1);
      --------------------------------------------------------------------
      -- Create the test helper signature
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn, '020: creating the helper signature';
      INSERT INTO test.HlprDef (line)
      SELECT line from test.fnCrtHlprCodeHlprSig();
      --------------------------------------------------------------------
      -- Create As-begin-decl-log-st bloc-test setup for the helper
      --------------------------------------------------------------------
      EXEC sp_log 1, @fn, '025: creating the as-begin-decl-log-st bloc-test setup';
      -- AS-BGN-ST, TF-DECL-ACTRTNDEF-TV,  BGN-TRY
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtHlprCodeBegin();
      -------------------------------------------------------------------------------------------------
      --  Create the tested rtn call
      -------------------------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '030: creating the call tested routine bloc';
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtHlprCodeCallBloc();--@rtn_ty_code, @ad_stp);
      -------------------------------------------------------------------------------
      -- Create the test bloc dependant on rtn type
      ------------------------------------------------- ------------------------------
      --EXEC sp_log 1, @fn, '035: creating the test bloc dependant on rtn ty';
      --INSERT INTO test.HlprDef (line)
      --SELECT line FROM test.fnCrtHlprCodeTestBloc(@rtn_ty_code, @ad_stp);
      -------------------------------------------------------------------------------
      -- Create the close bloc
      -------------------------------------------------------------------------------
      EXEC sp_log 1, @fn, '045 creating the close bloc';
      INSERT INTO test.HlprDef (line)
      SELECT line FROM test.fnCrtHlprCodeCloseBloc()
      -------------------------------------------------------------------------------
      -- Script completed
      -------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '900 script completed';
      EXEC sp_log 2, @fn, '910 displaying hlpr script   ';
      SELECT * FROM test.HlprDef;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, '950: Stage: ', @stage;
      THROW;
   END CATCH
  
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_086_sp_crt_tst_hlpr_script';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================================================================================================
-- Author:      Terry Watts
-- Create date: 09-Nov-2023
-- Description: creates a tSQLt test helper procedure from the data in test.RtnDetails and test.ParamDetails tables
--
-- Design: see EA ut/Use Case Model/Test Automation/Create Helper rotine Use case/Create the Helper routine_ActivityGraph
--
-- Algorithm:
-- Create the Helper script in the TstHlpr table
-- 
-- Create the helper procedure from the script 
--
-- OUTPUTS:
-- 1: populates table: test.tstActDefHlpr with the hlper creation sql script
--
-- Preconditions:
--    PRE01: test rtn details and param details tables populated
--
-- Algorithm:
-- Create the Helper script in a table
-- Create the Helper script file from the lines in teh tables
-- Compile the procedure from the script
--
-- Changes:
-- 231115: helper should have same defaults as the tstd rtn
-- 231121: @q_tstd_rtn must exist or exception 56472, '<@q_tstd_rtn> does not exist'
-- 231121: added a try catch handler to log errors
-- 231201: better tested exception handling
-- 231213: handle wonky []
-- 231216: add check for expected line for the given step id
-- 240402: refactor - split into subroutines
-- 240724: removed the compile feature as have difficulty in getting this to work programmatically
--         now manually copy paste from the test.TstHlpr table
-- ================================================================================================================================
CREATE PROCEDURE [test].[sp_crt_tst_hlpr]
   @folder    VARCHAR(500)
AS
BEGIN
   DECLARE 
    @fn                 VARCHAR(35)   = 'sp_crt_tst_hlpr'
   ,@hlpr_rtn_nm        VARCHAR(100)
   ,@script_file_path   VARCHAR(500) 
   ,@bckslsh            VARCHAR(1) = NCHAR(92)
   SET NOCOUNT ON;
   BEGIN TRY
      ----------------------------------------------------------------------------------------------------------------------------
      -- Init
      ----------------------------------------------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn,'000: starting';
      TRUNCATE TABLE Test.HlprDef;
      SELECT
         @hlpr_rtn_nm = hlpr_rtn_nm
      FROM test.RtnDetails;
      SET @script_file_path = CONCAT(@folder, @bckslsh, @hlpr_rtn_nm, '.sql');
      ---------------------------------------------------------------------------------
      -- Create the Helper script in the TstHlpr table
      ----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '010: Creating the script in the TstHlpr table: calling sp_crt_tst_hlpr_script';
      EXEC test.sp_crt_tst_hlpr_script;
      ----------------------------------------------------------------------------------
      -- Save the script to file
      ----------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '020: Create the Helper script file';
      EXEC test.sp_crt_hlpr_script_file @script_file_path;
      ----------------------------------------------------------------------------------
      -- Processing complete 
      ----------------------------------------------------------------------------------
      EXEC sp_log 1, @fn,'800: Processing complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
TRUNCATE TABLE APPLog
EXEC tSQLt.Run 'test.test_081_sp_crt_tst_hlpr';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ==================================================================
-- Author:      Terry Watts
-- Create date: 15-APR-2024
-- Description: Creates both the main and the helper test rtns
-- for the given tested rtn
--
-- Responibilities:
-- 1: creates both scripts
-- 2. runs the script to compile the stored procedure in the db
--
-- Postconditions:
-- POST 01: IF @tst_rtn_num is specfied then must be > 0
-- POST 02: IF @tst_rtn_num is specfied then must not be already used
-- POST 03: @q_tstd_rtn can either be <schema_nm>.<rtn name> or <rtn name> and must uniquely define
-- POST 04: must uniquely define exactly 1 routine if rtn does not exists -> 58000, 'Routine does not exist'
-- POST 05: if more than 1 rtn exists -> 58001, 'more than 1 routine match the tested routine paramater'
-- POST 06: @crt_or_alter must be one of {'A', 'C', NULL}  If null default: 'C' -> 58002 '@crt_or_alter paramater must be one of {'A', 'C', NULL}'
--
-- Algorithm
--    INIT crt_tst_rtns_init
--    Create the hlpr rtn (script and procdure from script)
--    Create the mn rtn  (script and procdure from script)
--
-- Tests: test_068_sp_crt_tst_rtns
--
-- Changes:
-- 231124: added remove [] brackets to make it easier to set up tests
-- 240724: removed the compile ferature as have difficulty in getting this to work programmatically
--         now manually copy paste from the test.TstHlpr table
-- 241031: removed @tst_mode param, defaulted @folder param
-- 241111: if @trn not supplied look for the first unused trn
-- 241115: default @ad_stp to 1
-- ==================================================================
CREATE PROCEDURE [test].[sp__crt_tst_rtns]
    @qrn       VARCHAR(100)  -- including schema
   ,@trn       INT            = NULL
   ,@cora      NCHAR(1)       = 'C'
   ,@ad_stp    BIT            = 0    -- 241115: default @ad_stp to 1 outputs fn call as comment in script to aid debugging
   ,@folder    VARCHAR(500)  = 'D:\tmp'
AS
BEGIN
   DECLARE 
    @fn              VARCHAR(35)   = 'sp_crt_tst_rtns'
   ,@n               INT
   SET NOCOUNT ON;
   BEGIN TRY
      EXEC sp_log 2, @fn, '00: starting:
   @qrn     :[',@qrn      ,']
   @trn     :[',@trn      ,']
   @cora    :[',@cora     ,']
   @ad_stp  :[',@ad_stp   ,']
   @ad_stp  :[',@ad_stp   ,']
   ';
      ----------------------------------------------------------------------------------------
      -- INIT crt_tst_rtns_init
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '05: test.calling sp_crt_tst_fn_hlpr';
      EXEC test.sp_crt_tst_rtns_init @qrn, @trn, @cora, @ad_stp;
      ----------------------------------------------------------------------------------------
      -- Create the hlpr rtn (script and procdure from script)
      ----------------------------------------------------------------------------------------
      EXEC test.sp_crt_tst_hlpr @folder;
      EXEC sp_log 3, @fn, '50: stopping early - while TDD';
      ----------------------------------------------------------------------------------------
      -- Create the mn rtn  (script and procdure from script)
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: calling test.sp_crt_tst_fn_mn';
      EXEC test.sp_crt_tst_mn @folder;
      ----------------------------------------------------------------------------------------
      --    Completed processing
      ----------------------------------------------------------------------------------------
      EXEC sp_log 2, @fn, '10: Completed processing'
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '999 leaving, OK';
END
/*
EXEC tSQLt.Run 'test.test_068_sp__crt_tst_rtns';
SELECT * FROM test.fnGetUntestedRtns();
TRUNCATE TABLE AppLog;
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ================================================
-- Author:      Terry watts
-- Create date: 06-FEB-2021
-- Description: Setter, clears the test pass count
-- Tests: test.test_030_chkTestConfig
-- ================================================
CREATE PROCEDURE [test].[sp_tst_clr_test_pass_cnt]
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetTstPassCntKey()
   EXEC sp_set_session_context @key, 0;
END
/*
EXEC test.test 030 chkTestConfig;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ========================================================
-- Author:      Terry Watts
-- Create date: 06-APR-2020
-- Description: Encapsulates the main test routine startup
-- ========================================================
CREATE PROCEDURE [test].[sp_tst_mn_cls] @err_msg VARCHAR(4000) = NULL
AS
BEGIN
   DECLARE
       @fn           VARCHAR(30)   = N'sp_tst_mn_cls'
      ,@tested_fn    VARCHAR(50)   = test.fnGetCrntTstdFn()
      ,@tst_fn       VARCHAR(50)   = test.fnGetCrntTstFn()
      ,@msg          VARCHAR(2000)
      ,@nl           VARCHAR(2)    = dbo.fnGetNL()
--      ,@line         VARCHAR(180)  = REPLICATE(N'*', 180)
      ,@tests_passed INT
      ,@error_st     BIT            = test.fnGetCrntTstErrSt()
--   PRINT CONCAT(@nl,@line);
   SET @msg = iif(@error_st = 0, 'Test: All sub tests passed', CONCAT('Error: 1 or more sub tests failed', @NL));
   EXEC sp_log 2, @fn, '000: Main test ', @tst_fn, ' finished, ', @msg, ' @tst_fn:[',@tst_fn,']';
   -- The disp log flag is set on startup
   -- Display Log both up and down ASC and DESC
   IF test.fnGetDisplayLogFlg() = 1
   BEGIN
      EXEC dbo.sp_appLog_display 1  -- descending order
      EXEC dbo.sp_appLog_display 0; -- ascending  order
   END
   -- Clear all flags and counters
   PRINT test.fnGetTstHdrFooterLine(1, 0, @tst_fn, CONCAT('', iif(@error_st = 0, 'PASSED', 'FAILED')));
   EXEC sp_log 0, @fn, '99: leaving';
--   PRINT CONCAT(@line, @nl);
END
/*
EXEC test.sp_tst_mn_st 'test_011_sp_import_UseStaging';
EXEC test.sp_tst_mn_cls;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2021
-- Description: Sets the @tst_num in the session context
--              Key: fnGetCrntTstNumKey()->N'Test num'
--
-- Tests:       test.test_049_SetGetCrntTstValue
-- Oppo         test.fnGetCrntTstNum()
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_num] @tst_num VARCHAR(60)
AS
BEGIN
DECLARE
    @fn     VARCHAR(35) = 'sp_tst_set_crnt_tst_num'
   ,@key    NVARCHAR(60);
   SET @key = test.fnGetCrntTstNumKey();
   EXEC sp_log 0, @fn,'000: starting, fn: ', @fn, ' key:[', @key,'] @tst_num:[',@tst_num,']';
   EXEC sp_set_session_context @key, @tst_num;
END
/*
EXEC tSQLt.Run 'test.test_030_chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests: test_049_SetGetCrntTstValue
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_1_off_setup_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE
      @fn   VARCHAR(35) = 'sp_tst_set_crnt_1_off_setup_fn'
     ,@key  NVARCHAR(40)= test.fnGetCrntTst1OffSetupFnKey()
     ;
   EXEC sp_log 0, @fn, 'starting, @val:[',@val,']';
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test_049_SetGetCrntTstValue'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test_049_SetGetCrntTstValue
-- Oppo:        test.fnGetCrntTstClseFn
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_clse_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE
    @fn  VARCHAR(35) = N'sp_tst_set_crnt_tst_clse_fn'
   ,@key NVARCHAR(40);
   SET @key = test.fnGetCrntTstClsFnKey()
   EXEC sp_log 0, @fn,'000: starting, @val: ', @val;
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.test_049_SetGetCrntTstValue
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test 030 chkTestConfig
-- Key:         N'TSU fn'
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_setup_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetCrntTstSetupFnKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstSetupFnKey()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test_030_chkTestConfig
-- Key:         'Tested fn'
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tstd_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetCrntTstdFnKey();
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test_030_chkTestConfig';
EXEC tSQLt.RunAll;
PRINT test.fnGetCrntTstdFnKey();
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests:       test_030_chkTestConfig
-- Key:         Display Log Flag
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_display_log_flg] @val BIT
AS
BEGIN
   DECLARE @key NVARCHAR(6) = test.fnGetDisplayLogFlgKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetDisplayLogFlgKey()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 04-FEB-2021
-- Description: Accessor
-- Tests: [test].[test 030 chkTestConfig]
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_fn] @val VARCHAR(80)
AS
BEGIN
   DECLARE @key NVARCHAR(40) = test.fnGetCrntTstFnKey();
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry watts
-- Create date: 05-FEB-2021
-- Description: Setter: for the test helper fn
-- Tests: [test].[test 030 chkTestConfig]
-- =============================================
CREATE PROCEDURE [test].[sp_tst_set_crnt_tst_hlpr_fn] @val VARCHAR(100)
AS
BEGIN
   DECLARE @key NVARCHAR(60) = test.fnGetCrntTstHlprFnKey()
   EXEC sp_set_session_context @key, @val;
END
/*
EXEC test.[test 030 chkTestConfig]
EXEC tSQLt.Run 'test.test 030 chkTestConfig'
EXEC tSQLt.RunAll
PRINT test.fnGetCrntTstHlprFnNmKey()
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:      Terry Watts
-- Create date: 05-FEB-2021
-- Description: main start set up
--
-- Responsibilities:
--    clear  test_pass_cnt= 0,
--
--    pop  the following:
--    crnt_tstd_fn
--    crnt_tst_fn
--    crnt_tst_hlpr_fn
--    rnt_tst_1_off_setup_fn
--    crnt_tst_setup_fn
--    crnt_tst_clse_fn
--
-- Validated preconditions:
--    PRE 01: @tst_fn must have at least 11 characters and be like: like ''test_nnn_<tested rtn mn>chkTestConfig''
--    PRE 02: the nnn @tst_fn must be a positive integer
--    PRE 02: @tst_fn must have no spaces
--
-- Postconditions 
-- CHANGES:
-- 241128: added paramater validation
-- =============================================
CREATE PROCEDURE [test].[sp_tst_mn_st_su]
       @tst_fn    VARCHAR(80)   = NULL   -- test fn like 'test 030 chkTestConfig'
      ,@log       BIT            = 1
AS
BEGIN
   DECLARE
       @tested_fn VARCHAR(60)            -- the tested function name
      ,@fn_num    VARCHAR(3)             
      ,@hlpr_fn   VARCHAR(60)            -- helper fn
      ,@tsu_fn    VARCHAR(60)            -- tsu    fn
      ,@tsu1_fn   VARCHAR(60)            -- tsu    fn
      ,@tcls_fn   VARCHAR(60)            -- close  fn
      ,@key       VARCHAR(40)
      ,@fn        VARCHAR(60) = N'sp_tst_mn_st_su'
      ,@len       INT
      ,@msg       VARCHAR(150)
      ,@is_num    BIT
   BEGIN TRY
      EXEC sp_log 0, @fn,'000: starting, @tst_fn:[',@tst_fn,']';
      ----------------------------------------------------------------------------------
      -- Validate inputs
      ----------------------------------------------------------------------------------
      EXEC sp_log 0, @fn,'010: Validate inputs';
      -- test fn like 'test 030 chkTestConfig'
      SET @len = dbo.fnLen(@tst_fn);
      EXEC sp_log 0, @fn,'020: @len: ', @len;
      SET @msg = CONCAT(' ',@fn, ' @tst_fn: [',@tst_fn,'] must have at least 11 characters and be like: like ''test_nnn_<tested rtn mn>chkTestConfig'' and have no spaces,
      nnn must be a positive integer like 015');
      -- PRE 01: @tst_fn must have at least 11 characters and be like: like ''test_nnn_<tested rtn mn>chkTestConfig''
      EXEC sp_log 0, @fn,'030 calling sp_assert_gtr_than @len: ', @len;
      EXEC sp_assert_gtr_than @len, 11, '011:', @msg;
      EXEC sp_log 0, @fn,'040';
      SET @fn_num = SUBSTRING( @tst_fn, 6, 3 );
      --EXEC sp_log 0, @fn,'010.15';
      EXEC dbo.sp_assert_not_null_or_empty @fn_num, '012: @fn_num must not be null @test_fn: ', @msg2 = @tst_fn;
      EXEC sp_log 0, @fn,'050: calling dbo.fnIsInt(',@fn_num,', 1);';
      SET @is_num = dbo.fnIsTxtInt(@fn_num, 1);
      --EXEC sp_log 0, @fn,'010.2 checking that @tst_fn has a positive integer';
--    PRE 02: the nnn @tst_fn must be a positive integer
      EXEC sp_assert_equal 1, @is_num, '060: @fn_num: [', @fn_num, '] must be a positive integer like ''015''';
      EXEC sp_log 0, @fn,'070';
      SET @tested_fn = SUBSTRING( @tst_fn, 10, 100);
      EXEC sp_log 0, @fn, '080: @tested_fn:[', @tested_fn, ']';
      EXEC dbo.sp_assert_not_null_or_empty @tested_fn, '013: tested_fn must be specified - chars 10-100 of @tst_fn psram';
      --EXEC sp_log 0, @fn,'010.4';
      -- PRE 03: @tst_fn must have no spaces
      IF CHARINDEX(' ', @tst_fn) > 0
      BEGIN
         EXEC sp_log 4, @fn,'090: @tst_fn must have no spaces';
         EXEC sp_raise_exception 56010, @fn, ' PRE 03: @tst_fn must have no spaces';
      END
      EXEC sp_log 0, @fn,'100';
      IF CHARINDEX('test_', @tst_fn )<> 1
      BEGIN
         EXEC sp_log 4, @fn,'110: test rtn nam should start with ''TEST_''';
         EXEC sp_raise_exception 53602, '100: ', @msg;
      END
      EXEC sp_log 0, @fn,'120: Validate inputs - OK';
      ----------------------------------------------------------------------------------
      -- Calc the test fn names for this test
      ----------------------------------------------------------------------------------
      -- Set the logging flag
      EXEC test.sp_tst_set_display_log_flg @log;
      SET @hlpr_fn = CONCAT(N'hlpr_', @fn_num, N' ', @tested_fn);
      SET @tsu_fn  = CONCAT(N'TSU ' , @fn_num, N' ', @tested_fn);
      SET @tsu1_fn = CONCAT(N'TSU1 ', @fn_num, N' ', @tested_fn);
      SET @tcls_fn = CONCAT(N'TCLS ', @fn_num, N' ', @tested_fn);
      ----------------------------------------------------------------------------------
      -- Validate
      ----------------------------------------------------------------------------------
      EXEC sp_log 0, @fn, '130: @tested_fn:[', @tested_fn, ']';
      EXEC sp_log 0, @fn, '140: @fn_num:[', @fn_num, ']';
      EXEC dbo.sp_assert_not_null_or_empty @hlpr_fn  , @msg1 = '140: @hlpr_fn  must be specified';
      EXEC dbo.sp_assert_not_null_or_empty @tsu_fn   , @msg1 = '150: @tsu_fn   must be specified';
      EXEC dbo.sp_assert_not_null_or_empty @tsu1_fn  , @msg1 = '160: @tsu1_fnm must be specified';
      EXEC dbo.sp_assert_not_null_or_empty @tcls_fn  , @msg1 = '170: @tcls_fn  must be specified';
      EXEC sp_log 0, @fn,'909';
      SET @len = dbo.fnLen(@fn_num);
      EXEC dbo.sp_assert_equal 3, @len ,'200: @fn_num len should be 3';
      SET @len = dbo.fnContainsWhiteSpace(@fn_num);
      EXEC dbo.sp_assert_equal 0, @len ,'210: @fn_num len should not contain spaces';
      ----------------------------------------------------------------------------------
      -- Set the state:
      ----------------------------------------------------------------------------------
      EXEC test.sp_tst_clr_test_pass_cnt;
      EXEC test.sp_tst_set_crnt_tst_num @fn_num;               --  oppo: fnGetCrntTstNum()         KEY: N'Test num'
      EXEC test.sp_tst_set_crnt_tst_num2           @fn_num;    -- Just the 3 digit test number
      EXEC test.sp_tst_set_crnt_tstd_fn @tested_fn;            --  oppo: fnGetCrntTstdFn()         KEY: N'Tested fn'
      EXEC test.sp_tst_set_crnt_tst_fn @tst_fn;                -- oppo: fnGetCrntTstFn()           KEY: N'Test fn'
      EXEC test.sp_tst_set_crnt_tst_hlpr_fn @hlpr_fn;          -- oppo: fnGetCrntTstHlprFn()       KEY: N'Hlpr fn'
      EXEC test.sp_tst_set_crnt_tst_1_off_setup_fn @tsu1_fn;   -- oppo: fnGetCrntTst1OffSetupFn()  KEY: N'TSU1 fn'
      EXEC test.sp_tst_set_crnt_tst_setup_fn @tsu_fn;          -- oppo: fnGetCrntTstSetupFn()      KEY: N'TSU fn'
      EXEC test.sp_tst_set_crnt_tst_clse_fn @tcls_fn;          -- oppo: fnGetCrntTstCloseFn()      KEY: N'TCLS fn'
      EXEC sp_log 0, @fn,'400: Processing complete';
   END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn,'500: Caught exception';
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 0, @fn,'999: leaving OK'
END
/*
EXEC sp_Set_log_level 0
EXEC test.sp_tst_mn_st_su 'test_049_SetGetCrntTstValue'
ECEC test.sp_tst_mn_st 'test_049_SetGetCrntTstValue'
EXEC tSQLt.Run 'test.test_050_sp_assert_not_null_or_zero';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- ===========================================================
-- Author:      Terry Watts
-- Create date: 06-APR-2020
-- Description: Encapsulates the main test routine startup
-- Parameters:  @tfn: the test function name
--
-- Session Keys:
--    Test fn           : 'Test fn'
--    Tested fn         : 'Tested fn'
--    Helper fn         : 'Helper fn'
--    per test setup fn : 'TSU fn'
--    1 off setup fn    : 'TSU1 fn'
--    per test close fn : 'TCLS fn'
--
-- POSTCONDITIONS:
-- POST 01: if @test_fn null or empty -> ex:
-- ===========================================================
CREATE PROCEDURE [test].[sp_tst_mn_st]
       @tst_fn VARCHAR(80)   = NULL   -- test fn
      ,@log    BIT            = 0      -- default not to display the log
AS
BEGIN
   DECLARE
       @fn                    VARCHAR(60) = N'sp_tst_mn_st'
      ,@fn_tst_pass_cnt_key   VARCHAR(50)
      ,@NL                    VARCHAR(2)    = NCHAR(13) + NCHAR(10)
      ,@Line                  VARCHAR(100)  = REPLICATE('-', 100)
      ,@tested_fn             VARCHAR(60)      -- the tested function name
--    ,@hlpr_fn               VARCHAR(60)      -- helper fn
      ,@tsu_fn                VARCHAR(60)      -- tsu    fn
      ,@tsu1_fn               VARCHAR(60)      -- tsu    fn
      ,@tcls_fn               VARCHAR(60)      -- close  fn
   BEGIN TRY
      SET NOCOUNT ON
      --PRINT test.fnGetTstHdrFooterLine(1, 1, @tst_fn, 'starting');
      DELETE FROM AppLog;
      EXEC sp_log 0, @fn, '000: starting (',@tst_fn,')';
      -- Validate Parameters
      EXEC dbo.sp_assert_not_null_or_empty @tst_fn, '@test_fn parameter must be specified';
      EXEC sp_log 0, @fn, '005';
      SET @tested_fn = SUBSTRING(@fn, 10, 99);
      EXEC sp_log 0, @fn, '006';
      -- Stop any more logging in this fn
      EXEC sp_set_session_context N'TST_MN_ST'        , 1;
      EXEC sp_log 0, @fn, '007';
      -- set up all test fn names and initial state
      EXEC sp_log 0, @fn,'010: calling sp_tst_mn_tst_st_su';
      EXEC test.sp_tst_mn_st_su
       @tst_fn = @tst_fn
      ,@log    = @log;
      EXEC sp_log 0, @fn,'015: setting context state';
      -- ASSERTION: all test fn names set up and initial state initialised properly
      -- Add static test passed count
      SET @fn_tst_pass_cnt_key  = CONCAT(@fn, N' tests passed');
      EXEC sp_set_session_context   @fn_tst_pass_cnt_key , 0;
      EXEC sp_set_session_context N'DISP_TST_RES'        , 1;
      EXEC test.sp_tst_set_crnt_tst_err_st 0;
      END TRY
   BEGIN CATCH
      EXEC sp_log 4, @fn, '500: caught exception';
      EXEC sp_log_exception @fn;
      THROW;
   END CATCH
   EXEC sp_log 0, @fn,'999: leaving OK';
END
/*
EXEC tSQLt.Run 'test.test_059_sp_tst_mn_st'
EXEC 
EXEC tSQLt.RunAll
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=======================================================================================
-- Author:           Terry Watts
-- Create date:      12-Jun-2025
-- Rtn:              test.test_068_sp_crt_pop_table
-- Description: main test routine for the dbo.sp_crt_pop_table routine 
--
-- Tested rtn description:
-- Create and populate a table from a data file
--
-- REQUIREMENTS:
-- R06.01: the table with the same name as the file is created:
-- R06.02: the table has the same column names as the column names in the file
-- R06.03: table is populated exactly from the rows and columns from the file
-- R06.04: if a column name contains spaces (any whitespace) then replace each sequence
--         of whitespace with a single underscore
--
-- Design: EA: Dorsu.eap: Dorsu Model.Conceptual Model.Create and populate a table from a data file
-- Define the import data file path
-- Table name = file name
-- Reads the header for the column names
-- Create a table with table name, columns = field names, type = text
-- Create a staging table
-- Create a format file using BCP and the table
-- Generate the import routine using the table and the format file
--
-- Parameters:
--    @file_path     VARCHAR(500) -- the import data file path
--
-- Test strategy:
-- 01. Check no error occurred
-- 02: Check the table exists
-- 03: Check the columns match the file columns
-- 04: Check the data matches
-- 04.01: check the row count of the table matches that of the file
-- 04.02: check the first row all columns
-- 04.03: check the last row all columns
--=======================================================================================
CREATE PROCEDURE [test].[test_068_sp_crt_pop_table]
AS
BEGIN
DECLARE
    @fn  VARCHAR(35) = 'test_068_sp_crt_pop_table'
   ,@tab CHAR        = CHAR(9)
   BEGIN TRY
      EXEC test.sp_tst_mn_st @fn;
      EXEC test.hlpr_068_sp_crt_pop_table
          @tst_num            = '001'
         ,@display_tables     = 1
         ,@inp_file_path      = 'D:\Dev\Property\Data\Property_Sales.Resort_Sale.tsv'
         ,@inp_format_file    = 'D:\Dev\Property\Data\Property_Sales.Resort_Sale.fmt'
         ,@inp_sep            = '0x09'
         ,@inp_codepage       = NULL
         ,@inp_display_tables = 1
         ,@exp_row_cnt        = NULL
         ,@exp_ex_num         = NULL
         ,@exp_ex_msg         = NULL
      ;
RETURN;
      EXEC test.hlpr_068_sp_crt_pop_table
          @tst_num            = '002'
         ,@display_tables     = 1
         ,@inp_file_path      = 'D:\Dorsu\Data\FileActivityLog.tsv'
--       ,@inp_format_file    = 'D:\Dev\Property\Data\Property_Sales.Resort_Sale.fmt'
         ,@inp_sep            = '0x09'
         ,@inp_codepage       = NULL
         ,@inp_display_tables = 1
         ,@exp_row_cnt        = 60286
         ,@exp_ex_num         = NULL
         ,@exp_ex_msg         = NULL
      ;
      EXEC sp_log 2, @fn, '999: All subtests PASSED';
   END TRY
   BEGIN CATCH
      EXEC sp_log 2, @fn, '520: caught exception -> sp_log_exception';
      EXEC sp_log_exception @fn;
      EXEC sp_log 2, @fn, '540: rethrowing exception';
      THROW;
   END CATCH
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC test.test_068_sp_crt_pop_table;
SELECT TOP 200 * FROM GenericStaging;
EXEC tSQLt.Run 'test.test_068_sp_crt_pop_table';
EXEC sp_crt_pop_table 'D:\Dev\Property\Data\PropertySales.txt';
EXEC sp_AppLog_Display 'hlpr_068_sp_crt_pop_table';
EXEC sp_AppLog_Display;
SELECT COUNT(*) FROM GenericStaging;
SELECT TOP 200 * FROM GenericStaging;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=================================================================
-- Author:           Terry Watts
-- Create date:      13-Jun-2025
-- Rtn:              test.test_069_fnCrtTblSql
-- Description: main test routine for the dbo.fnCrtTblSql routine 
--
-- Tested rtn description:
-- creates the SQL to create a table
--              based on the input string
--              All fields are VARCHAR(MAX)
--
-- PRECONDITIONS:
--    none
--
-- POSTCONDITIONS:
--    returns creat table SQL
--
-- Tests:
--=================================================================
CREATE PROCEDURE [test].[test_069_fnCrtTblSql]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_069_fnCrtTblSql'
   EXEC test.sp_tst_mn_st @fn;
   EXEC test.hlpr_069_fnCrtTblSql
       @tst_num      = '002'
      ,@inp_tbl_nm   = 'TestTable'
      ,@inp_fields   = ' Name 	 Type 	Area 	Delegate 	Status 	Quality 	Contact_nm 	Agnt_Comm_split 	Jan_20_2025 	Jan_16_2025 	Dec_09_2024 	preferred_contact_method 	phone 	Alt_phone 	Whatsapp 	Facebook 	messenger 	website 	email 	Address 	Notes 	Old_Notes 	date 	Actions_08-OCT 	date_2 	Actions_12-sep 	date_3 	date_4 	Actions_18-Aug 	Old_Status 	Action_By_dt 	Replied 	Visit 	 History '
      ,@exp_sql      = 'CREATE TABLE TestTable
(
    [Name] VARCHAR(8000)
   ,[Type] VARCHAR(8000)
   ,Area VARCHAR(8000)
   ,Delegate VARCHAR(8000)
   ,[Status] VARCHAR(8000)
   ,Quality VARCHAR(8000)
   ,Contact_nm VARCHAR(8000)
   ,Agnt_Comm_split VARCHAR(8000)
   ,Jan_20_2025 VARCHAR(8000)
   ,Jan_16_2025 VARCHAR(8000)
   ,Dec_09_2024 VARCHAR(8000)
   ,preferred_contact_method VARCHAR(8000)
   ,phone VARCHAR(8000)
   ,Alt_phone VARCHAR(8000)
   ,Whatsapp VARCHAR(8000)
   ,Facebook VARCHAR(8000)
   ,messenger VARCHAR(8000)
   ,website VARCHAR(8000)
   ,email VARCHAR(8000)
   ,[Address] VARCHAR(8000)
   ,Notes VARCHAR(8000)
   ,Old_Notes VARCHAR(8000)
   ,[date] VARCHAR(8000)
   ,Actions_08_OCT VARCHAR(8000)
   ,date_2 VARCHAR(8000)
   ,Actions_12_sep VARCHAR(8000)
   ,date_3 VARCHAR(8000)
   ,date_4 VARCHAR(8000)
   ,Actions_18_Aug VARCHAR(8000)
   ,Old_Status VARCHAR(8000)
   ,Action_By_dt VARCHAR(8000)
   ,Replied VARCHAR(8000)
   ,Visit VARCHAR(8000)
   ,History VARCHAR(8000)
);'
;
   EXEC test.hlpr_069_fnCrtTblSql
       @tst_num      = '001'
      ,@inp_tbl_nm   = 'TestTable'
      ,@inp_fields   = 'id, name,description, location'
      ,@exp_sql      = 'CREATE TABLE TestTable
(
    id VARCHAR(8000)
   ,[name] VARCHAR(8000)
   ,[description] VARCHAR(8000)
   ,[location] VARCHAR(8000)
);'
;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC test.test_069_fnCrtTblSql;
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--==============================================================================
-- Author:           Terry Watts
-- Create date:      05-Sep-2025
-- Rtn:              test.test_070_fnIsValidTableColumnName
-- Description: main test routine for the dbo.fnIsValidTableColumnName routine 
--
-- Tested rtn description:
--
-- Design:
-- Tests:
-- Author:
-- Create date:
--==============================================================================
CREATE PROCEDURE [test].[test_070_fnIsValidTableColumnName]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_070_fnIsValidTableColumnName'
   EXEC test.sp_tst_mn_st @fn;
   -- 1 off setup  ??
   EXEC test.hlpr_070_fnIsValidTableColumnName  '001','', 0;
   EXEC test.hlpr_070_fnIsValidTableColumnName  '001',' ', 0;
   EXEC test.hlpr_070_fnIsValidTableColumnName  '002','a', 1;
   EXEC test.hlpr_070_fnIsValidTableColumnName  '003','a b', 0;
   EXEC test.hlpr_070_fnIsValidTableColumnName  '004','SET', 0;
   EXEC test.hlpr_070_fnIsValidTableColumnName  '005','DATE', 0;
   EXEC test.hlpr_070_fnIsValidTableColumnName  '006','date', 0;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.Run 'test.test_070_fnIsValidTableColumnName';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--===================================================================
-- Author:           Terry Watts
-- Create date:      05-Sep-2025
-- Rtn:              test.test_071_sp_drop_table
-- Description: main test routine for the dbo.sp_drop_table routine 
--
-- Tested rtn description:
-- Drops a table if it exists
-- Design:
-- Tests:
--
-- PRECONDITIONS:
-- PRE 01 @tbl_nm must be specified NOT NULL or EMPTY Checked
--
-- POSTCONDITIONS:
-- POST01: table does not exist
--===================================================================
CREATE PROCEDURE [test].[test_071_sp_drop_table]
AS
BEGIN
DECLARE
    @fn VARCHAR(35) = 'test_071_sp_drop_table'
   ,@tst VARCHAR(10)
   ,@tbl VARCHAR(10)
   ;
   EXEC test.sp_tst_mn_st @fn;
   CREATE TABLE test.test_071_1
   (
      id INT
   );
   BEGIN TRY
      -- 1 off setup  ??
      SET @tst = '001';
      SET @tbl = NULL;
      EXEC test.hlpr_071_sp_drop_table
          @tst_num            = @tst
         ,@display_tables     = 0
         ,@inp_q_table_nm     = @tbl
         ,@exp_row_cnt        = NULL
         ,@exp_rc             = NULL
         ,@exp_ex_num         = 50005
         ,@exp_ex_msg         = '@q_table_nm must be specified'
      ;
      SET @tst = '002';
      SET @tbl = '';
      EXEC test.hlpr_071_sp_drop_table
          @tst_num            = @tst
         ,@display_tables     = 0
         ,@inp_q_table_nm     = @tbl
         ,@exp_row_cnt        = NULL
         ,@exp_rc             = NULL
         ,@exp_ex_num         = 50005
         ,@exp_ex_msg         = '@q_table_nm must be specified'
      ;
      SET @tst = '003';
      SET @tbl = 'test.test_071_1';
      EXEC test.hlpr_071_sp_drop_table
          @tst_num            = @tst
         ,@display_tables     = 0
         ,@inp_q_table_nm     = @tbl
         ,@exp_row_cnt        = NULL
         ,@exp_rc             = NULL
         ,@exp_ex_num         = NULL
         ,@exp_ex_msg         = NULL
      ;
   END TRY
   BEGIN CATCH
      EXEC sp_log_exception @fn, '500: caught exception test: ' ,@tst;
      EXEC sp_drop_table @tbl;
      THROW;
   END CATCH
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.Run 'test.test_071_sp_drop_table';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=====================================================================
-- Author:           Terry Watts
-- Create date:      05-Sep-2025
-- Rtn:              test.test_072_fnWrapFieldName
-- Description: main test routine for the dbo.fnWrapFieldName routine 
--
-- Tested rtn description:
--
-- Design:
-- Tests:
--=====================================================================
CREATE PROCEDURE [test].[test_072_fnWrapFieldName]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_072_fnWrapFieldName'
   EXEC test.sp_tst_mn_st @fn;
   EXEC test.hlpr_072_fnWrapFieldName '001', NULL, NULL, NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '002', '', '', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '003', 'info', 'info', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '004', 'name', '[name]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '005', 'description', '[description]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '006', 'abs', '[abs]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '007', 'ABS', '[ABS]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '008', 'WRITETEXT', '[WRITETEXT]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '009', 'writetext', '[writetext]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '010', 'date', '[date]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '011', 'current_date', '[current_date]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '012', 'status', '[status]', NULL, NULL;
   EXEC test.hlpr_072_fnWrapFieldName '012', 'STATUS', '[STATUS]', NULL, NULL;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.Run 'test.test_072_fnWrapFieldName';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=========================================================================
-- Author:           Terry Watts
-- Create date:      16-Jun-2025
-- Rtn:              test.test_073_fnDeLimitIdentifier
-- Description: main test routine for the dbo.fnDeLimitIdentifier routine 
--
-- Tested rtn description:
-- delimits identifier  if necessary
-- Design:
-- Tests:
--=========================================================================
CREATE PROCEDURE [test].[test_073_fnDeLimitIdentifier]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_073_fnDeLimitIdentifier'
   EXEC test.sp_tst_mn_st @fn;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '001'
      ,@inp_q_id           = NULL
      ,@exp_out_val        = NULL
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '002'
      ,@inp_q_id           = ''
      ,@exp_out_val        = ''
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '003'
      ,@inp_q_id           = 'User'
      ,@exp_out_val        = '[User]'
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '004'
      ,@inp_q_id           = 'int.User'
      ,@exp_out_val        = '[int].[User]'
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '005'
      ,@inp_q_id           = 'db.int.User'
      ,@exp_out_val        = 'db.[int].[User]'
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '006'
      ,@inp_q_id           = 'db.dbo.Enrollment Staging'
      ,@exp_out_val        = 'db.dbo.[Enrollment Staging]'
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC test.hlpr_073_fnDeLimitIdentifier
       @tst_num            = '007'
      ,@inp_q_id           = 'db.dbo.[Enrollment Staging]'
      ,@exp_out_val        = 'db.dbo.[Enrollment Staging]'
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_073_fnDeLimitIdentifier';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--===============================================================================
-- Author:           Terry Watts
-- Create date:      09-Sep-2025
-- Rtn:              test.test_074_sp_crt_pop_property_sales
-- Description: main test routine for the dbo.sp_crt_pop_property_sales routine 
--
-- Tested rtn description:
-- Clean populates the Property sales tables
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:
-- Tests:
--===============================================================================
CREATE PROCEDURE [test].[test_074_sp_crt_pop_property_sales]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_075_sp_crt_pop_property_sales'
   EXEC test.sp_tst_mn_st @fn;
   -- 1 off setup  ??
   EXEC test.hlpr_074_sp_crt_pop_property_sales
       @tst_num            = '001'
      ,@inp_file_path      = 'D:\Dev\Property\Data\Property Sales - Resort Sale.tsv'
      ,@inp_table_nm       = 'CRM'
      ,@display_tables     = 1
      ,@exp_row_cnt        = NULL
      ,@exp_rc             = NULL
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_074_sp_crt_pop_property_sales';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--==========================================================================
-- Author:           Terry Watts
-- Create date:      17-Jun-2025
-- Rtn:              test.test_074_sp_infer_field_types
-- Description: main test routine for the dbo.sp_infer_field_types routine 
--
-- Tested rtn description:
-- infers the field types froma staging table
--    based on its data
--
-- EXEC tSQLt.Run 'test.test_<nnn>_<proc_nm>';
-- Design:
-- Tests:
--==========================================================================
CREATE PROCEDURE [test].[test_075_sp_infer_field_types]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_075_sp_infer_field_types'
   EXEC test.sp_tst_mn_st @fn;
   -- Property Sales - Resort SaleStaging
   EXEC test.hlpr_075_sp_infer_field_types
       @tst_num            = '001'
      ,@display_tables     = 1
      ,@inp_q_table_nm     = 'dbo.Property Sales - Resort SaleStaging'
      ,@exp_row_cnt        = NULL
      ,@exp_rc             = NULL
      ,@exp_ex_num         = 50001
      ,@exp_ex_msg         = 'Table dbo.FileActivityLogStaging does not exist but should'
   ;
   -- Preconditions: PRE01: table must exist or exception 50001 'Table '<@q_table_nm> does not exist
   EXEC test.hlpr_075_sp_infer_field_types
       @tst_num            = '002'
      ,@display_tables     = 1
      ,@inp_q_table_nm     = 'dbo.FileActivityLogStaging'
      ,@exp_row_cnt        = NULL
      ,@exp_rc             = NULL
      ,@exp_ex_num         = 50001
      ,@exp_ex_msg         = 'Table dbo.FileActivityLogStaging does not exist but should'
   ;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC test.test_075_sp_infer_field_types;
SELECT * FROM FileActivityLog;
SELECT * FROM FileActivityLogStaging;
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_075_sp_infer_field_types';
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =======================================================================
-- Author:           Terry Watts
-- Create date:      17-Jun-2025
-- Description: main test routine for the dbo.fnCrtFldNotNullSql routine 
--
-- Tested rtn description:
--
-- =======================================================================
CREATE PROCEDURE [test].[test_076_fnCrtFldNotNullSql]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_076_fnCrtFldNotNullSql'
   EXEC test.sp_tst_mn_st @fn;
   EXEC test.hlpr_076_fnCrtFldNotNullSql
       @tst_num         = '001'
      ,@inp_q_table_nm  =  'dbo.Property Sales - Resort SaleStaging'
      ,@inp_fld_nm      = 'FilePath'
      ,@inp_ty          = 'BIT'
      ,@exp_sql         = 'IF NOT EXISTS
(
   SELECT 1 FROM dbo.[Property Sales - Resort SaleStaging]
   WHERE TRY_CAST([Name] AS BIT) IS NULL
)
   SET @fld_ty = ''BIT''
ELSE
   SET @fld_ty = NULL
;'
      ;
   EXEC test.hlpr_076_fnCrtFldNotNullSql
       @tst_num         = '002'
      ,@inp_q_table_nm  = 'dbo.FileActivityLogStaging'
      ,@inp_fld_nm      = 'FilePath'
      ,@inp_ty          = 'BIT'
      ,@exp_sql         = 'IF NOT EXISTS
(
   SELECT 1 FROM dbo.FileActivityLogStaging
   WHERE TRY_CAST([FilePath] AS BIT) IS NULL
)
   SET @fld_ty = ''BIT''
ELSE
   SET @fld_ty = NULL
;'
      ;
   -- 'dbo.Property Sales - Resort SaleStaging'
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.RunAll;
EXEC tSQLt.Run 'test.test_076_fnCrtFldNotNullSql';
      ,@exp_ex_num         = NULL
      ,@exp_ex_msg         = NULL
   ;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--=========================================================================
-- Author:           Terry Watts
-- Create date:      09-Sep-2025
-- Rtn:              test.test_077_fnNameNeedsBrackets
-- Description: main test routine for the dbo.fnNameNeedsBrackets routine 
--
-- Tested rtn description:
-- returns 1 if name needs brackets.
--    i.e. is a reserver word or has some wierd characters
-- Design:
-- Tests:
--=========================================================================
CREATE PROCEDURE [test].[test_077_fnNameNeedsBrackets]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_077_fnNameNeedsBrackets'
   EXEC test.sp_tst_mn_st @fn;
   EXEC test.hlpr_077_fnNameNeedsBrackets '000', NULL,      1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '001', '',        1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '002', a,         0;
   EXEC test.hlpr_077_fnNameNeedsBrackets '003', '1asd',    1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '004', '!',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '005', '@',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '006', '#',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '007', '$',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '008', '*',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '009', '%',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '010', '^',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '011', '&',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '012', '*',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '013', 'abs(de',  1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '014', 'asd)f',   1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '015', '-',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '016', '+',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '017', '=',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '018', '~',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '019', '`',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '020', '|',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '021', '\\',      1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '022', '/',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '023', '?',       1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '024', 'for',     1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '025', 'while',   1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '026', 'for',     1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '027', 'varchar', 1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '027', 'REAL',    1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '027', 'nVarchar',1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '027', 'INT',     1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '027', 'DATE',    1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '027', 'varchar', 1;
   EXEC test.hlpr_077_fnNameNeedsBrackets '028', 'out',     1;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.Run 'test.test_077_fnNameNeedsBrackets';
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
--==============================================================================
-- Author:           Terry Watts
-- Create date:      12-Sep-2025
-- Rtn:              test.test_078_sp_import_property_sales
-- Description: main test routine for the dbo.sp_import_property_sales routine 
--
-- Tested rtn description:
--
-- Design:      EA:
-- Tests:
--
-- Preconditions:
-- Postconditions: POST01: following tabnle are populated:
--    PropertySalesStaging
--    PropertySales
--    Agency         merge
--    Contacts       merge
--    Delegate       merge
--    Status         merge ??
--==============================================================================
CREATE PROCEDURE [test].[test_078_sp_import_property_sales]
AS
BEGIN
DECLARE
   @fn VARCHAR(35) = 'test_078_sp_import_property_sales'
   EXEC test.sp_tst_mn_st @fn;
   -- 1 off setup  ??
   EXEC test.hlpr_078_sp_import_property_sales
       @tst_num               = '001'
      ,@display_tables        = 1
      ,@inp_file              = 'D:\Dev\CRM\SQL\Tests\078_sp_import_property_sales\Property Sales.xlsx'
      ,@inp_worksheet         = 'Resort Sale'
      ,@inp_range             = 'A1:AA93'
      ,@exp_row_cnt           = 92
      ,@exp_rc                = 0
      ,@exp_agency_cnt        = 92
      ,@exp_contact_cnt       = 3
      ,@exp_contactAgency_cnt = 1
      ,@exp_ex_num            = NULL
      ,@exp_ex_msg            = NULL
   ;
   EXEC sp_log 2, @fn, '99: All subtests PASSED'
   EXEC test.sp_tst_mn_cls;
END
/*
EXEC tSQLt.Run 'test.test_078_sp_import_property_sales';
EXEC test.test_078_sp_import_property_sales;
EXEC tSQLt.RunAll;
*/
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [dbo].[Action](
	[action_id] [int] IDENTITY(1,1) NOT NULL,
	[action_nm] [nvarchar](35) NOT NULL,
 CONSTRAINT [PK__Action__3214EC27EB7E80FD] PRIMARY KEY CLUSTERED 
(
	[action_id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY],
 CONSTRAINT [UQ_Action_nm] UNIQUE NONCLUSTERED 
(
	[action_nm] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON, OPTIMIZE_FOR_SEQUENTIAL_KEY = OFF) ON [PRIMARY]
) ON [PRIMARY]
GO

